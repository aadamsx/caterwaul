Wrappers.
Specifies function transforms for all of the basic datatypes. Analogous to Divergence's .fn() method, d() returns a function for each of them. The conversions are roughly the same as before,
though with more versatility:

  Strings.   These are evaluated as function body expressions, just like they are in the first version of Divergence. However, further parameters can be passed to preserve closure state or to
             rename variables. For example, you can now specify things like this: 'x + $0', with the hash {x: 5}; this creates a local let-binding.
  Numbers.   These are mapped as before; 0 to arguments[0], 1 to arguments[1], etc. Negative numbers map to entries backwards from the end; e.g. -1 == arguments[arguments.length - 1]. If the
             number has a fractional component, then it is interpreted as 
  Arrays.    A componentwise homomorphic container for other types. d() is invoked on each element, and the resulting function returns an array of each result.
  Booleans.  Maps to d(0) if true, false if false. This serves as an 'and' map, basically.
  RegExps.   Maps to the .exec() method. This has the advantage that a match returns an array, whereas a failed match returns null.
  Functions. Normally are returned identically. However, further options may be provided to decompile and transform the function, alter its binding, or preload arguments.

New bindings that weren't possible before are these:

  Hashes.    A value-wise homomorphic container for other types. d() is called on each value, and the function returns a hash mapping the original keys to the new results.
  Undefined. Returns a function which always returns undefined.
  Null.      Returns a function which always returns null.

The general form of a call to d() is this:

| d (value, [modifier, [modifier, ...]])

Modifiers can also be any type, and there are some standard forms:

  Strings.   If an identifier, then it is looked up as a method of d. A common example is lifting over arrays: d(f, 'array_lift'), which is equivalent to d.array_lift(d(f)). You can specify
             arbitrarily many of these, and they will be applied left-to-right.

  Numbers.   
