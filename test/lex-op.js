// Operation lexing tests.

var t = function (s)    {return aeq(divergence.lex(s), Array.prototype.slice.call(arguments, 1))},
    s = function (s)    {return t(s, s)},
    q = function (s, e) {return aeq(divergence.lex(s), e.split(/\s+/))},
    Q = function (s)    {return q(s, s)};

// Simple expressions.

q('3+5', '3 + 5');
q('3-5', '3 - 5');
q('3*5', '3 * 5');

Q('3 + 5');
Q('3 - 5');
Q('3 * 5');
Q('3 / 5');
Q('4 % 5');
Q('5 ^ 6');
Q('6 & 7');
Q('7 | 8');

Q('1 > 2');
Q('1 < 2');
Q('1 >> 2');
Q('1 << 2');
Q('1 >>> 2');

Q('.3 + .5');
Q('.3 - .5');
Q('.3 * .5');
Q('.3 / .5');

// Pathological numerical cases.

q('1.2e+3+4', '1.2e+3 + 4');
q('1.2E10+5', '1.2E10 + 5');
q('1E10+2',   '1E10 + 2');
q('1E+10+4E+10', '1E+10 + 4E+10');

q('0x14.toString', '0x14 . toString');
q('0xE+5', '0xE + 5');

q('0644.toString', '0644 . toString');
q('0x511e+10e+10', '0x511e + 10e+10');

// Regular expression inference.

q('return /foo/g', 'return /foo/g');
q('throw /foo/g', 'throw /foo/g');
q('case /foo/g:', 'case /foo/g :');

q('bar /foo/g', 'bar / foo / g');
q('3.5 /foo/g', '3.5 / foo / g');
q('false /foo/g', 'false / foo / g');

// Pre/post increment and decrement.

q('x++ /foo/g', 'x ++ / foo / g');
q('x+++ /foo/g', 'x ++ + /foo/g');
q('++x /foo/g', 'u++ x / foo / g');
q('++x+ /foo/g', 'u++ x + /foo/g');

q('x-- /foo/g', 'x -- / foo / g');
q('x--+ /foo/g', 'x -- + /foo/g');
q('--x /foo/g', 'u-- x / foo / g');
q('--x+ /foo/g', 'u-- x + /foo/g');

// Generated by SDoc 