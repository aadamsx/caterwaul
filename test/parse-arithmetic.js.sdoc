Arithmetic/expression tests for the parser.

var p = function (s, i) {return eq(caterwaul.parse(caterwaul.lex(s)).inspect(), i)};

Basic precedence

p('3+5', '(+ (3) (5))');
p('3*5+6', '(+ (* (3) (5)) (6))');
p('3+5*6', '(+ (3) (* (5) (6)))');

Associativity

p('3+4+5', '(+ (+ (3) (4)) (5))');
p('3*4*5', '(* (* (3) (4)) (5))');
p('3-4-5', '(- (- (3) (4)) (5))');
p('3/4/5', '(/ (/ (3) (4)) (5))');

p('3=4=5', '(= (3) (= (4) (5)))');
p('3+=4+=5', '(+= (3) (+= (4) (5)))');
p('3-=4+=5', '(-= (3) (+= (4) (5)))');
p('3*=4+=5', '(*= (3) (+= (4) (5)))');
p('3/=4+=5', '(/= (3) (+= (4) (5)))');

Parentheses

p('(3+5)*6', '(* (( (+ (3) (5))) (6))');
p('6*(3+5)', '(* (6) (( (+ (3) (5))))');
p('((3))+((5))', '(+ (( (( (3))) (( (( (5))))');
p('((3+5))', '(( (( (+ (3) (5))))');

p('(3)(4)', '(() (( (3)) (( (4)))');
p('(3)(4)(5)', '(() (() (( (3)) (( (4))) (( (5)))');
p('3(4)', '(() (3) (( (4)))');
p('(3)[4]', '([] (( (3)) ([ (4)))');
p('3[4]', '([] (3) ([ (4)))');

Array literals

p('[1, 2, 3]', '([ (, (, (1) (2)) (3)))');
p('[1, 2][0]', '([] ([ (, (1) (2))) ([ (0)))');
p('[1][2, 3]', '([] ([ (1)) ([ (, (2) (3))))');
p('[1][2][3]', '([] ([] ([ (1)) ([ (2))) ([ (3)))');

Object notation

p('foo.bar', '(. (foo) (bar))');
p('foo.bar.bif', '(. (. (foo) (bar)) (bif))');
