// Code tracing module | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// The tracing configuration lets you create traces of code as it executes. It gives you a uniform interface to observe the evaluation of each expression in the program. To do this, first enable
// the 'trace' configuration, then add hooks. For example, here's a profiler:

// | var tracer  = caterwaul.clone('trace');
//   var timings = {};
//   var timers  = [];
//   tracer.tracing.before(fn[expression, index]       [timings[index] = timings[index] || 0, timers.push(+new Date())]).
//                   after(fn[expression, value, index][timings[index] += +new Date() - timers.pop()]);

// Interface details.
// Tracing things involves modifying the generated expressions in a specific way. First, the tracer marks that an expression will be evaluated. This is done by invoking a 'start' function, which
// then alerts all of the before-evaluation listeners. Then the tracer evaluates the original expression, capturing its output and alerting listeners in the process. Listeners are free to use
// and/or modify this value, but doing so may change how the program runs. (Note that value types are immutable, so in this case no modification will be possible.)

// There is currently no way to catch errors generated by the code. This requires a more aggressive and much slower method of tracing, and most external Javascript debuggers can give you a
// reasonable stack trace. (You can also deduce the error location by observing the discrepancy between before and after events.)

// Here is the basic transformation applied to the code:

// | some_expression   ->   (before_hook(qs[some_expression], some_index), after_hook(qs[some_expression], some_expression, some_index))

// The index is an integer that uniquely identifies the expression. This prevents you from having to do anything too weird trying to use syntax trees as hash-keys. (This isn't safe anyway due to
// the intensionality of syntax nodes and their semantics.)

// Note that the tracer inserts itself as an after-step in the compilation process. This means that if you have other after-configurations, you should think about whether you want them to operate
// on the traced or untraced code. If untraced, then you should configure caterwaul with those configurations first:

// | caterwaul.clone('X trace')    // X sees untraced code, then trace takes X's output
//   caterwaul.clone('trace X')    // X sees traced code, which is probably not what you want

// If for some reason you need to modify the listener lists, you can access the arrays directly using your_caterwaul.tracing.before_listeners and your_caterwaul.tracing.after_listeners.

// The hard part.
// If Javascript were any kind of sane language this module would be trivial to implement. Unfortunately, however, it is fairly challenging, primarily because of two factors. One is the role of
// statement-mode constructs, which can't be wrapped directly inside function calls. The other is method invocation binding, which requires either (1) no record of the value of the method itself,
// or (2) caching of the object. In this case I've written a special function to handle the caching to reduce the complexity of the generated code.

// Because certain forms can't be quoted directly, I call Caterwaul's parse function to get syntax trees. This shouldn't be too alarming, but there's a reason I'm not using qs[] or qse[].

// Gory details.
// Here's the list of transformations broken down by construct. Transformation is denoted by T[], and the generic hook transformation is denoted by H[]. T is understood to be recursive, since it
// drives the tree descent. First, here are the statement-mode transformations:

// | T[function foo (x, y) {body}]                                 -> function foo (x, y) {T[body]}
//   T[var x = y, z = w]                                           -> var x = T[y], z = T[w]
//   T[var x]                                                      -> var x
//   T[const x = y, z = w]                                         -> const x = T[y], z = T[w]                     // Most people don't use this, but just in case...
//   T[if (x) y; else z]                                           -> if (T[x]) T[y]; else T[z];
//   T[if (x) y;]                                                  -> if (T[x]) T[y];
//   T[for (x; y; z) w;]                                           -> for (T[x]; T[y]; T[z]) T[w];
//   T[for (x in y) z;]                                            -> for (x in T[y]) T[z];                        // Exceptional case: can't transform x because lvalue is implied
//   T[for (var x in y) z;]                                        -> for (var x in T[y]) T[z];
//   T[while (x) y;]                                               -> while (T[x]) T[y];
//   T[do x; while (y);]                                           -> do T[x]; while (T[y]);
//   T[try {x} catch (e) {y} finally {z}]                          -> try {T[x]} catch (e) {T[y]} finally {T[z]}
//   T[try {x} catch (e) {y}]                                      -> try {T[x]} catch (e) {T[y]}
//   T[return x]                                                   -> return T[x]
//   T[return]                                                     -> return
//   T[throw x]                                                    -> throw T[x]
//   T[break label]                                                -> break label                                  // Exceptional case: labels aren't transformed
//   T[break]                                                      -> break
//   T[continue label]                                             -> continue label
//   T[continue]                                                   -> continue
//   T[label: for ...]                                             -> label: T[for ...]
//   T[label: while ...]                                           -> label: T[while ...]
//   T[switch (x) {case v1: e1; break; ...; default: en}]          -> switch (T[x]) {case v1: T[e1]; break; ...; default: T[en]}
//   T[with (x) y;]                                                -> with (T[x]) T[y];
//   T[x; y]                                                       -> T[x]; T[y]
//   T[{x}]                                                        -> {T[x]}                                       // Done by context on statement-level things (because we trace object literals)

// And here are the expression-mode transformations:

// | T[function (x, y) {body}]                                     -> H[function (x, y) {T[body]}]
//   T[x ? y : z]                                                  -> H[T[x] ? T[y] : T[z]]
//   T[x + y]                                                      -> H[T[x] + T[y]]                               // For most binary operators; exceptions listed below
//   T[+x]                                                         -> H[+T[x]]                                     // For most unary operators; exceptions listed below
//   T[++x], T[--x], T[x++], T[x--]                                -> H[++x], H[--x], H[x++], H[x--]               // Lvalue, so can't trace the first value without disassembling the ++ or --
//   T[[x, y, z]]                                                  -> H[[T[x], T[y], T[z]]]
//   T[{x: y, z: w}]                                               -> H[{x: T[y], z: T[w]}]
//   T[object.method(x, y)]                                        -> M[T[object], T[method], [T[x], T[y]]]        // M[] is like H[], but preserves invocation binding
//   T[new f(x, y)]                                                -> H[new T[f](T[x], T[y])]                      // No H[] around the function call
//   T[delete x.y]                                                 -> H[delete T[x].y]                             // Lvalue, so can't trace y
//   T[void x]                                                     -> H[void T[x]]                                 // No point really, but capturing for completeness
//   T[typeof x]                                                   -> H[typeof x]                                  // Can't trace x due to potential ReferenceErrors if it isn't in scope
//   T[f(x, y)]                                                    -> H[T[f](T[x], T[y])]
//   T[x.y]                                                        -> H[T[x].y]
//   T[x.y = z]                                                    -> H[T[x].y = T[z]]
//   T[x[y] = z]                                                   -> H[T[x][T[y]] = T[z]]
//   T[x = y]                                                      -> H[x = T[y]]                                  // And all variants such as +=, -=, etc
//   T['literal']                                                  -> 'literal'                                    // Literal syntax nodes aren't traced
//   T[x, y]                                                       -> T[x], T[y]
//   T[x]                                                          -> H[x]                                         // For all identifiers x
//   T[undefined]                                                  -> H[undefined]                                 // undefined is a variable, not a literal (I'm reminding myself)

  caterwaul.tconfiguration('std seq continuation', 'trace', function () {
    this.namespace('tracing') /se[_.before_listeners = [], _.after_listeners = [], _.before(f) = _ /se[_.before_listeners.push(f)], _.after(f) = _ /se[_.after_listeners.push(f)]],

    this.after(
// Generated by SDoc 
