// Memoization module | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This memoizer is implemented a bit differently from Perl's memoize module; this one leaves more up to the user. To mitigate the difficulty involved in using it I've written a couple of default
// proxy functions. The basic model is that functions are assumed to map some 'state' (which obviously involves their arguments, but could involve other things as well) into either a return value
// or an exception. This memoization library lets you introduce a proxy around a function call:

// | var null_proxy = fn[context, args, f][f.apply(context, args)];                                        // Identity memoizer (does no memoization)
//   var memo_proxy = fn[context, args, f][this[args[0]] || (this[args[0]] = f.apply(context, args))];     // Memoizes on first argument
//   var identity = caterwaul.memoize.from(null_proxy);
//   var memoizer = caterwaul.memoize.from(memo_proxy);
//   var fibonacci = memoizer(fn[x][x < 2 ? x : fibonacci(x - 1) + fibonacci(x - 2)]);                     // O(n) time

// Here the 'fstate' argument represents state specific to the function being memoized. 'f' isn't the real function; it's a wrapper that returns an object describing the return value. This object
// contains:

// | 1. The amount of time spent executing the function. This can be used later to expire memoized results (see the 'heap' module for one way to do this).
//   2. Any exceptions thrown by the function.
//   3. Any value returned by the function.

// Internals.
// The core interface is the proxy function, which governs the memoization process at a low level. It is invoked with three parameters: the invocation context, the original 'arguments' object,
// and the function being memoized (wrapped by a helper, explained below). It also receives an implicit fourth as 'this', which is bound to a generic object specific to the memoized function. The
// proxy function owns this object, so it's allowed to manipulate it in any way.

//   Helpers.
//   The function passed into the proxy isn't the original. It's been wrapped by a result handler that captures the full range of things the function can do, including throwing an exception. This
//   guarantees the following things:

//   | 1. The wrapped function will never throw an exception.
//     2. The wrapped function will always return a truthy value, and it will be an object.
//     3. Each invocation of the wrapped function is automatically timed, and the time is accessible via the .time attribute on its return value.

//   The proxy function is expected to return one of these values, which will then be translated into the corresponding real action.

  caterwaul.tconfiguration('std seq continuation', 'memoize', function () {
    this.namespace('memoize') /se.m[m.wrap(f) = fn_[l[as = arguments, start = +new Date()] in unwind_protect[{error: e}][{result: f.apply(this, as)}] /se[_.time = +new Date() - start]]
                                                /se[_.original = f],
                                    m.perform(result) = result.error ? unwind[result.error] : result.result,
                                    m.from(proxy) = fn[f][l[state = {}, g = m.wrap(f)] in fn_[m.perform(proxy.call(state, this, arguments, g))]]]});
// Generated by SDoc 
