// Heap implementation | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This module provides a basic heap implementation on top of finite caterwaul sequences. The heap is parameterized by a function that orders elements, returning true if the element belongs more
// towards the root and false otherwise. (So a minheap on numbers or strings would use the function fn[x, y][x < y].)

// Usage.
// caterwaul.heap is a function that takes an order function and returns a constructor for heaps implementing that ordering. So, for example:

// | var minheap = caterwaul.heap(fn[x, y][x < y]);
//   var h = new minheap();
//   h.insert(10).insert(20).root()        // -> 10
//   h.rroot()                             // -> 10, removes the root

  caterwaul.tconfiguration('std seq', 'heap', function () {
    this.heap(less) = fc_[null] /se.c[c.prototype = new caterwaul.seq.finite() /se[_.constructor = c] /se[
      _.insert(x) = this.push(x).heapify_up(this.size() - 1),
      _.root()    = this[0],
      _.rroot()   = this[0] /se[this.pop() /se[this[0] = _, this.heapify_down(0), when[this.size()]]],

// Implementation.
// There's some less-than-obvious math going on here. Down-heapifying requires comparing an element to its two children and finding the top of the three. We then swap that element into the top
// position and heapify the tree that we swapped.

// Normally in a heap the array indexes are one-based, but this is inconvenient considering that everything else in Javascript is zero-based. To remedy this, I'm using some makeshift offsets. We
// basically transform the index in one-based space, but then subtract one to get its zero-based offset. Normally the left and right offsets are 2i and 2i + 1, respectively; in this case, here's
// the math:

// | right = 2(i + 1) + 1 - 1 = 2(i + 1)
//   left  = 2(i + 1) - 1     = right - 1

      _.swap(i, j)      = this /se[_[j] = _[i], _[i] = temp, where[temp = _[j]]],
      _.heapify_up(i)   = this /se[_.swap(i, p).heapify_up(p), when[less.call(_, _[i], _[p])], where[p = i >> 1]],
      _.heapify_down(i) = this /se[_.swap(lr, i).heapify_down(lr), unless[lr === i],
                                   where*[s = _.size(), r = i + 1 << 1, l = r - 1, ll = l < s && less.call(_, _[l], _[i]) ? l : i, lr = r < s && less.call(_, _[r], _[ll]) ? r : ll]]]]});
// Generated by SDoc 
