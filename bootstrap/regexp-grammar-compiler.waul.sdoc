Regular expression grammar compiler | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This module compiles regular expression grammars into polymorphic cons cells with associated parsing and serialization methods. Most regular expression syntax is supported and maps
transparently to Javascript data structures. Here is the mapping:

| 1. Repetition is encoded in array form: x* maps to [x1, x2, ...], where x1, x2, etc are match data.
  2. Alternation is encoded using polymorphic conses. That is, each alternative is a new class.
  3. Optional values are encoded verbatim or with null if there is no match.
  4. Sub-matches are encoded directly.
  5. Forgetful groups are structurally erased and encoded as strings (though they have some GC overhead).

Each matched region contains information about its match region, accessible via the start() and end() methods. This is useful for mapping syntactic regions back into string positions.

caterwaul.module('regexp-grammar-compiler', ':all', function ($) {

  Encoding of variants.
  Regular expressions are made of constant and variant pieces. For example, /foob*ar/ consists of two constants, 'foo' and 'ar', and one variant, 'b*'. Within the variant, 'b' is a constant,
  but we don't optimize this case specially. We need to know how many times 'b' occurred to reconstruct the original. Because repetition is encoded as an array, the resulting class would look
  like this:

  | foobar_regexp(start_, end_) *= capture [start()    = this.start_,
                                            end()      = this.end_,
                                            toString() = +this -seq -re- it.join('')]

  Pieces are one of:

  | 1. Constant: contains just the start/end data; the text is encoded in the prototype. This is a metaclass; a single class is generated for each constant.
    2. Erased variant: contains the result of an erased match; e.g. /(?:foo|bar|bif)/ is stored as just a string snippet, not as a proper alternative.
    3. Sequence: contains start/end data along with numerically-indexed sub-pieces that are optionally aliased onto named methods. Length is per-instance to allow for seq[] copying.

  You can think of these classes as being variations of atoms and conses, where conses have arbitrarily high arity (but are not variadic). Mapping semantics follow this model.

  Notation.
  Most regular expression constructs follow normal notational conventions. There are three significant exceptions:

  | 1. Regexps are parsed in terms of words, not characters. This is a big deal and is too involved to explain fully here (see source docs in caterwaul-regexp.waul).
    2. You can refer to other parse stages using a cross-reference, which is written as 'reference@'.
    3. You can name a piece of a regexp using a nominal binding, which is written as 'name:thing'. The : binds everything to its right up until a | or group-closer.

  Nominal bindings turn into additional methods that refer to numerically-bound properties.

Implementation.
Classes are emitted as uncompiled syntax trees rather than closures. This allows you to emit the output from this function as a runnable Javascript program.

  $.regexp_grammar(rules) = rules %v*parser_entry_point -seq

  Metaclass instance generation.
  Metaclass instances are emitted as cross-referential functions that have two modes of operation:

  | 1. Direct invocation causes a parse to occur. Returns null if given a non-conforming string. An optional second argument specifies the current input position; the resulting input position
       can be read using the .end() method.
    2. Constructor invocation builds a syntax node and returns immediately. This is used internally, though it might also be useful externally.
    3. Nullary constructor invocation builds a syntax node that has no children. This is used by caterwaul's seq[] macro.

  Each metaclass contains a .map() method that recursively descends through the tree. It uses a standard protocol to indicate nondestructive node replacement, stop-traversal, and continuation.
  Unlike caterwaul 1.3's map() method, this one is optimized to rewrite only modified subtrees.

  -where [metaclass_constructor(name, args)  = template /~replace/ {_name: name, _formals: formals, _formal_assignments: formal_assignments}
                 -where [template            = qse[_name(_formals) = this.constructor === _name ? _formal_assignments -then- this : _name.parse(arguments[0], arguments[1] || 0),
                                                   _name.parse     = _@parser_implementation],

                         fold_into_comma(xs) = xs /[new $.syntax(',')][x0 /~push/ x] -seq -re- it.unflatten(),
                         formals             = args /!fold_into_comma,
                         formal_assignments  = args *[/^_\d+/.test(x) ? 'this[_i] = _x'.qs /~replace/ {_i: x.substr(1), _x: x}
                                                                      : 'this._x  = _x'.qs /~replace/ {                 _x: x}] /seq /!fold_into_comma],

          metaclass_instance(n, ctor, proto) = qse[_constructor, _prototype, _name.prototype.constructor = _name]
                                               /~replace/ {_constructor: ctor, _prototype: proto, _name: n},

  Invariant instances.
  These have predetermined content and length, so all that is necessary for each instance is the 'start' parameter. Serialization and mapping are both trivial. The end() method simply adds the
  starting position to the precomputed length of the constant. Here, 'k' is the invariant string.

          invariant_metaclass(name, k) = metaclass_instance(name, metaclass_constructor(name, 'start'.qw) /~replace/ {'_@parser_implementation': parser(name, k)},
                                                                  proto(k))

               -where [proto(k)        = qse[capture [map(f, r = f(this)) = r === true || !r ? this : r,
                                                      end()               = this.start_ + _l,
                                                      length              = 0,
                                                      toString()          = _s]] /~replace/ {_s: k /!$.syntax.from_string, _l: '#{k.length}'},

                       parser(name, k) = qse[new _name(i) -when [_s === s.substr(i, _l)] -given [s, i]]
                                                   /~replace/ {_name: name, _s: k /!$.syntax.from_string, _l: '#{k.length}'}],

  Erased-variant instances.
  These have variant content and length and therefore take two parameters. The metaclass evaluates the given parser and turns the result into a string before saving it.

          erased_variant_metaclass(name, sub) = metaclass_instance(name, metaclass_constructor(name, 1) /~replace/ {'_@parser_implementation': parser(name, p)},
                                                                         qse[capture [map(f, r = f(this)) = r === true || !r ? this : r
                                                                                      end()               = this.start_ + this.parsed_.length,
                                                                                      length              = 0,
                                                                                      toString()          = this.parsed_]])

                    -where [parser(name, sub) = qse[new _name(i, result.toString()) -when.result -where [result = _sub.parse(s, i)] -given [s, i]]
                                                /~replace/ {_name: name, _parse: parse}],

  Sequence instances.
  Sequences destructure regular expressions piece by piece. This isn't quite as simple as the above cases for a couple of reasons. First, regular expressions don't map one-to-one against
  metaclass instances. In cases like /foo|bar/, two subclasses will be created, one for each constant possibility. Second, pieces of the regular expression can have names aliased onto numeric
  members. For example, /foo (bar:bif) baz/ creates a prototype method called bar() that returns this[1].

  The alternative case is an interesting one. If the regular expression represents a disjunction, then we flatten it out and construct a virtual class. This class will never be instantiated,
  but it will have a .parse() static method as promised to whoever created it. That way sub-instantiation and cross-references will both work. Note that there is no prototype chaining; it
  would be unnecessary because alternatives don't necessarily have anything in common.

  The sequence_metaclass method returns a hash to accommodate sub-definitions.

          sequence_metaclass(name, tree) = 

                         formals_for(arity)  = 'start end'.qw + n[arity] *['_#{x}'] -seq,
