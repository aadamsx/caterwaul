Regular expression grammar compiler | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This module converts regular expression grammar maps to string-isomorphic AST nodes. Variants are specified using a group containing a declaration: /(cond: expression)/ defines a variant named
'cond' that uses the 'expression' rule. Rules are specified in a hash.

Certain regular expression operators are not supported:

| 1. Lookahead/negative lookahead.
  2. Greedy repetition.
  3. Most backslash-forms.
  4. Match groups in their normal context.
  5. Backreferences.
  6. Toplevel alternation, unless /i is used.

Anything not defined as a variant must be a constant. A variant must be explicitly created when you use ?, +, or *. For example:

| /(foo: bar*)/         <- foo() returns an array of bar
  /(foo: bar+)/         <- ditto
  /(foo: bar?)/         <- foo() returns a bar or null

caterwaul.module('regexp-grammar-compiler', ':all', function ($) {

Implementation details.
For the most part this compiler is really boring. It splits alternation into separate cons forms; e.g. 'x: /foo | bar/' results in two conses, 'x0' and 'x1', as well as the original 'x' used
only for parsing. The exact layout is this:

| x: {parse: ...},
  x0: {} prototype={toString: '"foo"'.qf}
  x1: {} prototype={toString: '"bar"'.qf}

Inlining is performed for rules marked with the 'i' modifier: statement: /if | for | while | ... | expression/i. This indicates that the rule is comprised of singly-variant alternatives with
no immediate constant terms. The grammar compiler will generate invalid code if you use anything else.

  $.regexp_grammar(rules) = rules /pairs *!visit -seq -re- classes
                    -where [parsed_rules                    = {},
                            classes                         = {},

                            visit(pair)                     = parsed_rules[pair[0]] -eq- pair[1] /-$.regexp/ {atom: 'word'} <then> classes[pair[0]] -eq- parser_for(parsed_rules[pair[0]]),

                            flatten(t, d)                   = t.data === d && t.length >= 2 ? [t[0]] /~concat/ flatten(t[1], d) : [t],

                            parser_for(r)                   = r.i() ? alternative_parser(r /-flatten/ '|') : sequential_parser(r /-flatten/ ','),
                            alternative_parser(rs)          = '_r, given.s'.qse /~replace/ {_r: rs /['false'.qs]['_x0 || _x(s)'.qs /~replace/ {_x0: x0, _x: x.data}] -seq},
                            sequential_parser(rs)           = 'function (s) {var cons = {}, _definitions; if (_last) {_last.cons = cons; return _last}}'.qs
                                                              /~replace/ {_definitions: rs *[matcher_for(x, xi)] /[new $.syntax(',')][x0 /~push/ x] -seq -re- it.unflatten(),
                                                                          _last:        's#{rs.length - 1}'},

                            matcher_for(t, i)               = matching_stage_for(t, i, 's#{i}', i ? 's#{i - 1}' : 's'),
                            matching_stage_for(t, i, s, sp) = '_s = _sp && _m'.qs /~replace/ {_sp: sp, _s: s, _m: matching_expression(t, i, sp)},
                            matching_expression(t, i, sp)   = t /!is_substep  -re [it ? 'cons._name = _step(_sp)'.qse /~replace/ {_name: it._name.data, _step: it._step.data, _sp: sp}
                                                            : t /!is_constant -re [it ? '_sp.s.substr(_sp.i, _l) === _s'.qse /~replace/
                                                                                        {_sp: sp, _l: '#{it.data.length}', _s: $.syntax.from_string(it.data)}
                                                            : 'error: no matching form for #{t}']],

                            substep_pattern                 = $.regexp(/(_name: _step)/, {atom: 'word'}),
                            is_substep(t)                   = substep_pattern /~match/ t,
                            is_constant(t)                  = t.is_atom() && t.data !== '.' && t || t.is_group() && t[0] /!is_constant]});
