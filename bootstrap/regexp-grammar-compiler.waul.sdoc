Regular expression grammar compiler | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
This module converts regular expression grammar maps to string-isomorphic AST nodes. Variants are specified using a group containing a declaration: /(cond: expression)/ defines a variant named
'cond' that uses the 'expression' rule. Rules are specified in a hash.

Certain regular expression operators are not supported:

| 1. Lookahead/negative lookahead.
  2. Greedy repetition.
  3. Most backslash-forms.
  4. Match groups in their normal context.
  5. Backreferences.
  6. Toplevel alternation, unless /i is used.

Anything not defined as a variant must be a constant. A variant must be explicitly created when you use ?, +, or *. For example:

| /(foo: bar*)/         <- foo() returns an array of bar
  /(foo: bar+)/         <- ditto
  /(foo: bar?)/         <- foo() returns a bar or null

caterwaul.module('regexp-grammar-compiler', ':all', function ($) {

Implementation details.
For the most part this compiler is really boring. It splits alternation into separate cons forms; e.g. 'x: /foo | bar/' results in two conses, 'x0' and 'x1', as well as the original 'x' used
only for parsing. The exact layout is this:

| x: {parse: ...},
  x0: {} prototype={toString: '"foo"'.qf}
  x1: {} prototype={toString: '"bar"'.qf}

Inlining is performed for rules marked with the 'i' modifier: statement: /if | for | while | ... | expression/i. This indicates that the rule is comprised of singly-variant alternatives with
no immediate constant terms. The grammar compiler will generate invalid code if you use anything else.

  $.regexp_grammar(rules) = rules /pairs *!visit -seq -re- classes
                    -where [parsed_rules              = {},
                            classes                   = {},

                            visit(pair)               = parsed_rules[pair[0]] -eq- pair[1] /-$.regexp/ {atom: 'word'} <then> classes[pair[0]] -eq- parser_for(parsed_rules[pair[0]]),

                            flatten(t, d)             = t.data === d && t.length >= 2 ? [t[0]] /~concat/ flatten(t[1], d) : [t],

                            parser_for(r)             = r.i() ? alternative_parser(r /-flatten/ '|') : sequential_parser(r),
                            alternative_parser(rs)    = '_r, given.s'.qse /~replace/ {_r: rs /['false'.qs]['_x0 || _x(s)'.qs /~replace/ {_x0: x0, _x: x.data}] -seq},
                            sequential_parser(r)      = 'function (s) {var cons = {}; _stages; if (s) {s.cons = cons; return s}}'.qs /~replace/ {_stages: matching_stage_for(r, 's')},

                            matching_stage_for(t, v)  = t /!is_substep  -re [it ? 'if (_v && (_v = _step(_v))) (cons._name || (cons._name = [])).push(_v.cons)'.qse
                                                                                  /~replace/ {_name: it._name.data, _step: it._step.data, _v: v}

                                                      : t /!is_constant -re [it ? 'if (_v && _v.s.substr(_v.i, _l) === _s) _v = {s: _v.s, i: _v.i + _l}; else _v = null'.qse
                                                                                  /~replace/ {_l: '#{it.data.length}', _s: $.syntax.from_string(it.data), _v: v}

                                                      : t.data === '*?'         ? 'var _last; while (_v) {_last = _v; _each}; _v = _last'.qs
                                                                                  /~replace/ {_last: $.gensym('last'), _v: v, _each: matching_stage_for(t[0], v)}

                                                      : t.data === '?'          ? 'var _temp = _v; _stage; if (_temp) _v = _temp'.qs
                                                                                  /~replace/ {_v: v, _temp: temp, _stage: matching_stage_for(t[0], v)}
                                                                                  -where [temp = $.gensym(v)]

                                                      : t.data === ','          ? '_x; _y'.qs /~replace/ {_x: matching_stage_for(t[0], v), _y: matching_stage_for(t[1], v)}
                                                      : t.data === '('          ? matching_stage_for(t[0], v)
                                                      : t.data === '|'          ? 'var _temp = _v; _stage1; if (_temp) _v = _temp; else _stage2'.qs
                                                                                  /~replace/ {_v: v, _temp: temp, _stage1: matching_stage_for(t[0], temp), _stage2: matching_stage_for(t[1], v)}
                                                                                  -where [temp = $.gensym(v)]

                                                      : t.is_character_class()  ? 'if (_v && _regexp.test(_v.s.charAt(_v.i))) _v = {s: _v.s, i: _v.i + 1}'.qs
                                                                                  /~replace/ {_v: v, _regexp: '/#{t}/'}

                                                                                : 'error: no matching form for #{t}']],

                            substep_pattern           = $.regexp(/(_name: _step)/, {atom: 'word'}),
                            is_substep(t)             = substep_pattern /~match/ t,
                            is_constant(t)            = t.is_atom() && t.data !== '.' && t]});
