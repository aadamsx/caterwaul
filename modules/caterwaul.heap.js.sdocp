sdocp('sdoc::js::modules/caterwaul.heap', 'Heap implementation | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis module provides a basic heap implementation on top of finite caterwaul sequences. The heap is parameterized by a function that orders elements, returning true if the element belongs more\ntowards the root and false otherwise. (So a minheap on numbers or strings would use the function fn[x, y][x < y].)\n\nUsage.\ncaterwaul.heap is a function that takes an order function and returns a constructor for heaps implementing that ordering. So, for example:\n\n| var minheap = caterwaul.heap(fn[x, y][x < y]);\n  var h = new minheap();\n  h.insert(10).insert(20).root()        // -> 10\n  h.rroot()                             // -> 10, removes the root\n\n  caterwaul.tconfiguration(\'std seq\', \'heap\', function () {\n    this.heap(less) = fc_[null] /se.c[c.prototype = new caterwaul.seq.finite() /se[_.constructor = c] /se[\n      _.insert(x) = this.push(x).heapify_up(this.size() - 1),\n      _.root()    = this[0],\n      _.rroot()   = this[0] /se[this.pop() /se[this[0] = _, this.heapify_down(0), when[this.size()]]],\n\nImplementation.\nThere\'s some less-than-obvious math going on here. Down-heapifying requires comparing an element to its two children and finding the top of the three. We then swap that element into the top\nposition and heapify the tree that we swapped.\n\nNormally in a heap the array indexes are one-based, but this is inconvenient considering that everything else in Javascript is zero-based. To remedy this, I\'m using some makeshift offsets. We\nbasically transform the index in one-based space, but then subtract one to get its zero-based offset. Normally the left and right offsets are 2i and 2i + 1, respectively; in this case, here\'s\nthe math:\n\n| right = 2(i + 1) + 1 - 1 = 2(i + 1)\n  left  = 2(i + 1) - 1     = right - 1\n\n      _.swap(i, j)      = this /se[_[j] = _[i], _[i] = temp, where[temp = _[j]]],\n      _.heapify_up(i)   = this /se[_.swap(i, p).heapify_up(p), when[less.call(_, _[i], _[p])], where[p = i >> 1]],\n      _.heapify_down(i) = this /se[_.swap(lr, i).heapify_down(lr), unless[lr === i],\n                                   where*[s = _.size(), r = i + 1 << 1, l = r - 1, ll = l < s && less.call(_, _[l], _[i]) ? l : i, lr = r < s && less.call(_, _[r], _[ll]) ? r : ll]]]]});');