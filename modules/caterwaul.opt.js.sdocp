sdocp('modules/caterwaul.opt.js.sdoc', 'Caterwaul optimization library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nJavaScript JIT technology has come a long way, but there are some optimizations that it still isn\'t very good at performing. One is loop unrolling, which can have a large impact on execution\nspeed. Another is function inlining, which may be coming soon but for now also makes a difference. This library provides macros to transform well-factored code into high-performance code.\n\nLoop unrolling.\nThis is probably the most straightforward family of optimizations in the library. If you\'re using the \'seq\' library for iteration, then you will already benefit from these macros; but you can\nalso use them directly, like this:\n\n| // Slow for loop:\n  for (var i = 0, total = 0; i < xs.length; ++i) {\n    console.log(xs[i]);\n    total += xs[i];\n  }\n\n| // Using the unroll[] macro (notice the superimposing of type information):\n  var total = 0;\n  var x;\n  opt.unroll[i, xs.length][\n    x = xs[i],\n    console.log(x),\n    total += x\n  ];\n\n| // Here\'s the generated code (reformatted for readability):\n  var total = 0;\n  var x;\n  (function (_gensym_iterations) {\n    var _gensym_rounds = _gensym_iterations >>> 3;\n    var _gensym_extra  = _gensym_iterations & 7;\n    for (var i = 0; i < _gensym_extra; ++i)\n      x = xs[i], console.log(x), total += x;\n    for (var _gensym_i = 0; _gensym_i < _gensym_rounds; ++_gensym_i) {\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n      i++; x = _gensym_xs[i], console.log(x), total += x;\n    }\n  }) (xs.length);\n\n  Caveats.\n  Caterwaul\'s optimizer is not smart about identifying loop invariants or non-side-effectful things about loops. In other words, it really exists only for the purpose of taking the work out of\n  unrolling things or doing similarly mechanical low-level optimization. It also does not optimize algorithms or any other high-level aspects of your code that generally have a more\n  significant performance impact than low-level stuff like loop unrolling.\n\n  caterwaul.tconfiguration(\'qs qg fn defmacro\', \'opt.unroll\', function () {this.rmacro(qs[opt.unroll[_, _][_]], fn[variable, iterations, body][\n    with_gensyms[l, rs, es, j][qg[function (l) {for (var rs = l >>> 3, es = l & 7, _i_ = 0; _i_ < es; ++_i_) _body_;\n                                                for (var j = 0; j < rs; ++j) {_i_++; _body_; _i_++; _body_; _i_++; _body_; _i_++; _body_;\n                                                                              _i_++; _body_; _i_++; _body_; _i_++; _body_; _i_++; _body_}}](_iterations_)].\n    s(\'_i_\', variable).s(\'_body_\', body).s(\'_iterations_\', iterations)])});\n');