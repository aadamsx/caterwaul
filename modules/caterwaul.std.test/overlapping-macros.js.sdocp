sdocp('modules/caterwaul.std.test/overlapping-macros.js.sdoc', 'Test for an uncommon but important macro case:\n\n| defmacro[_ + _][fn[x, y][..., when[x.data === 5]]];   // or some such\n  defmacro[_ + _][fn[x, y][..., when[y.data === 10]]];\n\nMacroexpansion works backwards, but the macroexpander should failover to the first defmacro if the second expander rejects the match.\n\ntest(function () {\n  var c = caterwaul.clone(\'std\');\n\n  c(function (eq) {\n    compile_eval[this.count1 = 0, this.count2 = 0];\n    defmacro[_ + _][fn[x, y][++this.count1, qs[_x < _y].replace({_x: x, _y: y}), when[x.is_number()]]];\n    defmacro[_ + _][fn[x, y][++this.count2, qs[_x * _y].replace({_x: x, _y: y}), when[y.is_number()]]];\n\n    defmacro[c._][fn[attribute][new this.ref(this[attribute.data])]];\n\n    eq(qs[3].is_number(), true);        // Make sure this works...\n    eq(qs[4].is_number(), true);\n\n    var x = 3;\n    var y = \'bar\';\n\n    // Case 1. Should increment count2.\n    eq(x * 4, 12);              // Just checking...\n    eq(x + 4, 12);\n    eq(c.count1, 0);\n    eq(c.count2, 1);\n\n    // Case 2. Should fall through and increment count 1.\n    eq(3 < y, false);           // Just checking...\n    eq(3 + y, false);\n    eq(c.count1, 1);\n    eq(c.count2, 1);\n  }) (eq);\n});\n');