// Test for an uncommon but important macro case:

// | defmacro[_ + _][fn[x, y][..., when[x.data === 5]]];   // or some such
//   defmacro[_ + _][fn[x, y][..., when[y.data === 10]]];

// Macroexpansion works backwards, but the macroexpander should failover to the first defmacro if the second expander rejects the match.

test('caterwaul.std.overlapping-macros', function () {
  var c = caterwaul.clone('std');

  c(function (eq) {
    compile_eval[this.count1 = 0, this.count2 = 0];
    defmacro[_ + _][fn[x, y][++this.count1, qs[_x < _y].replace({_x: x, _y: y}), when[x.is_number()]]];
    defmacro[_ + _][fn[x, y][++this.count2, qs[_x * _y].replace({_x: x, _y: y}), when[y.is_number()]]];

    defmacro[c._][fn[attribute][new this.ref(this[attribute.data])]];

    eq(qs[3].is_number(), true);        // Make sure this works...
    eq(qs[4].is_number(), true);

    var x = 3;
    var y = 'bar';

    // Case 1. Should increment count2.
    eq(x * 4, 12);              // Just checking...
    eq(x + 4, 12);
    eq(c.count1, 0);
    eq(c.count2, 1);

    // Case 2. Should fall through and increment count 1.
    eq(3 < y, false);           // Just checking...
    eq(3 + y, false);
    eq(c.count1, 1);
    eq(c.count2, 1);
  }) (eq);
});
// Generated by SDoc 
