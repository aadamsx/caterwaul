// Caterwaul parser module | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// The caterwaul parser uses a combinatory approach, much like Haskell's parser combinator library. The parser consumes elements from a finite input stream and emits the parse tree at each step.
// Because Javascript runtimes aren't required to optimize tail calls, it internally uses CPS and the tail-call mechanism provided by the continuation library.

// Note that parsers generated here are not at all insightful or necessarily performant. In particular, left-recursion isn't resolved, meaning that the parser will loop forever in this case. (And
// consume arbitrarily much memory without causing a stack overflow, too, since it's in CPS.)

//   Basis and acknowledgements.
//   This parser library is based heavily on Chris Double's JSParse (available at github.com/doublec/jsparse), which implements a memoized combinatory PEG parser. If you are looking for a simple
//   and well-designed parsing library, I highly recommend JSParse; it will be easier to use and more predictable than caterwaul.parser. Like JSParse, these parsers are memoized and use parsing
//   expression grammars. Unlike JSParse, this library uses CPS-conversion and macros to prevent stack overflows (which can be a drawback in the case of accidental infinite left-recursion) and to
//   maximize expressiveness, respectively.

// Notation.
// Parsers are written as collections of named nonterminals. Each nonterminal contains a mandatory expansion and an optional binding:

// | peg[start[c('a') % c('b')]]                           // A grammar that recognizes the character 'a' followed by the character 'b'
//   peg[start[c('a') % c('b')] >>= fn[ab][ab[0] + ab[1]]] // The same grammar, but the AST transformation step appends the two characters

// The >>= notation is borrowed from Haskell; the idea is that the optional binding is a monadic transform on the parse-state monad. (The only difference is that you don't have to re-wrap the
// result in a new parse state using 'return' as you would in Haskell -- the return here is implied.) The right-hand side of >>= can be any expression that returns a function. It will be
// evaluated directly within its lexical context, so the peg[] macro is scope-transparent modulo gensyms.

// Parsers are transparent over parentheses. Only the operators described below are converted specially.

//   Sequences.
//   Denoted using the '%' operator. The resulting AST is flattened into a finite caterwaul sequence. For example:

//   | peg[x[c('a') % c('b') % c('c')]]('abc')                     // -> ['a', 'b', 'c']
//     peg[x[c('a') % c('b')] >>= fn[xs][xs.join('/')]]('ab')      // -> 'a/b'

//   Alternatives.
//   Denoted using the '/' operator. Alternation is transparent; that is, the chosen entry is returned identically. Entries are tried from left to right without backtracking. For example:

//   | peg[x[c('a') / c('b')]]('a')                                // -> 'a'

//   Repetition.
//   Denoted using subscripted ranges, similar to the notation used in regular expressions. For example:

//   | peg[x[c('a')[0]]]                   // Zero or more 'a's
//     peg[x[c('b')[1,4]]                  // Between 1 and 4 'b's

//   Optional things.
//   Denoted using arrays. Returns a tree of undefined if the option fails to match. For example:

//   | peg[x[c('a') % [c('b')] % c('c')]]  // a followed by optional b followed by c

//   Negation.
//   Denoted using !:

//   | peg[x[!c('a')]]                     // Any character that isn't an a

//   Positive and negative matches.
//   Denoted using unary + and -, respectively. These consume no input but make assertions:

//   | peg[x[c('a') % +c('b')]]            // Matches an 'a' followed by a 'b', but consumes only the 'a'
//     peg[x[c('a') % -c('b')]]            // Matches an 'a' followed by anything except 'b', but consumes only the 'a'
// Generated by SDoc 
