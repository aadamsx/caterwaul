sdocp('sdoc::js::modules/caterwaul.std', 'Caterwaul standard library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\n  caterwaul.\n\nSyntax manipulation.\nThese configurations contain macros to grab references to syntax nodes or to bypass macroexpansion.\n\n  Qs library.\n  You really need to use this if you\'re going to write macros. It enables the qs[] construct in your code. This comes by default when you configure with \'std\'. A variant, qse[], macroexpands\n  the quoted code first and returns the macroexpansion. This improves performance while still enabling terse macro forms -- for example, if you write this:\n\n  | this.rmacro(qs[foo[_]], function (tree) {return qse[fn_[x + 1]].replace({x: tree})})\n\n  The fn_[] will be expanded exactly once when the qse[] is processed, rather than each time as part of the macroexpansion. I don\'t imagine it improves performance that noticeably, but it\'s\n  been bugging me for a while so I decided to add it.\n\n  Finally, there\'s also a literal[] macro to preserve code forms. Code inside literal[] will not be macroexpanded in any way.\n\n    configuration(\'std.qs\', function () {this.macro(this.parse(\'qs[_]\'),      function (tree) {return new this.ref(tree)}).\n                                              macro(this.parse(\'qse[_]\'),     function (tree) {return new this.ref(this.macroexpand(tree))}).\n                                              macro(this.parse(\'literal[_]\'), function (tree) {return tree})}).\n\n  Qg library.\n  The qg[] construct seems useless; all it does is parenthesize things. The reason it\'s there is to overcome constant-folding and rewriting Javascript runtimes such as SpiderMonkey. Firefox\n  failed the unit tests when ordinary parentheses were used because it requires disambiguation for expression-mode functions only at the statement level; thus syntax trees are not fully mobile\n  like they are ordinarily. Already-parenthesized expressions aren\'t wrapped.\n\n    tconfiguration(\'std.qs\', \'std.qg\', function () {this.rmacro(qs[qg[_]], function (expression) {return expression.as(\'(\')})}).\n\nCommon shorthands.\nThe rest of the macros in the standard library implement shorthands for commonly-used constructs.\n\n  Function abbreviations.\n  There are several shorthands that are useful for functions. fn[x, y, z][e] is the same as function (x, y, z) {return e}, fn_[e] constructs a nullary function returning e. fb[][] and fb_[]\n  are identical to fn[][] and fn_[], but they preserve \'this\' across the function call.\n\n  The fc[][] and fc_[] variants build constructor functions. These are just like regular functions, but they always return undefined.\n\n    tconfiguration(\'std.qs std.qg\', \'std.fn\', function () {\n      this.rmacro(qs[fn[_][_]], function (vars, expression) {return qse[qg[function (vars) {return expression}]].replace({vars: vars, expression: expression})}).\n           rmacro(qs[fn_[_]],   function       (expression) {return qse[qg[function     () {return expression}]].replace({expression: expression})})}).\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.fb\', function () {\n      this.rmacro(qs[fb[_][_]], function (vars, expression) {return qse[fn[_t][fn_[fn[vars][e].apply(_t, arguments)]](this)].replace({_t: this.gensym(), vars: vars, e: expression})}).\n           rmacro(qs[fb_[_]],   function       (expression) {return qse[fn[_t][fn_[fn_     [e].apply(_t, arguments)]](this)].replace({_t: this.gensym(),             e: expression})})}).\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.fc\', function () {\n      this.rmacro(qs[fc[_][_]], function       (vars, body) {return qse[qg[fn[vars][body, undefined]]].replace({vars: vars, body: body})}).\n           rmacro(qs[fc_[_]],   function             (body) {return qse[qg[fn[vars][body, undefined]]].replace({            body: body})})}).\n\n  Method binding library.\n  Another useful set of macros is the /mb/ and the /mb[] notation. These return methods bound to the object from which they were retrieved. This is useful when you don\'t want to explicitly\n  eta-expand when calling a method in point-free form:\n\n  | xs.map(object/mb/method);           // === xs.map(fn[x][object.method(x)])\n    xs.map(object/mb[method]);          // === xs.map(fn[x][object[method](x)])\n\n  Note that undefined methods are returned as such rather than having a fail-later proxy. (i.e. if foo.bar === undefined, then foo/mb/bar === undefined too) Neither the object nor the property\n  (for the indirected version) are evaluated more than once.\n\n  Side-effecting.\n  Also useful is side-effecting, which you can do this way:\n\n  | {} /se[_.foo = \'bar\']               // === l[_ = {}][_.foo = \'bar\', _]\n\n  Conveniently, side-effects can be chained since / is left-associative. An alternative form of side-effecting is the \'right-handed\' side-effect (which is still left-associative, despite the\n  name), written x /re[y]. This returns the result of evaluating y, where _ is bound to x. Variants of /se and /re allow you to specify a variable name:\n\n  | {} /se.o[o.foo = \'bar\']\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.mb\', function () {\n      this.rmacro(qs[_/mb/_],    fn[o, m][qse[qg[fn[_o]    [_o.m   && fn_[_o.m.apply  (_o, arguments)]]](o)]   .replace({_o: this.gensym(),                    o: o, m: m})]).\n           rmacro(qs[_/mb[_]],   fn[o, m][qse[qg[fn[_o, _m][_o[_m] && fn_[_o[_m].apply(_o, arguments)]]](o, m)].replace({_o: this.gensym(), _m: this.gensym(), o: o, m: m})])}).\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.se\', function () {\n      this.rmacro(qs[_/se._[_]], fn[v, n, b][qse[qg[fn[n][b, n]].call(this, v)].replace({b: b, n: n, v: v})]).rmacro(qs[_/se[_]], fn[v, b][qse[v /se._[b]].replace({b: b, v: v})]).\n           rmacro(qs[_/re._[_]], fn[v, n, b][qse[qg[fn[n]   [b]].call(this, v)].replace({b: b, n: n, v: v})]).rmacro(qs[_/re[_]], fn[v, b][qse[v /re._[b]].replace({b: b, v: v})])}).\n\n  Binding abbreviations.\n  Includes forms for defining local variables. One is \'l[bindings] in expression\', and the other is \'expression, where[bindings]\'. For the second, keep in mind that comma is left-associative.\n  This means that you\'ll get the whole comma-expression placed inside a function, rendering it useless for expressions inside procedure calls. (You\'ll need parens for that.) Each of these\n  expands into a function call; e.g.\n\n  | l[x = 6] in x + y         -> (function (x) {return x + y}).call(this, 6)\n\n  You also get l* and where*, which define their variables in the enclosed scope:\n\n  | l*[x = 6, y = x] in x + y\n    // compiles into:\n    (function () {\n      var x = 6, y = x;\n      return x + y;\n    }).call(this);\n\n  This form has a couple of advantages over the original. First, you can use the values of previous variables; and second, you can define recursive functions:\n\n  | l*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]] in f(5)\n\n  You can also use the less English-like but more expressive l[...][...] syntax:\n\n  | l[x = 5][x + 1]\n    l*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]][f(5)]\n\n  This has the advantage that you no longer need to parenthesize any short-circuit, decisional, or relational logic in the expression.\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.bind\', function () {\n      var l_star_expander = fb[vars, expression][qs[qg[function () {var vars; return expression}].call(this)].replace({vars: this.macroexpand(vars), expression: expression})],\n          l_expander      = fb[vars, expression][vars = this.macroexpand(vars).flatten(\',\'),\n                              qse[qg[fn[vars][e]].call(this, values)].replace({vars: vars.map(fn[n][n[0]]).unflatten(), e: expression, values: vars.map(fn[n][n[1]]).unflatten()})];\n\n      this.rmacro(qs[l [_] in _], qs[l [_][_]], l_expander).     rmacro(qs[_, where [_]], qs[_ /where [_]], fn[e, vs][l_expander(vs, e)]).\n           rmacro(qs[l*[_] in _], qs[l*[_][_]], l_star_expander).rmacro(qs[_, where*[_]], qs[_ /where*[_]], fn[e, vs][l_star_expander(vs, e)])}).\n\n  Assignment abbreviations.\n  Lets you create functions using syntax similar to the one supported in Haskell and OCaml -- for example, f(x) = x + 1. You can extend this too, though Javascript\'s grammar is not very easy\n  to work with on this point. (It\'s only due to an interesting IE feature (bug) that assigning to a function call is possible in the first place.)\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.lvalue\', function () {this.rmacro(qs[_(_) = _], fn[l, xs, v][qse[_l = qg[fn[_xs][_v]]].replace({_l: l, _xs: xs, _v: v})])}).\n\n  Conditional abbreviations.\n  Includes forms for making decisions in perhaps a more readable way than using short-circuit logic. In particular, it lets you do things postfix; i.e. \'do X if Y\' instead of \'if Y do X\'.\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.cond\', function () {this.rmacro(qs[_,   when[_]], qs[_   /when[_]], fn[expr, cond][qse[  qg[l] && qg[r]].replace({l: cond, r: expr})]).\n                                                                         rmacro(qs[_, unless[_]], qs[_ /unless[_]], fn[expr, cond][qse[! qg[l] && qg[r]].replace({l: cond, r: expr})])}).\n\n  Self-reference.\n  Sometimes you want to get a reference to \'this Caterwaul function\' at runtime. If you\'re using the anonymous invocation syntax (which I imagine is the most common one), this is actually not\n  possible without a macro. This macro provides a way to obtain the current Caterwaul function by writing \'caterwaul\'. The expression is replaced by a closure variable that will refer to\n  whichever Caterwaul function was used to transform the code.\n\n    tconfiguration(\'std.qs std.qg std.fn\', \'std.ref\', function () {this.macro(qs[caterwaul], fn_[new this.ref(this)])}).\n\n  String interpolation.\n  Rebase provides interpolation of #{} groups inside strings. Caterwaul can do the same using a similar rewrite technique that enables macroexpansion inside #{} groups. It generates a syntax\n  tree of the form (+ \'string\' (expression) \'string\' (expression) ... \'string\') -- that is, a flattened variadic +. Strings that do not contain #{} groups are returned as-is.\n\n  There is some weird stuff going on with splitting and bounds here. Most of it is IE6-related workarounds; IE6 has a buggy implementation of split() that fails to return elements inside match\n  groups. It also fails to return leading and trailing zero-length strings (so, for example, splitting \':foo:bar:bif:\' on /:/ would give [\'foo\', \'bar\', \'bif\'] in IE, vs. [\'\', \'foo\', \'bar\',\n  \'bif\', \'\'] in sensible browsers). So there is a certain amount of hackery that happens to make sure that where there are too few strings empty ones get inserted, etc.\n\n  Another thing that has to happen is that we need to take care of any backslash-quote sequences in the expanded source. The reason is that while generally it\'s safe to assume that the user\n  didn\'t put any in, Firefox rewrites strings to be double-quoted, escaping any double-quotes in the process. So in this case we need to find \\" and replace them with ".\n\n  In case the \'result.push\' at the end looks weird, it\'s OK because result is a syntax node and syntax nodes return themselves when you call push(). If \'result\' were an array the code would be\n  seriously borked.\n\n    tconfiguration(\'std.qs std.fn std.bind\', \'std.string\', function () {\n      this.rmacro(qs[_], fn[string]\n        [string.is_string() && /#\\{[^\\}]+\\}/.test(string.data) &&\n         l*[q = string.data.charAt(0), s = string.as_escaped_string(), eq = new RegExp(\'\\\\\\\\\' + q, \'g\'), strings = s.split(/#\\{[^\\}]+\\}/), xs = [], result = new this.syntax(\'+\')]\n           [s.replace(/#\\{([^\\}]+)\\}/g, fn[_, s][xs.push(s), \'\']),\n            this.util.map(fb[x, i][result.push(new this.syntax(q + (i < strings.length ? strings[i] : \'\') + q)).push(new this.syntax(\'(\', this.parse(xs[i].replace(eq, q))))], xs),\n            new this.syntax(\'(\', result.push(new this.syntax(q + (xs.length < strings.length ? strings[strings.length - 1] : \'\') + q)).unflatten())]])}).\n\nImports via \'using\'.\nNew in caterwaul 1.0 is the ability to, at compile time, import an object\'s keys into local scope. The semantics are similar to those of a with() statement, but importing is much faster\nbecause no dynamic scope resolution gets performed. It assumes that the object(s) that you\'re using are available both at compile-time and at runtime. So, for example:\n\n| var foo = {bar: {bif: {baz: \'bok\'}}};\n  caterwaul.clone(\'std\')(function () {\n    using[foo.bar.bif] in baz\n  });\n\nThe compiled result is:\n\n| var foo = {bar: {bif: {baz: \'bok\'}}};\n  (function () {\n    (function (gensym_1) {\n      return (function (baz) {\n        return baz\n      }).call(this, gensym_1.baz);\n    }).call(this, foo.bar.bif);\n  });\n\nIn general, each key/value pair is converted into another parameter of the anonymous scope. You can also specify multiple objects to use:\n\n| using[foo.bar, bif.baz] in ...\n\nNote that using[] uses compile-time evaluation! You can\'t use it to import the values of runtime objects. This also means that if you put a function expression into a using[] block (which is\ntotally allowed), the function call will happen at macroexpansion-time and again at runtime.\n\n  tconfiguration(\'std.qs\', \'std.using\', function () {this.rmacro(qs[using[_] in _], qs[using[_][_]], fn[os, body][\n    \n                  ])}).\n\n\nStandard configuration.\nThis loads all of the production-use extensions.\n\n  configuration(\'std\', function () {this.configure(\'std.qs std.qg std.bind std.lvalue std.cond std.fn std.mb std.se std.ref std.string std.using\')});');