sdocp('modules/caterwaul.std.js.sdoc', 'Caterwaul standard library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\n  caterwaul.\n\nQs library.\nYou really need to use this if you\'re going to write macros. It enables the qs[] construct in your code. This comes by default when you configure with \'std\'. A variant, qse[], macroexpands the\nquoted code first and returns the macroexpansion. This improves performance while still enabling terse macro forms -- for example, if you write this:\n\n| this.rmacro(qs[foo[_]], function (tree) {return qse[fn_[x + 1]].replace({x: tree})})\n\nThe fn_[] will be expanded exactly once when the qse[] is processed, rather than each time as part of the macroexpansion. I don\'t imagine it improves performance that noticeably, but it\'s\nbeen bugging me for a while so I decided to add it.\n\nFinally, there\'s also a literal[] macro to preserve code forms. Code inside literal[] will not be macroexpanded in any way.\n\n  configuration(\'std.qs\', function () {this.macro(this.parse(\'qs[_]\'),      function (tree) {return new this.ref(tree)}).\n                                            macro(this.parse(\'qse[_]\'),     function (tree) {return new this.ref(this.macroexpand(tree))}).\n                                            macro(this.parse(\'literal[_]\'), function (tree) {return tree})}).\n\nQg library.\nThe qg[] construct seems useless; all it does is parenthesize things. The reason it\'s there is to overcome constant-folding and rewriting Javascript runtimes such as SpiderMonkey. Firefox\nfailed the unit tests when ordinary parentheses were used because it requires disambiguation for expression-mode functions only at the statement level; thus syntax trees are not fully mobile\nlike they are ordinarily. Already-parenthesized expressions aren\'t wrapped.\n\n  tconfiguration(\'std.qs\', \'std.qg\', function () {this.rmacro(qs[qg[_]], function (expression) {return expression.as(\'(\')})}).\n\nFunction abbreviations (the \'fn\' library).\nThere are several shorthands that are useful for functions. fn[x, y, z][e] is the same as function (x, y, z) {return e}, fn_[e] constructs a nullary function returning e. fb[][] and fb_[]\nare identical to fn[][] and fn_[], but they preserve \'this\' across the function call.\n\nThe fc[][] and fc_[] variants build constructor functions. These are just like regular functions, but they always return undefined.\n\n  tconfiguration(\'std.qs std.qg\', \'std.fn\', function () {\n    this.configure(\'std.qg\').\n         rmacro(qs[fn[_][_]], function (vars, expression) {return qs[qg[function (vars) {return expression}]].replace({vars: vars, expression: expression})}).\n         rmacro(qs[fn_[_]],   function       (expression) {return qs[qg[function     () {return expression}]].replace({expression: expression})}).\n         rmacro(qs[fb[_][_]], function (vars, expression) {return qse[fn[_t][fn_[fn[vars][e].apply(_t, arguments)]](this)].replace({_t: this.gensym(), vars: vars, e: expression})}).\n         rmacro(qs[fb_[_]],   function       (expression) {return qse[fn[_t][fn_[fn_     [e].apply(_t, arguments)]](this)].replace({_t: this.gensym(),             e: expression})}).\n         rmacro(qs[fc[_][_]], function       (vars, body) {return qse[qg[fn[vars][body, undefined]]].replace({vars: vars, body: body})}).\n         rmacro(qs[fc_[_]],   function             (body) {return qse[qg[fn[vars][body, undefined]]].replace({            body: body})})}).\n\nObject abbreviations (the \'obj\' library).\nAnother useful set of macros is the /mb/ and the /mb[] notation. These return methods bound to the object from which they were retrieved. This is useful when you don\'t want to explicitly\neta-expand when calling a method in point-free form:\n\n| xs.map(object/mb/method);           // === xs.map(fn[x][object.method(x)])\n  xs.map(object/mb[method]);          // === xs.map(fn[x][object[method](x)])\n\nAlso useful is side-effecting, which you can do this way:\n\n| {} /se[_.foo = \'bar\']               // === let[_ = {}][_.foo = \'bar\', _]\n\nSide-effects can be chained since / is left-associative.\n\nAn alternative form of side-effecting is the \'right-handed\' side-effect, written x /re[y]. This returns the result of evaluating y, where _ is bound to x. Variants of /se and /re allow you to\nspecify a variable name:\n\n| {} /se.o[o.foo = \'bar\']\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.obj\', function () {\n    this.configure(\'std.qg std.fn\').rmacro(qs[_/mb/_],    fn   [object, method][qse[qg[fn[_o][fn_[_o.m.apply (_o, arguments)]]](o)].replace({_o: this.gensym(), o: object, m: method})]).\n                                    rmacro(qs[_/mb[_]],   fn   [object, method][qse[qg[fn[_o][fn_[_o[m].apply(_o, arguments)]]](o)].replace({_o: this.gensym(), o: object, m: method})]).\n                                    rmacro(qs[_/se[_]],   fn      [value, body][qse[qg[fn[_][body, _]].call(this, value)].replace({body: body, value: value})]).\n                                    rmacro(qs[_/re[_]],   fn      [value, body][qse[qg[fn[_]   [body]].call(this, value)].replace({body: body, value: value})]).\n                                    rmacro(qs[_/se._[_]], fn[value, name, body][qse[qg[fn[name][body, name]].call(this, value)].replace({body: body, name: name, value: value})]).\n                                    rmacro(qs[_/re._[_]], fn[value, name, body][qse[qg[fn[name]      [body]].call(this, value)].replace({body: body, name: name, value: value})])}).\n\nBinding abbreviations (the \'bind\' library).\nIncludes forms for defining local variables. One is \'let [bindings] in expression\', and the other is \'expression, where[bindings]\'. For the second, keep in mind that comma is left-associative.\nThis means that you\'ll get the whole comma-expression placed inside a function, rendering it useless for expressions inside procedure calls. (You\'ll need parens for that.) Each of these\nexpands into a function call; e.g.\n\n| let[x = 6] in x + y         -> (function (x) {return x + y}).call(this, 6)\n\nYou also get let* and where*, which define their variables in the enclosed scope:\n\n| let*[x = 6, y = x] in x + y\n  // compiles into:\n  (function () {\n    var x = 6, y = x;\n    return x + y;\n  }).call(this);\n\nThis form has a couple of advantages over the original. First, you can use the values of previous variables; and second, you can define recursive functions:\n\n| let*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]] in f(5)\n\nYou can also use the less English-like but more expressive let[...][...] syntax:\n\n| let[x = 5][x + 1]\n  let*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]][f(5)]\n\nThis has the advantage that you no longer need to parenthesize any short-circuit, decisional, or relational logic in the expression.\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.bind\', function () {\n    var let_star_expander = fb[vars, expression][qs[qg[function () {var vars; return expression}].call(this)].replace({vars: this.macroexpand(vars), expression: expression})],\n        let_expander      = fb[vars, expression][vars = this.macroexpand(vars).flatten(\',\'),\n                                                 qs[qg[function (vars) {return e}].call(this, values)].replace({vars: vars.map(fn[n][n[0]]), e: expression, values: vars.map(fn[n][n[1]])})];\n    this.configure(\'std.qg\').\n         rmacro(qs[let [_] in _], let_expander).     rmacro(qs[let [_][_]], let_expander).     rmacro(qs[_, where [_]], fn[expression, vars][let_expander(vars, expression)]).\n         rmacro(qs[let*[_] in _], let_star_expander).rmacro(qs[let*[_][_]], let_star_expander).rmacro(qs[_, where*[_]], fn[expression, vars][let_star_expander(vars, expression)])}).\n\nAssignment abbreviations (the \'lvalue\' library).\nLets you create functions using syntax similar to the one supported in Haskell and OCaml -- for example, f(x) = x + 1. You can extend this too, though Javascript\'s grammar is not very easy\nto work with on this point. (It\'s only due to an interesting IE feature (bug) that assigning to a function call is possible in the first place.)\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.lvalue\', function () {this.rmacro(qs[_(_) = _], fn[base, params, value][qs[base = qg[function (params) {return value}]].\n                                                                                                                        replace({base: base, params: params, value: value})])}).\n\nConditional abbreviations (the \'cond\' library).\nIncludes forms for making decisions in perhaps a more readable way than using short-circuit logic. In particular, it lets you do things postfix; i.e. \'do X if Y\' instead of \'if Y do X\'.\n\n  tconfiguration(\'std.qs std.fn\', \'std.cond\', function () {this.configure(\'std.qg\').rmacro(qs[_,   when[_]], fn[expression, cond][qs[  qg[l] && qg[r]].replace({l: cond, r: expression})]).\n                                                                                    rmacro(qs[_, unless[_]], fn[expression, cond][qs[! qg[l] && qg[r]].replace({l: cond, r: expression})])}).\n\nMacro authoring tools (the \'defmacro\' library).\nLisp provides some handy macros for macro authors, including things like (with-gensyms (...) ...) and even (defmacro ...). Writing defmacro is simple because \'this\' inside a macroexpander\nrefers to the caterwaul function that is running. It is trivial to expand into \'null\' and side-effectfully define a new macro on that caterwaul object.\n\nAnother handy macro is \'with_gensyms\', which lets you write hygienic macros. For example:\n\n| defmacro[forEach[_][_]][fn[xs, f][with_gensyms[i, l, xs][(function() {for (var i = 0, xs = _xs, l = xs.length, it; it = xs[i], it < l; ++it) {_body}})()].replace({_xs: xs, _body: f})]];\n\nThis will prevent \'xs\', \'l\', and \'i\' from being visible; here is a sample (truncated) macroexpansion:\n\n| forEach[[1, 2, 3]][console.log(it)]   ->  (function() {for (var _gensym_gesr8o7u_10fo11_ = 0, _gensym_gesr8o7u_10fo12_ = [1, 2, 3],\n                                                                  _gensym_gesr8o7u_10fo13_ = _gensym_gesr8o7u_10fo12_.length, it;\n                                                              it = _gensym_gesr8o7u_10fo12_[_gensym_...], _gensym_... < ...; ...) {console.log(it)}})()\n\nSince nobody in their right mind would name a variable _gensym_gesr8o7u_10fo11_, it is effectively collision-proof. (Also, even if you load Caterwaul twice you aren\'t likely to have gensym\ncollisions. The probability of it is one-in-several-billion at least.)\n\nNote that macros defined with \'defmacro\' are persistent; they outlast the function they were defined in. Presently there is no way to define scoped macros. Related to \'defmacro\' is \'defsubst\',\nwhich lets you express simple syntactic rewrites more conveniently. Here\'s an example of a defmacro and an equivalent defsubst:\n\n| defmacro[_ <equals> _][fn[left, right][qs[left === right].replace({left: left, right: right})]];\n  defsubst[_left <equals> _right][_left === _right];\n\nSyntax variables are prefixed with underscores; other identifiers are literals.\n\n  tconfiguration(\'std.qs std.fn std.bind std.lvalue\', \'std.defmacro\', function () {\n    let[wildcard(n) = n.data.constructor === String && n.data.charAt(0) === \'_\' && \'_\'] in\n    this.macro(qs[defmacro[_][_]], fn[pattern, expansion][this.rmacro(pattern, this.compile(this.macroexpand(expansion))), qs[null]]).\n         macro(qs[defsubst[_][_]], fn[pattern, expansion][this.rmacro(pattern.rmap(wildcard), let[wildcards = pattern.collect(wildcard)] in fn_[let[hash = {}, as = arguments]\n                                                            [this.util.map(fn[v, i][hash[v.data] = as[i]], wildcards), expansion.replace(hash)]]), qs[null]])}).\n\n  tconfiguration(\'std.qs std.fn std.bind\', \'std.with_gensyms\', function () {\n    this.rmacro(qs[with_gensyms[_][_]], fn[vars, expansion][let[bindings = {}][vars.flatten(\',\').each(fb[v][bindings[v.data] = this.gensym()]),\n                                                                               qs[qs[_]].replace({_: expansion.replace(bindings)})]])}).\n\nCompile-time eval (the \'compile_eval\' library).\nThis is one way to get values into your code (though you don\'t have closure if you do it this way). Compile-time evals will be bound to the current caterwaul function and the resulting\nexpression will be inserted into the code as a reference. The evaluation is done at macro-expansion time, and any macros defined when the expression is evaluated are used.\n\n  tconfiguration(\'std.qs std.fn\', \'std.compile_eval\', function () {\n    this.macro(qs[compile_eval[_]], fn[e][new this.ref(this.compile(this.macroexpand(qs[fn_[_]].replace({_: e}))).call(this))])}).\n\nSelf-reference (the \'ref\' library).\nSometimes you want to get a reference to \'this Caterwaul function\' at runtime. If you\'re using the anonymous invocation syntax (which I imagine is the most common one), this is actually not\npossible without a macro. This macro provides a way to obtain the current Caterwaul function by writing \'caterwaul\'. The expression is replaced by a closure variable that will refer to\nwhichever Caterwaul function was used to transform the code.\n\n  tconfiguration(\'std.qs std.fn\', \'std.ref\', function () {this.macro(qs[caterwaul], fn_[new this.ref(this)])}).\n\nLocal macroexpansion (the \'locally\' library).\nSometimes you want to write a configuration that isn\'t applied globally, but rather just to a delimited section of code. This macro does just that: You can specify one or more configurations\nand a block of code, and the block of code will be transformed under a Caterwaul clone with those configurations and returned. So, for example:\n\n| caterwaul.clone(\'std.locally\')(function () {\n    return locally[\'std\'][fn[x][x + 1]];        // General case (especially if you want multiple configurations separated by spaces)\n    return locally[std][fn[x][x + 1]];          // Same thing\n    return locally.std[fn[x][x + 1]];           // Also the same thing\n  });\n\nNote that the implementation of this isn\'t terribly efficient. It creates a custom Caterwaul clone for the block in question and then throws that clone away. This probably pales in comparison\nto the macroexpansion process in general, but if your Caterwaul has a ton of configurations applied it could be a performance bottleneck during macroexpansion.\n\n  tconfiguration(\'std.qs std.bind std.lvalue\', \'std.locally\', function () {\n    let*[t = this, handler(c, e) = t.clone(c.is_string() ? c.as_escaped_string() : c.data).macroexpand(e)] in this.macro(qs[locally[_][_]], handler).macro(qs[locally._[_]], handler)}).\n\nString interpolation.\nRebase provides interpolation of #{} groups inside strings. Caterwaul can do the same using a similar rewrite technique that enables macroexpansion inside #{} groups. It generates a syntax\ntree of the form (+ \'string\' (expression) \'string\' (expression) ... \'string\') -- that is, a flattened variadic +. Strings that do not contain #{} groups are returned as-is.\n\nThere is some weird stuff going on with splitting and bounds here. Most of it is IE6-related workarounds; IE6 has a buggy implementation of split() that fails to return elements inside match\ngroups. It also fails to return leading and trailing zero-length strings (so, for example, splitting \':foo:bar:bif:\' on /:/ would give [\'foo\', \'bar\', \'bif\'] in IE, vs. [\'\', \'foo\', \'bar\',\n\'bif\', \'\'] in sensible browsers). So there is a certain amount of hackery that happens to make sure that where there are too few strings empty ones get inserted, etc.\n\nAnother thing that has to happen is that we need to take care of any backslash-quote sequences in the expanded source. The reason is that while generally it\'s safe to assume that the user\ndidn\'t put any in, Firefox rewrites strings to be double-quoted, escaping any double-quotes in the process. So in this case we need to find \\" and replace them with ".\n\nIn case the \'result.push\' at the end looks weird, it\'s OK because result is a syntax node and syntax nodes return themselves when you call push(). If \'result\' were an array the code would be\nseriously borked.\n\n  tconfiguration(\'std.qs std.fn std.bind\', \'std.string\', function () {\n    this.rmacro(qs[_], fn[string]\n      [string.is_string() && /#\\{[^\\}]+\\}/.test(string.data) &&\n       let*[q = string.data.charAt(0), s = string.as_escaped_string(), eq = new RegExp(\'\\\\\\\\\' + q, \'g\'), strings = s.split(/#\\{[^\\}]+\\}/), xs = [], result = new this.syntax(\'+\')]\n           [s.replace(/#\\{([^\\}]+)\\}/g, fn[_, s][xs.push(s), \'\']),\n            this.util.map(fb[x, i][result.push(new this.syntax(q + (i < strings.length ? strings[i] : \'\') + q)).push(new this.syntax(\'(\', this.parse(xs[i].replace(eq, q))))], xs),\n            new this.syntax(\'(\', result.push(new this.syntax(q + (xs.length < strings.length ? strings[strings.length - 1] : \'\') + q)))]])}).\n\nStandard configuration.\nThis loads all of the production-use extensions.\n\n  configuration(\'std\', function () {this.configure(\'std.qs std.qg std.bind std.lvalue std.cond std.fn std.obj std.defmacro std.with_gensyms std.ref std.locally std.compile_eval std.string\')});\n');