sdocp('sdoc::js::modules/caterwaul.std', 'Caterwaul standard library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\n  caterwaul.\n\nQs library.\nYou really need to use this if you\'re going to write macros. It enables the qs[] construct in your code. This comes by default when you configure with \'std\'. A variant, qse[], macroexpands the\nquoted code first and returns the macroexpansion. This improves performance while still enabling terse macro forms -- for example, if you write this:\n\n| this.rmacro(qs[foo[_]], function (tree) {return qse[fn_[x + 1]].replace({x: tree})})\n\nThe fn_[] will be expanded exactly once when the qse[] is processed, rather than each time as part of the macroexpansion. I don\'t imagine it improves performance that noticeably, but it\'s\nbeen bugging me for a while so I decided to add it.\n\nFinally, there\'s also a literal[] macro to preserve code forms. Code inside literal[] will not be macroexpanded in any way.\n\n  configuration(\'std.qs\', (function (qs_template, qse_template, literal_template) {return function () {\n                            this.macro(qs_template,      function (tree) {return new this.ref(tree)}).\n                                 macro(qse_template,     function (tree) {return new this.ref(this.macroexpand(tree))}).\n                                 macro(literal_template, function (tree) {return tree})}}) (caterwaul.parse(\'qs[_]\'), caterwaul.parse(\'qse[_]\'), caterwaul.parse(\'literal[_]\'))).\n\nQg library.\nThe qg[] construct seems useless; all it does is parenthesize things. The reason it\'s there is to overcome constant-folding and rewriting Javascript runtimes such as SpiderMonkey. Firefox\nfailed the unit tests when ordinary parentheses were used because it requires disambiguation for expression-mode functions only at the statement level; thus syntax trees are not fully mobile\nlike they are ordinarily. Already-parenthesized expressions aren\'t wrapped.\n\n  tconfiguration(\'std.qs\', \'std.qg\', function () {this.rmacro(qs[qg[_]], function (expression) {return expression.as(\'(\')})}).\n\nFunction abbreviations (the \'fn\' library).\nThere are several shorthands that are useful for functions. fn[x, y, z][e] is the same as function (x, y, z) {return e}, fn_[e] constructs a nullary function returning e. fb[][] and fb_[]\nare identical to fn[][] and fn_[], but they preserve \'this\' across the function call.\n\nThe fc[][] and fc_[] variants build constructor functions. These are just like regular functions, but they always return undefined.\n\n  tconfiguration(\'std.qs std.qg\', \'std.fn\', function () {\n    this.configure(\'std.qg\').\n         rmacro(qs[fn[_][_]], function (vars, expression) {return qs[qg[function (vars) {return expression}]].replace({vars: vars, expression: expression})}).\n         rmacro(qs[fn_[_]],   function       (expression) {return qs[qg[function     () {return expression}]].replace({expression: expression})}).\n         rmacro(qs[fb[_][_]], function (vars, expression) {return qse[fn[_t][fn_[fn[vars][e].apply(_t, arguments)]](this)].replace({_t: this.gensym(), vars: vars, e: expression})}).\n         rmacro(qs[fb_[_]],   function       (expression) {return qse[fn[_t][fn_[fn_     [e].apply(_t, arguments)]](this)].replace({_t: this.gensym(),             e: expression})}).\n         rmacro(qs[fc[_][_]], function       (vars, body) {return qse[qg[fn[vars][body, undefined]]].replace({vars: vars, body: body})}).\n         rmacro(qs[fc_[_]],   function             (body) {return qse[qg[fn[vars][body, undefined]]].replace({            body: body})})}).\n\nObject abbreviations (the \'obj\' library).\nAnother useful set of macros is the /mb/ and the /mb[] notation. These return methods bound to the object from which they were retrieved. This is useful when you don\'t want to explicitly\neta-expand when calling a method in point-free form:\n\n| xs.map(object/mb/method);           // === xs.map(fn[x][object.method(x)])\n  xs.map(object/mb[method]);          // === xs.map(fn[x][object[method](x)])\n\nNote that undefined methods are returned as such rather than having a fail-later proxy. (i.e. if foo.bar === undefined, then foo/mb/bar === undefined too) Neither the object nor the property\n(for the indirected version) are evaluated more than once.\n\nAlso useful is side-effecting, which you can do this way:\n\n| {} /se[_.foo = \'bar\']               // === l[_ = {}][_.foo = \'bar\', _]\n\nConveniently, side-effects can be chained since / is left-associative. An alternative form of side-effecting is the \'right-handed\' side-effect (which is still left-associative, despite the\nname), written x /re[y]. This returns the result of evaluating y, where _ is bound to x. Variants of /se and /re allow you to specify a variable name:\n\n| {} /se.o[o.foo = \'bar\']\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.obj\', function () {\n    this.configure(\'std.qg std.fn\').\n      rmacro(qs[_/mb/_],    fn[object, method][qse[qg[fn[_o]    [_o.m   && fn_[_o.m.apply  (_o, arguments)]]](o)]   .replace({_o: this.gensym(),                    o: object, m: method})]).\n      rmacro(qs[_/mb[_]],   fn[object, method][qse[qg[fn[_o, _m][_o[_m] && fn_[_o[_m].apply(_o, arguments)]]](o, m)].replace({_o: this.gensym(), _m: this.gensym(), o: object, m: method})]).\n      rmacro(qs[_/se._[_]], fn[v, n, b][qse[qg[fn[n][b, n]].call(this, v)].replace({b: b, n: n, v: v})]).rmacro(qs[_/se[_]], fn[v, b][qse[v /se._[b]].replace({b: b, v: v})]).\n      rmacro(qs[_/re._[_]], fn[v, n, b][qse[qg[fn[n]   [b]].call(this, v)].replace({b: b, n: n, v: v})]).rmacro(qs[_/re[_]], fn[v, b][qse[v /re._[b]].replace({b: b, v: v})])}).\n\nBinding abbreviations (the \'bind\' library).\nIncludes forms for defining local variables. One is \'l[bindings] in expression\', and the other is \'expression, where[bindings]\'. For the second, keep in mind that comma is left-associative.\nThis means that you\'ll get the whole comma-expression placed inside a function, rendering it useless for expressions inside procedure calls. (You\'ll need parens for that.) Each of these\nexpands into a function call; e.g.\n\n| l[x = 6] in x + y         -> (function (x) {return x + y}).call(this, 6)\n\nYou also get l* and where*, which define their variables in the enclosed scope:\n\n| l*[x = 6, y = x] in x + y\n  // compiles into:\n  (function () {\n    var x = 6, y = x;\n    return x + y;\n  }).call(this);\n\nThis form has a couple of advantages over the original. First, you can use the values of previous variables; and second, you can define recursive functions:\n\n| l*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]] in f(5)\n\nYou can also use the less English-like but more expressive l[...][...] syntax:\n\n| l[x = 5][x + 1]\n  l*[f = fn[x][x > 0 ? f(x - 1) + 1 : x]][f(5)]\n\nThis has the advantage that you no longer need to parenthesize any short-circuit, decisional, or relational logic in the expression.\n\nThe legacy let and let* forms are also supported, but they will cause syntax errors in some Javascript interpreters (hence the change).\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.bind\', function () {this.configure(\'std.qg\');\n    var lf = fb[form][this.rmacro(form, l_expander)], lsf = fb[form][this.rmacro(form, l_star_expander)],\n        l_star_expander = fb[vars, expression][qs[qg[function () {var vars; return expression}].call(this)].replace({vars: this.macroexpand(vars), expression: expression})],\n        l_expander      = fb[vars, expression][vars = this.macroexpand(vars).flatten(\',\'),\n                            qs[qg[function (vars) {return e}].call(this, values)].replace({vars: vars.map(fn[n][n[0]]).unflatten(), e: expression, values: vars.map(fn[n][n[1]]).unflatten()})];\n\n    lf (qs[l [_] in _]), lf (qs[l [_][_]]), lf (let_in),  lf (let_brackets). rmacro(qs[_, where [_]], fn[expression, vars][l_expander(vars, expression)]);\n    lsf(qs[l*[_] in _]), lsf(qs[l*[_][_]]), lsf(lets_in), lsf(lets_brackets).rmacro(qs[_, where*[_]], fn[expression, vars][l_star_expander(vars, expression)])},\n\n    {let_in: caterwaul.parse(\'let [_] in _\'), let_brackets: caterwaul.parse(\'let [_][_]\'), lets_in: caterwaul.parse(\'let*[_] in _\'), lets_brackets: caterwaul.parse(\'let*[_][_]\')}).\n\nAssignment abbreviations (the \'lvalue\' library).\nLets you create functions using syntax similar to the one supported in Haskell and OCaml -- for example, f(x) = x + 1. You can extend this too, though Javascript\'s grammar is not very easy\nto work with on this point. (It\'s only due to an interesting IE feature (bug) that assigning to a function call is possible in the first place.)\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.lvalue\', function () {this.rmacro(qs[_(_) = _], fn[base, params, value][qs[base = qg[function (params) {return value}]].\n                                                                                                                        replace({base: base, params: params, value: value})])}).\n\nConditional abbreviations (the \'cond\' library).\nIncludes forms for making decisions in perhaps a more readable way than using short-circuit logic. In particular, it lets you do things postfix; i.e. \'do X if Y\' instead of \'if Y do X\'.\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.cond\', function () {this.configure(\'std.qg\').rmacro(qs[_,   when[_]], fn[expr, cond][qs[  qg[l] && qg[r]].replace({l: cond, r: expr})]).\n                                                                                           rmacro(qs[_, unless[_]], fn[expr, cond][qs[! qg[l] && qg[r]].replace({l: cond, r: expr})])}).\n\nSelf-reference (the \'ref\' library).\nSometimes you want to get a reference to \'this Caterwaul function\' at runtime. If you\'re using the anonymous invocation syntax (which I imagine is the most common one), this is actually not\npossible without a macro. This macro provides a way to obtain the current Caterwaul function by writing \'caterwaul\'. The expression is replaced by a closure variable that will refer to\nwhichever Caterwaul function was used to transform the code.\n\n  tconfiguration(\'std.qs std.qg std.fn\', \'std.ref\', function () {this.macro(qs[caterwaul], fn_[new this.ref(this)])}).\n\nString interpolation.\nRebase provides interpolation of #{} groups inside strings. Caterwaul can do the same using a similar rewrite technique that enables macroexpansion inside #{} groups. It generates a syntax\ntree of the form (+ \'string\' (expression) \'string\' (expression) ... \'string\') -- that is, a flattened variadic +. Strings that do not contain #{} groups are returned as-is.\n\nThere is some weird stuff going on with splitting and bounds here. Most of it is IE6-related workarounds; IE6 has a buggy implementation of split() that fails to return elements inside match\ngroups. It also fails to return leading and trailing zero-length strings (so, for example, splitting \':foo:bar:bif:\' on /:/ would give [\'foo\', \'bar\', \'bif\'] in IE, vs. [\'\', \'foo\', \'bar\',\n\'bif\', \'\'] in sensible browsers). So there is a certain amount of hackery that happens to make sure that where there are too few strings empty ones get inserted, etc.\n\nAnother thing that has to happen is that we need to take care of any backslash-quote sequences in the expanded source. The reason is that while generally it\'s safe to assume that the user\ndidn\'t put any in, Firefox rewrites strings to be double-quoted, escaping any double-quotes in the process. So in this case we need to find \\" and replace them with ".\n\nIn case the \'result.push\' at the end looks weird, it\'s OK because result is a syntax node and syntax nodes return themselves when you call push(). If \'result\' were an array the code would be\nseriously borked.\n\n  tconfiguration(\'std.qs std.fn std.bind\', \'std.string\', function () {\n    this.rmacro(qs[_], fn[string]\n      [string.is_string() && /#\\{[^\\}]+\\}/.test(string.data) &&\n       l*[q = string.data.charAt(0), s = string.as_escaped_string(), eq = new RegExp(\'\\\\\\\\\' + q, \'g\'), strings = s.split(/#\\{[^\\}]+\\}/), xs = [], result = new this.syntax(\'+\')]\n         [s.replace(/#\\{([^\\}]+)\\}/g, fn[_, s][xs.push(s), \'\']),\n          this.util.map(fb[x, i][result.push(new this.syntax(q + (i < strings.length ? strings[i] : \'\') + q)).push(new this.syntax(\'(\', this.parse(xs[i].replace(eq, q))))], xs),\n          new this.syntax(\'(\', result.push(new this.syntax(q + (xs.length < strings.length ? strings[strings.length - 1] : \'\') + q)).unflatten())]])}).\n\nStandard configuration.\nThis loads all of the production-use extensions.\n\n  configuration(\'std\', function () {this.configure(\'std.qs std.qg std.bind std.lvalue std.cond std.fn std.obj std.ref std.string\')});');