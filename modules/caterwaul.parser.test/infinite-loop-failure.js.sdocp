sdocp('sdoc::js::modules/caterwaul.parser.test/infinite-loop-failure', 'An observed failure involving infinite looping.\nThe original case is in the Figment parser:\n\n| l*[literate     = peg[c(/[A-Z\\|](?:[^\\n]+\\n?)*/, 1) >> fn_[\'\']],\n     paragraph    = peg[c(/([^\\n]+\\n?)*/, 1) >> fn[xs][xs[0]]],\n     paragraphs   = peg[([c(/\\n\\n+/, 2)] % (literate / paragraph) >> fn[xs][xs.join(\'\')])[0] >> fn[xs][xs.join(\'\')]],\n     line_comment = peg[c(/[-\\/]\\s*/, 1) % c(/[A-Z][^\\n]*/, 1) % c(\'\\n\') >> fn_[\'\']],\n     code         = peg[(line_comment / c([\'-\', \'/\']) / c(/[^-\\/]+/, 1))[1] >> fn[xs][xs.join(\'\')]]] in\n  fn[s][code(paragraphs(s))]\n\nUpdate: Another failure is related to newlines. The Figment parser hangs indefinitely when presented with the input "this.hello_world = \'hello world!\'\\n".\n\ntest(\'caterwaul.parser.infinite-loop-failure\', function () {\n  var c = caterwaul.clone(\'std parser\');\n  c(function (eq) {\n    l*[literate     = peg[c(/[A-Z\\|](?:[^\\n]+\\n?)+/, 2) >> fn_[\'\']],\n       paragraph    = peg[c(/(?:[^\\n]+\\n?)+/, 1) >> fn[xs][xs[0]]],\n       paragraphs   = peg[(literate / paragraph % ([c(/\\n\\n+/, 2)] >> fn_[\'\']) >> fn[xs][xs.join(\'\')])[1] >> fn[xs][xs.join(\'\')]],\n       line_comment = peg[c(/[-\\/]\\s*/, 1) % c(/[A-Z][^\\n]*/, 1) % c(\'\\n\') >> fn_[\'\']],\n       code         = peg[(line_comment / c([\'-\', \'/\']) / c(/[^-\\/]+/, 1))[1] >> fn[xs][xs.join(\'\')]]] in\n\n    eq /se[_(code(paragraphs(\'foo\')), \'foo\'),\n           _(code(paragraphs(\'foo\\n\')), \'foo\\n\'),\n           _(code(paragraphs(\'foo = "bar"\\n\')), \'foo = "bar"\\n\'),\n           _(code(paragraphs(\'foo = "bar"\\n\\n\')), \'foo = "bar"\\n\')];\n\n    // The failure case is triggered by this (the "one or more" combinator failed to recognize end of input):\n    eq(peg[c(/.*/, 1)[1]](\'abcdef\').join(\'\'), \'abcdef\');\n    eq(peg[c(/.*/, 1)[1]](\'abc\').join(\'\'), \'abc\');\n    eq(peg[c(/.*/, 1)[1]](\'a\').join(\'\'), \'a\');\n\n    // Second failure: a boundary case:\n    eq(peg[[c(/\\s+/, 1)]](\'\\n\'), \'\\n\');\n    eq(peg[c(/\\s+/, 1)[1]](\'\\n\').join(\'\'), \'\\n\');\n    eq(peg[c(/\\w+/, 1) % c(/\\s+/, 1)[1]](\'foo\\n\').join(\'\'), \'foo\\n\');\n  })(eq);\n});');