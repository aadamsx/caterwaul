sdocp('sdoc::js::modules/caterwaul.parser', 'Caterwaul parser module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThe caterwaul parser uses a combinatory approach, much like Haskell\'s parser combinator library. The parser consumes elements from a finite input stream and emits the parse tree at each step.\nNote that parsers generated here are not at all insightful or necessarily performant. In particular, left-recursion isn\'t resolved, meaning that the parser will loop forever in this case.\n\n  Basis and acknowledgements.\n  This parser library is based heavily on Chris Double\'s JSParse (available at github.com/doublec/jsparse), which implements a memoized combinatory PEG parser. If you are looking for a simple\n  and well-designed parsing library, I highly recommend JSParse; it will be easier to use and more predictable than caterwaul.parser. Like JSParse, these parsers are memoized and use parsing\n  expression grammars. However, this parser is probably quite a lot slower.\n\nInternals.\nMemoization is restricted to a session rather than being global. This prevents the space leak that would otherwise occur if the parser outlived the result. Behind the scenes the parser\npromotes the input into a parse-state (very much like the ps() function in JSParse). Like other caterwaul libraries, this one uses non-macro constructs behind the scenes. You can easily get at\nthis by accessing stuff inside the caterwaul.parser namespace.\n\n  caterwaul.tconfiguration(\'std seq continuation memoize\', \'parser.core\', function () {\n    this.namespace(\'parser\') /se[_.parse_state(input, i, result, memo) = undefined /se[this.input = input, this.i = i, this.result = result, this.memo = memo],\n                                 _.parse_state /se.s[s.from_input(input) = new _.parse_state(input, 0, null, {}),\n                                                     s.prototype /se[_.accept(n, r) = new this.constructor(this.input, n, r, this.memo),\n                                                                     _.toString()   = \'ps[#{this.input.substr(this.i)}, #{this.r}]\']],\n\n                                 _.memoize               = caterwaul.memoize.from(fn[c, as, f][k in m ? m[k] : (m[k] = f.apply(c, as)),\n                                                                                               where[k = \'#{f.original.memo_id}|#{as[0].i}\', m = as[0].memo || (as[0].memo = {})]]),\n                                 _.promote_non_states(f) = fn[state][f.call(this, state.constructor === _.parse_state ? state : _.parse_state.from_input(state))],\n                                 _.identify(f)           = f /se[_.memo_id = caterwaul.gensym()],\n                                 _.parser(f)             = _.promote_non_states(_.memoize(_.identify(f))),\n                                 _.defparser(name, f)    = _.parsers[name]() = _.parser(f.apply(this, arguments)),\n                                 _.parsers               = {}]}).\n\nNotation.\nParsers are written as collections of named nonterminals. Each nonterminal contains a mandatory expansion and an optional binding:\n\n| peg[c(\'a\') % c(\'b\')]                                  // A grammar that recognizes the character \'a\' followed by the character \'b\'\n  peg[c(\'a\') % c(\'b\') >>= fn[ab][ab[0] + ab[1]]]        // The same grammar, but the AST transformation step appends the two characters\n\nThe >>= notation is borrowed from Haskell; the idea is that the optional binding is a monadic transform on the parse-state monad. (The only difference is that you don\'t have to re-wrap the\nresult in a new parse state using \'return\' as you would in Haskell -- the return here is implied.) The right-hand side of >>= can be any expression that returns a function. It will be\nevaluated directly within its lexical context, so the peg[] macro is scope-transparent modulo gensyms.\n\nParsers are transparent over parentheses. Only the operators described below are converted specially.\n\n  Strings.\n  Strings are parsable by using the c(x) function, which is named this because it matches a constant.\n\n  | peg[c(\'x\')]         // Parses the string \'x\'\n    peg[c(\'foo bar\')]   // Parses the string \'foo bar\'\n\n    tconfiguration(\'std seq continuation\', \'parser.c\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'c\', fn[x][fn[state][state.accept(state.i + x.length, x), when[x === state.input.substr(state.i, x.length)]]])}).\n\n  Sequences.\n  Denoted using the \'%\' operator. The resulting AST is flattened into a finite caterwaul sequence. For example:\n\n  | peg[c(\'a\') % c(\'b\') % c(\'c\')](\'abc\')                     // -> [\'a\', \'b\', \'c\']\n    peg[c(\'a\') % c(\'b\') >>= fn[xs][xs.join(\'/\')]](\'ab\')      // -> \'a/b\'\n\n    tconfiguration(\'std opt seq continuation\', \'parser.seq\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'seq\', fn_[l[as = arguments] in fn[state][\n        call/cc[fn[cc][opt.unroll[i, as.length][(state = as[i](state)) ? result.push(state.result) : cc(false)], state.accept(state.i, result)]], where[result = []]]])}).\n\n  Alternatives.\n  Denoted using the \'/\' operator. Alternation is transparent; that is, the chosen entry is returned identically. Entries are tried from left to right without backtracking. For example:\n\n  | peg[c(\'a\') / c(\'b\')](\'a\')        // -> \'a\'\n\n    tconfiguration(\'std seq\', \'parser.alt\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'alt\', fn_[l[as = seq[~arguments]] in fn[state][seq[as |[r = _(state)]] && r, where[r = null]]])}).\n\n  Repetition.\n  Denoted using subscripted ranges, similar to the notation used in regular expressions. For example:\n\n  | peg[c(\'a\')[0]]                   // Zero or more \'a\'s\n    peg[c(\'b\')[1,4]                  // Between 1 and 4 \'b\'s\n\n    tconfiguration(\'std opt seq continuation\', \'parser.times\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'times\', fn[p, lower, upper][fn[state][\n        call/cc[fn[cc][opt.unroll[i, lower][++count, (state = p(state)) ? result.push(state.result) : cc(false)], true]] &&\n        call/cc[l*[loop(cc) = (! upper || count++ < upper) && p(state) /se[state = _, when[_]] ? result.push(state.result) && call/tail[loop(cc)] :\n                                                                                                 cc(state.accept(state.i, result))] in loop], where[count = 0, result = []]]])}).\n\n  Optional things.\n  Denoted using arrays. Returns a tree of undefined if the option fails to match. For example:\n\n  | peg[c(\'a\') % [c(\'b\')] % c(\'c\')]  // a followed by optional b followed by c\n\n    tconfiguration(\'std seq continuation\', \'parser.opt\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'opt\', fn[p][fn[state][state.accept(n, r), where*[s = p(state), n = s ? s.i : state.i, r = s && s.result]]])}).\n\n  Positive and negative matches.\n  Denoted using unary + and -, respectively. These consume no input but make assertions:\n\n  | peg[c(\'a\') % +c(\'b\')]            // Matches an \'a\' followed by a \'b\', but consumes only the \'a\'\n    peg[c(\'a\') % -c(\'b\')]            // Matches an \'a\' followed by anything except \'b\', but consumes only the \'a\'\n\n    tconfiguration(\'std seq continuation\', \'parser.match\', function () {\n      this.configure(\'parser.core\').parser /se[_.defparser(\'match\',  fn[p][fn[state][p(state) /re[_  && state.accept(state.i, state.result)]]]),\n                                               _.defparser(\'reject\', fn[p][fn[state][p(state) /re[!_ && state.accept(state.i, null)]]])]}).\n\n  Binding.\n  This is fairly straightforward; a parser is \'bound\' to a function by mapping through the function if it is successful. The function then returns a new result based on the old one. Binding is\n  denoted by the >>= operator.\n\n    tconfiguration(\'std seq continuation\', \'parser.bind\', function () {\n      this.configure(\'parser.core\').parser /se[_.defparser(\'bind\', fn[p, f][fn[state][p(state) /re[_ && _.accept(_.i, f.call(_, _.result))]]])]}).\n\nDSL macro.\nMost of the time you\'ll want to use the peg[] macro rather than hand-coding the grammar. The macro both translates the tree and introduces all of the parsers as local variables (like a with()\nblock, but much faster and doesn\'t earn the wrath of Douglas Crockford).\n\n  tconfiguration(\'std seq continuation\', \'parser.dsl\', function () {\n    this.configure(\'parser.core\').rmacro(qs[peg[_]], fn[x][with_gensyms[_gs][qg[l*[_bindings, _gs = _parser] in fn_[_gs.apply(this, arguments) /re[_ && _.result]]]].replace({\n                                                             _bindings: new this.syntax(\',\', seq[sp[this.parser.parsers] *[qs[_x = _y].replace({_x: _[0], _y: new outer.ref(_[1])})]]),\n                                                             _parser:   this.parser.dsl.macroexpand(x)}),\n                                                           where[outer = this]]),\n    this.parser.dsl = caterwaul.global().clone() /se[\n      _.macro(qs[_], fn[x][x]) /se.dsl[\n        seq[sp[unary]  *![dsl.rmacro(_[1], fn[x][qs[_f(_x)].replace({_f: _[0], _x: x})])]],\n        seq[sp[binary] %[_[1].constructor === String] *!op[dsl.rmacro(qs[_], fn[t][qs[_f(_t)].replace({_f: op[0], _t: t.flatten(op[1]) /se[_.data = \',\']}), when[t.data === op[1]]])]]],\n\n      _.macro(qs[_ >>= _], fn[p, f][qs[bind(_p, _f)].replace({_p: this.macroexpand(p), _f: f})]),\n\n      _.macro(qs[_].as(\'(\'), fn[x][_.macroexpand(x).as(\'(\')]).rmacro(qs[_[_]],    fn[x, lower]       [qs[times(_x, _lower, 0)]     .replace({_x: x, _lower: lower})]).\n                                                              rmacro(qs[_[_, _]], fn[x, lower, upper][qs[times(_x, _lower, _upper)].replace({_x: x, _lower: lower, _upper: upper})]),\n\n      where*[unary = {opt: qs[[_]], match: qs[+_], reject: qs[-_]}, binary = {alt: \'/\', seq: \'%\'}]]}).\n\nFinal configuration.\nLoads both the classes and the peg[] macro.\n\n  configuration(\'parser\', function () {\n    this.configure(\'parser.core parser.c parser.seq parser.alt parser.times parser.opt parser.match parser.bind parser.dsl\')});');