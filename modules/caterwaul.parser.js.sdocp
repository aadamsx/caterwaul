sdocp('sdoc::js::modules/caterwaul.parser', 'Caterwaul parser module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThe caterwaul parser uses a combinatory approach, much like Haskell\'s parser combinator library. The parser consumes elements from a finite input stream and emits the parse tree at each step.\nNote that parsers generated here are not at all insightful or necessarily performant. In particular, left-recursion isn\'t resolved, meaning that the parser will loop forever in this case.\n\n  Basis and acknowledgements.\n  This parser library is based heavily on Chris Double\'s JSParse (available at github.com/doublec/jsparse), which implements a memoized combinatory PEG parser. If you are looking for a simple\n  and well-designed parsing library, I highly recommend JSParse; it will be easier to use and more predictable than caterwaul.parser. Like JSParse, these parsers are memoized and use parsing\n  expression grammars. However, this parser is probably quite a lot slower.\n\nInternals.\nMemoization is restricted to a session rather than being global. This prevents the space leak that would otherwise occur if the parser outlived the result. Behind the scenes the parser\npromotes the input into a parse-state (very much like the ps() function in JSParse). Like other caterwaul libraries, this one uses non-macro constructs behind the scenes. You can easily get at\nthis by accessing stuff inside the caterwaul.parser namespace.\n\n  caterwaul.tconfiguration(\'std seq continuation memoize\', \'parser.core\', function () {\n    this.namespace(\'parser\') /se[_.parse_state(input, i, result, memo) = undefined /se[this.input = input, this.i = i, this.result = result, this.memo = memo],\n                                 _.parse_state /se.s[s.from_input(input) = new _.parse_state(input, 0, null, {}),\n                                                     s.prototype /se[_.accept(n, r) = new this.constructor(this.input, n, r, this.memo),\n                                                                     _.toString()   = \'ps[#{this.input.substr(this.i)}, #{this.r}]\']],\n\n                                 _.memoize               = caterwaul.memoize.from(fn[c, as, f][k in m ? m[k] : (m[k] = f.apply(c, as)),\n                                                                                               where[k = \'#{f.original.memo_id}|#{as[0].i}\', m = as[0].memo || (as[0].memo = {})]]),\n                                 _.promote_non_states(f) = fn[state][f.call(this, state.constructor === _.parse_state ? state : _.parse_state.from_input(state))],\n                                 _.identify(f)           = f /se[_.memo_id = caterwaul.gensym()],\n                                 _.parser(f)             = _.promote_non_states(_.memoize(_.identify(f))),\n                                 _.defparser(name, f)    = _.parsers[name]() = _.parser(f.apply(this, arguments)),\n                                 _.parsers               = {}]}).\n\nNotation.\nParsers are written as collections of named nonterminals. Each nonterminal contains a mandatory expansion and an optional binding:\n\n| peg[c(\'a\') % c(\'b\')]                                  // A grammar that recognizes the character \'a\' followed by the character \'b\'\n  peg[c(\'a\') % c(\'b\') >>= fn[ab][ab[0] + ab[1]]]        // The same grammar, but the AST transformation step appends the two characters\n\nThe >>= notation is borrowed from Haskell; the idea is that the optional binding is a monadic transform on the parse-state monad. (The only difference is that you don\'t have to re-wrap the\nresult in a new parse state using \'return\' as you would in Haskell -- the return here is implied.) The right-hand side of >>= can be any expression that returns a function. It will be\nevaluated directly within its lexical context, so the peg[] macro is scope-transparent modulo gensyms.\n\nParsers are transparent over parentheses. Only the operators described below are converted specially.\n\n  Strings.\n  Strings are parsable by using the c(x) function, which is named this because it matches a constant.\n\n  | peg[c(\'x\')]                 // Parses the string \'x\'\n    peg[c(\'foo bar\')]           // Parses the string \'foo bar\'\n    peg[c([\'foo\', \'bar\'])]      // Parses either the string \'foo\' or the string \'bar\', in mostly-constant time in the size of the array (see below)\n    peg[c({foo: 1, bar: 2})]    // Parses either the string \'foo\' or the string \'bar\'; returns 1 if \'foo\' matched, 2 if \'bar\' matched (also in mostly-constant time)\n    peg[c(/\\d+/, 1)]            // Parses strings of digits with a minimum length of 1. The parse is greedy, and the regexp\'s exec() method output is returned.\n    peg[c(fn[s][3])]            // Always takes three characters, regardless of what they are.\n\n  The c() function can take other arguments as well. One is an array of strings; in this case, it matches against any string in the array. (Matching time is O(l), where l is the number of\n  distinct lengths of strings.) Another is an object; if any directly-contained (!) attribute of the key is parsed and consumed, then the value associated with that key is returned. The time\n  for this algorithm is O(l), where l is the number of distinct lengths of the keys in the object.\n\n  Another option is specifying a regular expression with a minimum length. The rule is that the parser fails immediately if the regexp doesn\'t match the minimum length of characters. If it\n  does match, then the maximum matching length is found. This ends up performing O(log n) regexp-matches against the input, for a total runtime of O(n log n). (The algorithm here is an\n  interesting one: Repeatedly double the match length until matching fails, then binary split between the last success and the first failure.) Because of the relatively low performance of this\n  regexp approach, it may be faster to use a regular finite-automaton approach for routine parsing and lexing. Then again, O(log n) linear-time native code calls may be faster than O(n)\n  constant-time calls in practice.\n\n  Finally, you can also specify a function. If you do this, the function will be invoked on the input and the current offset, and should return the number of characters it intends to consume.\n  It returns a falsy value to indicate failure.\n\n    Implementation.\n    The O(l) complexity bound is guaranteed by pre-indexing potential matches by their lengths. Then the matching process proceeds in terms of suppositions: "Do any 8-character substrings\n    match? If so, return it; otherwise try shorter strings." (I\'m actually fudging the number a bit. It\'s really O(sum(l[i])), where l is the array of string lengths.) All substring lengths\n    have to be tested, and unfortunately from longest to shortest -- this means that the average case is basically the worst case. However, neither is all that bad for a parser.\n\n    tconfiguration(\'std seq continuation\', \'parser.c\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'c\', fn[x, l][\n        x.constructor === String   ? fn[state][state.accept(state.i + x.length, x), when[x === state.input.substr(state.i, x.length)]] :\n        x.constructor === Array    ? l[index = index_entries(x)] in fn[state][check_index(index, state.input, state.i) /re[_ && state.accept(state.i + _.length, _)]] :\n        x.constructor === RegExp   ? fn[state][maximum_length(x, state.input, state.i, l) /re[_ && split_lengths(x, state.input, state.i, l, _)\n                                                                                                   /re[state.accept(state.i + _, x.exec(state.input.substr(state.i, _)))]]] :\n        x.constructor === Function ? fn[state][x.call(state, state.input, state.i) /re[_ && state.accept(state.i + _, state.input.substr(state.i, _))]] :\n                                     l[index = index_entries(seq[sk[x]])] in fn[state][check_index(index, state.input, state.i) /re[_ && state.accept(state.i + _.length, x[_])]],\n\n        where*[index_entries(xs)    = l*[xsp = seq[~xs], ls = seq[sk[!(xsp *[[_.length, true]])] *+Number]] in seq[~ls.sort(fn[x, y][y - x]) *~l[xsp %[_.length === l] *[[\'@#{_}\', true]]]],\n               check_index(i, s, p) = l[r = false, has = Object.prototype.hasOwnProperty] in seq[~i |[has.call(_, \'@\' + s) && (r = s), where[s = s.substr(p, _.length)]]] /re[r],\n\n               fail_length(re, s, p, l)      = p + l < s.length && re.test(s.substr(p, l)) ? find_maximum_length(re, s, p, l << 1) : l,\n               split_lengths(re, s, p, l, u) = l*[b(cc, l, u) = l + 1 < u ? re.test(s.substr(p, u)) ? call/tail[b(cc, l + (u - l >> 1), u)] : call/tail[b(cc, l, u - (u - l >> 1))] : cc(l)] in\n                                               call/cc[fn[cc][b(cc, l1, l2)]]]])}).\n\n  Sequences.\n  Denoted using the \'%\' operator. The resulting AST is flattened into a finite caterwaul sequence. For example:\n\n  | peg[c(\'a\') % c(\'b\') % c(\'c\')](\'abc\')                     // -> [\'a\', \'b\', \'c\']\n    peg[c(\'a\') % c(\'b\') >>= fn[xs][xs.join(\'/\')]](\'ab\')      // -> \'a/b\'\n\n    tconfiguration(\'std opt seq continuation\', \'parser.seq\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'seq\', fn_[l[as = arguments] in fn[state][\n        call/cc[fn[cc][opt.unroll[i, as.length][(state = as[i](state)) ? result.push(state.result) : cc(false)], state.accept(state.i, result)]], where[result = []]]])}).\n\n  Alternatives.\n  Denoted using the \'/\' operator. Alternation is transparent; that is, the chosen entry is returned identically. Entries are tried from left to right without backtracking. For example:\n\n  | peg[c(\'a\') / c(\'b\')](\'a\')        // -> \'a\'\n\n    tconfiguration(\'std seq\', \'parser.alt\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'alt\', fn_[l[as = seq[~arguments]] in fn[state][seq[as |[r = _(state)]] && r, where[r = null]]])}).\n\n  Repetition.\n  Denoted using subscripted ranges, similar to the notation used in regular expressions. For example:\n\n  | peg[c(\'a\')[0]]                   // Zero or more \'a\'s\n    peg[c(\'b\')[1,4]                  // Between 1 and 4 \'b\'s\n\n    tconfiguration(\'std opt seq continuation\', \'parser.times\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'times\', fn[p, lower, upper][fn[state][\n        call/cc[fn[cc][opt.unroll[i, lower][++count, (state = p(state)) ? result.push(state.result) : cc(false)], true]] &&\n        call/cc[l*[loop(cc) = (! upper || count++ < upper) && p(state) /se[state = _, when[_]] ? result.push(state.result) && call/tail[loop(cc)] :\n                                                                                                 cc(state.accept(state.i, result))] in loop], where[count = 0, result = []]]])}).\n\n  Optional things.\n  Denoted using arrays. Returns a tree of undefined if the option fails to match. For example:\n\n  | peg[c(\'a\') % [c(\'b\')] % c(\'c\')]  // a followed by optional b followed by c\n\n    tconfiguration(\'std seq continuation\', \'parser.opt\', function () {\n      this.configure(\'parser.core\').parser.defparser(\'opt\', fn[p][fn[state][state.accept(n, r), where*[s = p(state), n = s ? s.i : state.i, r = s && s.result]]])}).\n\n  Positive and negative matches.\n  Denoted using unary + and -, respectively. These consume no input but make assertions:\n\n  | peg[c(\'a\') % +c(\'b\')]            // Matches an \'a\' followed by a \'b\', but consumes only the \'a\'\n    peg[c(\'a\') % -c(\'b\')]            // Matches an \'a\' followed by anything except \'b\', but consumes only the \'a\'\n\n    tconfiguration(\'std seq continuation\', \'parser.match\', function () {\n      this.configure(\'parser.core\').parser /se[_.defparser(\'match\',  fn[p][fn[state][p(state) /re[_  && state.accept(state.i, state.result)]]]),\n                                               _.defparser(\'reject\', fn[p][fn[state][p(state) /re[!_ && state.accept(state.i, null)]]])]}).\n\n  Binding.\n  This is fairly straightforward; a parser is \'bound\' to a function by mapping through the function if it is successful. The function then returns a new result based on the old one. Binding is\n  denoted by the >>= operator.\n\n    tconfiguration(\'std seq continuation\', \'parser.bind\', function () {\n      this.configure(\'parser.core\').parser /se[_.defparser(\'bind\', fn[p, f][fn[state][p(state) /re[_ && _.accept(_.i, f.call(_, _.result))]]])]}).\n\nDSL macro.\nMost of the time you\'ll want to use the peg[] macro rather than hand-coding the grammar. The macro both translates the tree and introduces all of the parsers as local variables (like a with()\nblock, but much faster and doesn\'t earn the wrath of Douglas Crockford).\n\n  tconfiguration(\'std seq continuation\', \'parser.dsl\', function () {\n    this.configure(\'parser.core\').rmacro(qs[peg[_]], fn[x][with_gensyms[_gs][qg[l*[_bindings, _gs = _parser] in fn_[_gs.apply(this, arguments) /re[_ && _.result]]]].replace({\n                                                             _bindings: new this.syntax(\',\', seq[sp[this.parser.parsers] *[qs[_x = _y].replace({_x: _[0], _y: new outer.ref(_[1])})]]),\n                                                             _parser:   this.parser.dsl.macroexpand(x)}),\n                                                           where[outer = this]]),\n    this.parser.dsl = caterwaul.global().clone() /se[\n      _.macro(qs[_], fn[x][x]) /se.dsl[\n        seq[sp[unary]  *![dsl.rmacro(_[1], fn[x][qs[_f(_x)].replace({_f: _[0], _x: x})])]],\n        seq[sp[binary] %[_[1].constructor === String] *!op[dsl.rmacro(qs[_], fn[t][qs[_f(_t)].replace({_f: op[0], _t: t.flatten(op[1]) /se[_.data = \',\']}), when[t.data === op[1]]])]]],\n\n      _.macro(qs[_ >>= _], fn[p, f][qs[bind(_p, _f)].replace({_p: this.macroexpand(p), _f: f})]),\n\n      _.macro(qs[_].as(\'(\'), fn[x][_.macroexpand(x).as(\'(\')]).rmacro(qs[_[_]],    fn[x, lower]       [qs[times(_x, _lower, 0)]     .replace({_x: x, _lower: lower})]).\n                                                              rmacro(qs[_[_, _]], fn[x, lower, upper][qs[times(_x, _lower, _upper)].replace({_x: x, _lower: lower, _upper: upper})]),\n\n      where*[unary = {opt: qs[[_]], match: qs[+_], reject: qs[-_]}, binary = {alt: \'/\', seq: \'%\'}]]}).\n\nFinal configuration.\nLoads both the classes and the peg[] macro.\n\n  configuration(\'parser\', function () {\n    this.configure(\'parser.core parser.c parser.seq parser.alt parser.times parser.opt parser.match parser.bind parser.dsl\')});');