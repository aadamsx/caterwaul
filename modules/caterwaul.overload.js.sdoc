Operator/syntax overloading module | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
Operator overloading in JS is generally slow and error-prone (if you transform your whole program), but sometimes it's really useful. Operators that don't exist for some object end up falling
back to the default Javascript operator behavior. This is also true when the object in question is null or undefined.

Usage.
It's easy to overload a region of code. Here's how you do it:

| caterwaul.clone('std ... overload')(function () {
    var x = overload[3 + 5];
  })();

The code that gets generated does dispatching to determine whether the operator is implemented for the given class. For this example, the code is:

| var x = (function (_gensym, _gensym2) {return _gensym !== null && _gensym !== undefined && _gensym['+'] ? _gensym['+'](_gensym2) : (_gensym + _gensym2)}).call(this, 3, 5);

The operators that can be overloaded are:

| / * % + - << >> >>> & | ^ && || u+ u- new typeof instanceof in < > <= >= == !=   === !== (be careful with these)
  += -= *= /= &= ^= |= <<= >>= >>>= %=

  caterwaul.tconfiguration('std seq', 'overload', function () {
    let[overload_binary(op, x, y) = qse[fn[_g1, _g2][_g1 !== null && _g1 !== undefined && _g1[_op] ? _g1[_op](_g2) : qg[_g1 + _g2]].call(this, _x, _y)].
                                    replace({_g1: caterwaul.gensym(), _g2: caterwaul.gensym(), _x: x, _y: y, _op: '"#{op}"', '+': op}),
        overload_lvalue(op, x, y) = x.data === '[]' || x.data === '.' ? 
    });
