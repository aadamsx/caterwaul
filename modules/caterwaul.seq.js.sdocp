sdocp('modules/caterwaul.seq.js.sdoc', 'Caterwaul JS sequence library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nJavaScript lacks a robust lazy sequence library. Most of its sequence-manipulation constructs are side-effectful, which means that they take up a lot of code-space and don\'t compose well in\nexpressions. This library is designed to provide first-class sequence macros/classes to (hopefully) obviate the need for \'for\' loops and similar JavaScript statement-level constructs.\n\n  Macros and sequence construction.\n  In addition to providing utility as classes, there are also some nice macros that come with sequences. You get comprehensions, generators, and side-effectful and pure traversal. Here are\n  some examples (using \'std\', \'seq.ana\', \'seq.comp\', and \'seq.iter\'):\n\n  | var naturals_from = seq.ana[x + 1];                                 // O(1) time\n    var naturals      = naturals_from(0);                               // O(1) time\n    naturals.length             // -> Infinity                          // O(1) time (obviously, it\'s a property)\n    naturals.size()             // -> Infinity                          // O(1) time\n    naturals.at(0)              // -> 0                                 // O(1) time\n    naturals.at(1)              // -> 1                                 // O(1) time given that we called at(0) already\n    naturals.force()            // throws error: can\'t force infinite stream // O(1) time\n\n  | var to_10 = naturals.first(10);                                     // O(1) time\n    to_10.length                // -> 10                                // O(1) time\n    to_10.at(0)                 // -> 0                                 // O(1) time\n    to_10.at(9)                 // -> 9                                 // O(n) time (since it\'s generating each element from the previous one)\n    to_10.at(-1)                // -> 9                                 // O(1) time (since generated elements are memoized)\n    to_10.at(10)                // -> undefined                         // O(1) time (out of bounds)\n    to_10.force()               // -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    // O(n) time (returns a copy of the memoized element array)\n    to_10[0]                    // -> 0                                 // O(1) time (this is the cache for this.at(0))\n    to_10[9]                    // -> 9                                 // O(1) time (this is the cache for this.at(9))\n\n  | var to_20 = to_10.first(20);                                        // O(1) time\n    to_20.length                // -> 10 (length must be accurate for <se< iteration below -- see \'Traversal\')\n    to_20.prepare(10)           // -> to_20                             // O(n) time (populates the [n] cache)\n    to_20.prepare(10)           // -> to_20                             // O(1) time (the cache is already there -- this checks only the last element)\n    to_20[0]                    // -> 0                                 // O(1) time (already cached because of prepare())\n    to_20.force()               // -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    // O(n) time (returns a copy)\n\n  | var odds = naturals.grep(fn[x][x & 1]);                             // O(1) time\n    odds.length                 // -> Infinity                          // O(1) time\n    odds.at(0)                  // -> 1                                 // O(n) time (might take a while to find a match)\n    odds.at(1)                  // -> 3                                 // O(n) time\n\n  | var times_3 = x * 3 <sm< naturals;                                  // O(1) time\n    times_3.length              // -> Infinity                          // O(1) time\n    times_3.at(0)               // -> 0                                 // O(1) time\n    times_3.at(1)               // -> 3                                 // O(1) time\n\n  | var depth_first_cartesian_product = (([x, y] <sm< naturals, where[y = x]) <sm< naturals).flatten();         // O(1) time\n    depth_first_cartesian_product.length          // -> Infinity                                                // O(1) time\n    depth_first_cartesian_product.at(0)           // -> [0, 0]                                                  // O(1) time\n    depth_first_cartesian_product.at(1)           // -> [1, 0]                                                  // O(1) time\n\n  | var primes = ! naturals.between(2, x).exists(fn[y][x % y === 0]) <sf< naturals.after(1);                    // O(1) time\n    primes.length                                 // -> Infinity                                                // O(1) time\n    primes.at(0)                                  // -> 2                                                       // O(1) time\n    primes.at(1)                                  // -> 3                                                       // O(n) time\n    primes.at(2)                                  // -> 5                                                       // O(n) time\n\n  | var fibonacci = seq.ana[this.at(n - 1) + this.at(n - 2)] (naturals.before(2));    // More compactly: seq.ana[$(-1) + $(-2)] ([0, 1]);\n    fibonacci.length                              // -> Infinity\n    fibonacci.first(10)                           // -> seq[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]                    // O(n) time\n\n  Traversal.\n  Side-effectful traversal can be achieved by using the each() method (which takes a Javascript function), or by using the <se< or >se> macros, which take a block of code. each() does not\n  rewrite your code, but <se< and >se> do. These macros optimize the rewritten form like this (with gensym details elided):\n\n  | console.log(x) <se< naturals.between(1, 10);\n    // becomes:\n    (function (_gensym_seq) {\n      _gensym_seq.prepare && _gensym_seq.prepare();\n      for (var _gensym_i = 0, _gensym_l = _gensym_seq.length, x; x = _gensym_seq[_gensym_i], _gensym_i < _gensym_l; ++_gensym_i)\n        console.log(x);\n      return _gensym_seq;\n    }) (naturals.between(1, 10));\n\n  Because \'<\' and \'>\' are left-associative, you can use the right-handed >se> to write sequences of side-effects:\n\n  | sequence >se> foo(x) >se> bar(x) >se> bif(x);\n    foo(x) <se< bar(x) <se< bif(x) <se< sequence        // <- Won\'t do what you want!\n    foo(x) <se< (bar(x) <se< (bif(x) <se< sequence))    // <- This is what you want.\n\n  Other traversal functions include <sm< and >sm> (map), <sfm< and >sfm> (flatmap), <sc< and >sc> (fold, \'c\' stands for catamorphism), and <smf< and >smf> (map-filter -- returns a map across\n  your function for elements for which your function is defined). The nice thing about these methods is that you can also use them with arrays -- they don\'t assume any methods besides\n  prepare(), and they use that only if it exists.\n\n  Lazy mapping.\n  The <sm<, <sf<, <sfm<, <sc<, and <smf< transforms (and their right-handed equivalents) return proxy sequences that operate on the originals. This is true even if the original is an array,\n  which has the important consequence that, for example, code like this will probably not do what you want:\n\n  | var xs = [1, 2, 3];\n    var ys = x + 1 <sm< xs;\n    xs[0] = 4;\n    console.log(x) <se< ys;     // Prints 5, 3, 4 instead of 2, 3, 4\n    xs[0] = 5;\n    console.log(x) <se< ys;     // Prints 5, 3, 4 instead of 6, 3, 4\n\n  The issue here is when ys gets forced. In this case it is forced when we use <se< on it; after that its elements aren\'t recomputed. If this is an issue, a safe way to get around it is to\n  call prepare() on the result:\n\n  | var ys = (x + 1 <sm< xs).prepare()  // By default prepares all elements\n\n  This code isn\'t subject to the problem because ys is forced before xs can be modified.\n');