sdocp('modules/caterwaul.seq.js.sdoc', 'Caterwaul JS sequence library | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nJavaScript lacks a robust lazy sequence library. Most of its sequence-manipulation constructs are side-effectful, which means that they take up a lot of code-space and don\'t compose well in\nexpressions. This library is designed to provide first-class sequence macros/classes to (hopefully) obviate the need for \'for\' loops and similar JavaScript statement-level constructs.\n\n  Sequence metaclass.\n  Sequences provide some methods such as \'grep\', and selectors such as \'before\' and \'after\', whose matching parameters can mean very different things depending on what the sequence is used\n  for. As such, you can instantiate the sequence metaclass into a regular class to provide a sequence with well-defined behavior for element matching. For example:\n\n  | var seq        = caterwaul.util.seq;\n    var seq_of_int = seq.specialize({match: fn[pattern, x][pattern.constructor === Number   ? x === pattern :\n                                                           pattern.constructor === Function ? pattern(x) : false]});\n    var seq_modulo = seq.specialize({match: fn[pattern, x][pattern.constructor === Number   ? ! (x % pattern) : ...]});\n\n  | var threes     = seq_of_int.from([1, 2, 3, 4, 5, 4, 3, 2, 1]).grep(3);\n    var evens      = seq_modulo.from([1, 2, 3, 4, 5, 6, 7, 8, 9]).grep(2);\n\n  Macros and sequence construction.\n  In addition to providing utility as classes, there are also some nice macros that come with sequences. You get comprehensions, generators, and side-effectful and pure traversal. Here are\n  some examples (using \'std\', \'seq.ana\', \'seq.comp\', \'seq.cons\', and \'seq.iter\'):\n\n  | var naturals = seq.ana[x + 1](0);                                   // O(1) time\n    naturals.length             // -> Infinity                          // O(1) time (obviously, it\'s a property)\n    naturals.size()             // -> Infinity                          // O(1) time\n    naturals.at(0)              // -> 0                                 // O(1) time\n    naturals.at(1)              // -> 1                                 // O(1) time given that we called at(0) already\n    naturals.force()            // throws error: can\'t force infinite stream // O(1) time\n\n  | var to_10 = naturals.first(10);                                     // O(1) time\n    to_10.length                // -> 10                                // O(1) time\n    to_10.at(0)                 // -> 0                                 // O(1) time\n    to_10.at(9)                 // -> 9                                 // O(n) time (since it\'s generating each element from the previous one)\n    to_10.at(-1)                // -> 9                                 // O(1) time (since generated elements are memoized)\n    to_10.at(10)                // -> undefined                         // O(1) time (out of bounds)\n    to_10.force()               // -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    // O(n) time (returns a copy of the memoized element array)\n    to_10[0]                    // -> 0                                 // O(1) time (this is the cache for this.at(0))\n    to_10[9]                    // -> 9                                 // O(1) time (this is the cache for this.at(9))\n\n  | var to_20 = to_10.first(20);                                        // O(1) time\n    to_20.length                // -> 10 (length must be accurate for <se< iteration below -- see \'Traversal\')\n    to_20.prepare(10)           // -> to_20                             // O(n) time (populates the [n] cache)\n    to_20.prepare(10)           // -> to_20                             // O(1) time (the cache is already there -- this checks only the last element)\n    to_20[0]                    // -> 0                                 // O(1) time (already cached because of prepare())\n    to_20.force()               // -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]    // O(n) time (returns a copy)\n\n  | var odds = naturals.grep(fn[x][x & 1]);                             // O(1) time\n    odds.length                 // -> Infinity                          // O(1) time\n    odds.at(0)                  // -> 1                                 // O(n) time (might take a while to find a match)\n    odds.at(1)                  // -> 3                                 // O(n) time\n\n  | var times_3 = x * 3 <sm< naturals;                                  // O(1) time\n    times_3.length              // -> Infinity                          // O(1) time\n    times_3.at(0)               // -> 0                                 // O(1) time\n    times_3.at(1)               // -> 3                                 // O(1) time\n\n  | var depth_first_cartesian_product = (([x, y] <sm< naturals, where[y = x]) <sm< naturals).flatten();         // O(1) time\n    depth_first_cartesian_product.length          // -> Infinity                                                // O(1) time\n    depth_first_cartesian_product.at(0)           // -> [0, 0]                                                  // O(1) time\n    depth_first_cartesian_product.at(1)           // -> [1, 0]                                                  // O(1) time\n\n  | var primes = ! naturals.between(2, x).exists(fn[y][x % y === 0]) <sf< naturals.after(1);                    // O(1) time\n    primes.length                                 // -> Infinity                                                // O(1) time\n    primes.at(0)                                  // -> 2                                                       // O(1) time\n    primes.at(1)                                  // -> 3                                                       // O(n) time\n    primes.at(2)                                  // -> 5                                                       // O(n) time\n\n  | var fibonacci = seq.ana[this.at(n - 1) + this.at(n - 2)] (naturals.before(2));    // More compactly: seq.ana[$(-1) + $(-2)] ([0, 1]);\n    fibonacci.length                              // -> Infinity\n    fibonacci.first(10)                           // -> seq[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]                    // O(n) time\n\n  | var custom1 = 1 |sc| (2 |sc| (3 |sc| undefined));                                                           // O(n) time (n conses)\n    var custom2 = 4 |sc| (5 |sc| undefined);                                                                    // O(n) time\n    (custom1 |sa| custom2).length                 // -> 5                                                       // O(1) time (lazy append)\n\n  Traversal.\n  Side-effectful traversal can be achieved by using the each() method (which takes a JavaScript function), or by using the <se< or >se> macros, which take a block of code. each() does not\n  rewrite your code, but <se< and >se> do. These macros optimize the rewritten form like this (with gensym details elided):\n\n  | console.log(x) <se< naturals.between(1, 10);\n    // becomes (though see \'Advanced optimization options\' below for the full story here):\n    (function (_gensym_seq) {\n      _gensym_seq.prepare && _gensym_seq.prepare();\n      for (var _gensym_i = 0, _gensym_l = _gensym_seq.length, x; x = _gensym_seq[_gensym_i], _gensym_i < _gensym_l; ++_gensym_i)\n        console.log(x);\n      return _gensym_seq;\n    }) (naturals.between(1, 10));\n\n  Because \'<\' and \'>\' are left-associative, you can use the right-handed >se> to write sequences of side-effects:\n\n  | sequence >se> foo(x) >se> bar(x) >se> bif(x);\n    foo(x) <se< bar(x) <se< bif(x) <se< sequence        // <- Won\'t do what you want!\n    foo(x) <se< (bar(x) <se< (bif(x) <se< sequence))    // <- This is what you want.\n\n  Other traversal functions include <sm< and >sm> (map), <sfm< and >sfm> (flatmap), <sc< and >sc> (fold, \'c\' stands for catamorphism), and <smf< and >smf> (map-filter -- returns a map across\n  your function for elements for which your function is defined). The nice thing about these methods is that you can also use them with arrays -- they don\'t assume any methods besides\n  prepare(), and they use that only if it exists.\n\n    Advanced optimization options.\n    For-loops aren\'t actually that fast in JavaScript, even running under V8. Better is to use some form of loop unrolling such as Duff\'s device (http://en.wikipedia.org/wiki/Duff\'s_device).\n    The sequence library uses this by default (8 steps of unrolling -- see the caterwaul.opt module), but if for some reason you want to use regular for loops instead you can configure it like\n    this:\n\n    | caterwaul.seq.optimize(false);\n\n  Lazy mapping.\n  The <sm<, <sf<, <sfm<, <sc<, and <smf< transforms (and their right-handed equivalents) return proxy sequences that operate on the originals. This is true even if the original is an array,\n  which has the important consequence that, for example, code like this will probably not do what you want:\n\n  | var xs = [1, 2, 3];\n    var ys = x + 1 <sm< xs;\n    xs[0] = 4;\n    console.log(x) <se< ys;     // Prints 5, 3, 4 instead of 2, 3, 4\n    xs[0] = 5;\n    console.log(x) <se< ys;     // Prints 5, 3, 4 instead of 6, 3, 4\n\n  The issue here is when ys gets forced. In this case it is forced when we use <se< on it; after that its elements aren\'t recomputed. If this is an issue, a safe way to get around it is to\n  call prepare() on the result:\n\n  | var ys = (x + 1 <sm< xs).prepare()  // By default prepares all elements\n\n  This code isn\'t subject to the problem because ys is forced before xs can be modified.\n');