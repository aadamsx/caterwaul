Caterwaul parser module | Spencer Tipping
Licensed under the terms of the MIT source code license

Introduction.
The caterwaul parser uses a combinatory approach, much like Haskell's parser combinator library. The parser consumes elements from a finite input stream and emits the parse tree at each step.
Because Javascript runtimes aren't required to optimize tail calls, it internally uses CPS and the tail-call mechanism provided by the continuation library.

Note that parsers generated here are not at all insightful or necessarily performant. In particular, left-recursion isn't resolved, meaning that the parser will loop forever in this case. (And
consume arbitrarily much memory without causing a stack overflow, too, since it's in CPS.)

Usage.
The parser library is built to work with strings, but you can extend it to do a number of different things. Technically you can use the parser combinators without macros, but because of the
CPS conversion it's so miserable that you probably shouldn't bother.

  Parsing strings.
  There are three kinds of parsers. One is a terminal, another is a sequence, and the final is an alternative. For the sake of convenience I've added some others, but they are variants of
  these three. Here's an example of a parser that parses simple (addition and multiplication) arithmetic expressions:

  | var arithmetic = cfg[expression = term   & '+' & expression | '',
                         term       = number & '*' & term       | '',
                         number     = /\d/ & number | ''];

  Now you can use it like this:

  | l*[result         = arithmetic('3+4*5'),
       evaluate(node) = node.rule === 'expression' ? evaluate(node[0]) + evaluate(node[2]) :
                        node.rule === 'term'       ? evaluate(node[0]) * evaluate(node[2]) :
                        node.rule === 'number'     ? Number(node[0] + evaluate(node[1])) : null] in
    evaluate(result);

  Generated parse trees.
  Parse trees are flattened for convenience, and they also implement sequences annotated by the names of the rules they used. A terminal generates an atom (not a sequence), a series of &
  operators generates a flattened sequence of its operands, and the | operator generates whichever of its alternatives succeeded. For example:

  | cfg[top = 'a' & 'b' & 'c']('abc')     // -> {rule: 'top', alternative: 0, length: 3, '0': 'a', '1': 'b', '2', 'c'}
    cfg[top = 'a' | 'b' & 'c']('a')       // -> {rule: 'top', alternative: 0, length: 1, '0': 'a'}
    cfg[top = 'a' | 'b' & 'c']('bc')      // -> {rule: 'top', alternative: 1, length: 2, '0': 'b', '1': 'c'}

  Equivalence classes and comparisons.
  Single elements in the incoming sequence are handed to the various functions that get generated from the parse tree. By this point, the parse tree already encodes the possible type
  coercisions that have taken place. The interesting part is what happens when the cfg[] macro converts things to functions.

  The parser combinators use a caterwaul instance to build up the parser as a function. Ultimately it gets emitted as a fairly complex function that relies on continuation macros.
