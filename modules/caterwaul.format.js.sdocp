sdocp('modules/caterwaul.format.js.sdoc', 'Code formatting module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nCaterwaul\'s code generation is designed for compilation efficiency, but it isn\'t at all human-readable. This module provides a configuration that adds a \'format\' method to Caterwaul. This\nmethod takes a function, string, or syntax tree and returns a string containing reasonably-formatted code.\n\nFormatting rules.\nIndentation is two spaces, and each block-style construct triggers additional indentation. Each semicolon triggers a line-wrap.\n\n  caterwaul.tconfiguration(\'std\', \'format\', function () {\n    var n_spaces = fn[n][n ? \' #{n_spaces(n - 1)}\' : \'\'];\n\n    this.ref(\'format\', function (tree, indentation) {\n      var spaces = n_spaces(indentation << 1), c = this, op = tree.data, map = caterwaul.util.map,\n       serialize = fn[n][fn[x][x ? x.constructor === String ? x : c.format(x, (indentation || 0) + (n || 0)) : \'\']];\n\n      return op === \'()\' || op === \'[]\' ? map(serialize(), [tree[0], op.charAt(0), tree[1], op.charAt(1)]).join(\'\') :\n                    tree.is_invisible() ? map(serialize(), tree).join(\' \') :\n                             op === \'?\' ? \'#{serialize()(tree[0])}\\n#{spaces}  ? #{serialize(1)(tree[1])}\\n#{spaces}  : #{serialize(1)(tree[2])}\' :\n               op === \'(\' || op === \'[\' ? \'#{op}#{serialize()(tree[0])}#{op === "(" ? ")" : "]"}\' :\n                             op === \'{\' ? \'{\\n#{spaces}  #{serialize(1)(tree[0])}\\n#{spaces}}\' :\n                             op === \';\' ? \'#{serialize()(tree[0])};\\n#{spaces}#{serialize()(tree[1])}\' :\n                             op === \'.\' ? \'#{serialize()(tree[0])}.#{serialize()(tree[1])}\' :\n                             op === \',\' ? \'#{serialize()(tree[0])}, #{serialize()(tree[1])}\' :\n                           op === \'for\' ? \'for #{c.format(tree[0]).replace(/\\n/g, " ")} #{serialize()(tree[1])}\' :\n              tree.is_binary_operator() ? tree.length ? map(serialize(), tree).join(\' #{op} \') : op :\n        tree.is_prefix_unary_operator() ? \'#{op.replace(/^u/, "")} #{serialize()(tree[0])}\' :\n       tree.is_postfix_unary_operator() ? \'#{serialize()(tree[0])}#{op.replace(/^u/, "")}\' :\n            tree.is_blockless_keyword() ? \'#{op} #{serialize()(tree[0])}\' :\n               tree.has_grouped_block() ? tree[1] && tree[1].data !== \'{\' && tree[2] && tree.accepts(tree[2]) ?\n                                            \'#{op} #{serialize()(tree[0])} #{serialize()(tree[1])};\\n#{spaces}#{serialize()(tree[2])}\' :\n                                            \'#{op} #{map(serialize(), tree).join(" ")}\' :\n                                          op})});\n');