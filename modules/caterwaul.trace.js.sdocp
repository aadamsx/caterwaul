sdocp('sdoc::js::modules/caterwaul.trace', 'Code tracing module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThe tracing configuration lets you create traces of code as it executes. It gives you a uniform interface to observe the evaluation of each expression in the program. To do this, first enable\nthe \'trace\' configuration, then add hooks. For example, here\'s a profiler:\n\n| var tracer  = caterwaul.clone(\'trace\');\n  var timings = {};\n  var timers  = [];\n  tracer.tracing.before(fn[expression, index]       [timings[index] = timings[index] || 0, timers.push(+new Date())]).\n                  after(fn[expression, value, index][timings[index] += +new Date() - timers.pop()]);\n\nInterface details.\nTracing things involves modifying the generated expressions in a specific way. First, the tracer marks that an expression will be evaluated. This is done by invoking a \'start\' function, which\nthen alerts all of the before-evaluation listeners. Then the tracer evaluates the original expression, capturing its output and alerting listeners in the process. Listeners are free to use\nand/or modify this value, but doing so may change how the program runs. (Note that value types are immutable, so in this case no modification will be possible.)\n\nThere is currently no way to catch errors generated by the code. This requires a more aggressive and much slower method of tracing, and most external Javascript debuggers can give you a\nreasonable stack trace. (You can also deduce the error location by observing the discrepancy between before and after events.)\n\nHere is the basic transformation applied to the code:\n\n| some_expression   ->   (before_hook(qs[some_expression], some_index), after_hook(qs[some_expression], some_expression, some_index))\n\nThe index is an integer that uniquely identifies the expression. This prevents you from having to do anything too weird trying to use syntax trees as hash-keys. (This isn\'t safe anyway due to\nthe intensionality of syntax nodes and their semantics.)\n\nNote that the tracer inserts itself as an after-step in the compilation process. This means that if you have other after-configurations, you should think about whether you want them to operate\non the traced or untraced code. If untraced, then you should configure caterwaul with those configurations first:\n\n| caterwaul.clone(\'X trace\')    // X sees untraced code, then trace takes X\'s output\n  caterwaul.clone(\'trace X\')    // X sees traced code, which is probably not what you want\n\nIf for some reason you need to modify the listener lists, you can access the arrays directly using your_caterwaul.tracing.before_listeners and your_caterwaul.tracing.after_listeners.\n\nThe hard part.\nIf Javascript were any kind of sane language this module would be trivial to implement. Unfortunately, however, it is fairly challenging, primarily because of two factors. One is the role of\nstatement-mode constructs, which can\'t be wrapped directly inside function calls. The other is method invocation binding, which requires either (1) no record of the value of the method itself,\nor (2) caching of the object. In this case I\'ve written a special function to handle the caching to reduce the complexity of the generated code.\n\nBecause certain forms can\'t be quoted directly, I call Caterwaul\'s parse function to get syntax trees. This shouldn\'t be too alarming, but there\'s a reason I\'m not using qs[] or qse[].\n\nGory details.\nHere\'s the list of transformations broken down by construct. Transformation is denoted by T[], and the generic hook transformation is denoted by H[]. T is understood to be recursive, since it\ndrives the tree descent. First, here are the statement-mode transformations:\n\n| T[function foo (x, y) {body}]                                 -> function foo (x, y) {T[body]}\n  T[var x = y, z = w]                                           -> var x = T[y], z = T[w]\n  T[var x]                                                      -> var x\n  T[const x = y, z = w]                                         -> const x = T[y], z = T[w]                     // Most people don\'t use this, but just in case...\n  T[if (x) y; else z]                                           -> if (T[x]) T[y]; else T[z];\n  T[if (x) y;]                                                  -> if (T[x]) T[y];\n  T[for (x; y; z) w;]                                           -> for (T[x]; T[y]; T[z]) T[w];\n  T[for (x in y) z;]                                            -> for (x in T[y]) T[z];                        // Exceptional case: can\'t transform x because lvalue is implied\n  T[for (var x in y) z;]                                        -> for (var x in T[y]) T[z];\n  T[while (x) y;]                                               -> while (T[x]) T[y];\n  T[do x; while (y);]                                           -> do T[x]; while (T[y]);\n  T[try {x} catch (e) {y} finally {z}]                          -> try {T[x]} catch (e) {T[y]} finally {T[z]}\n  T[try {x} catch (e) {y}]                                      -> try {T[x]} catch (e) {T[y]}\n  T[return x]                                                   -> return T[x]\n  T[return]                                                     -> return\n  T[throw x]                                                    -> throw T[x]\n  T[break label]                                                -> break label                                  // Exceptional case: labels aren\'t transformed\n  T[break]                                                      -> break\n  T[continue label]                                             -> continue label\n  T[continue]                                                   -> continue\n  T[label: for ...]                                             -> label: T[for ...]\n  T[label: while ...]                                           -> label: T[while ...]\n  T[switch (x) {case v1: e1; break; ...; default: en}]          -> switch (T[x]) {case v1: T[e1]; break; ...; default: T[en]}\n  T[with (x) y;]                                                -> with (T[x]) T[y];\n  T[x; y]                                                       -> T[x]; T[y]\n  T[{x}]                                                        -> {T[x]}                                       // Done by context on statement-level things (because we trace object literals)\n\nAnd here are the expression-mode transformations:\n\n| T[function (x, y) {body}]                                     -> H[function (x, y) {T[body]}]\n  T[x ? y : z]                                                  -> H[T[x] ? T[y] : T[z]]\n  T[x + y]                                                      -> H[T[x] + T[y]]                               // For most binary operators; exceptions listed below\n  T[+x]                                                         -> H[+T[x]]                                     // For most unary operators; exceptions listed below\n  T[++x], T[--x], T[x++], T[x--]                                -> H[++x], H[--x], H[x++], H[x--]               // Lvalue, so can\'t trace the first value without disassembling the ++ or --\n  T[[x, y, z]]                                                  -> H[[T[x], T[y], T[z]]]\n  T[{x: y, z: w}]                                               -> H[{x: T[y], z: T[w]}]\n  T[object.method(x, y)]                                        -> M[T[object], T[method], [T[x], T[y]]]        // M[] is like H[], but preserves invocation binding\n  T[new f(x, y)]                                                -> H[new T[f](T[x], T[y])]                      // No H[] around the function call\n  T[delete x.y]                                                 -> H[delete T[x].y]                             // Lvalue, so can\'t trace y\n  T[void x]                                                     -> H[void T[x]]                                 // No point really, but capturing for completeness\n  T[typeof x]                                                   -> H[typeof x]                                  // Can\'t trace x due to potential ReferenceErrors if it isn\'t in scope\n  T[f(x, y)]                                                    -> H[T[f](T[x], T[y])]\n  T[x.y]                                                        -> H[T[x].y]\n  T[x.y = z]                                                    -> H[T[x].y = T[z]]\n  T[x[y] = z]                                                   -> H[T[x][T[y]] = T[z]]\n  T[x = y]                                                      -> H[x = T[y]]                                  // And all variants such as +=, -=, etc\n  T[\'literal\']                                                  -> \'literal\'                                    // Literal syntax nodes aren\'t traced\n  T[x, y]                                                       -> T[x], T[y]\n  T[x]                                                          -> H[x]                                         // For all identifiers x\n  T[undefined]                                                  -> H[undefined]                                 // undefined is a variable, not a literal (I\'m reminding myself)\n\n  caterwaul.tconfiguration(\'std seq continuation\', \'trace\', function () {\n    this.namespace(\'tracing\') /se[_.before_listeners = [], _.after_listeners = [], _.before(f) = _ /se[_.before_listeners.push(f)], _.after(f) = _ /se[_.after_listeners.push(f)]],\n\n    this.after(');