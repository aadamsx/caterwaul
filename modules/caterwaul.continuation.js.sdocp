sdocp('sdoc::js::modules/caterwaul.continuation', 'Continuation manipulation module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis module provides macros to assist with continuations. The most widely-known case of continuation manipulation is probably continuation-passing-style conversion, which you use when you do\nnonblocking things such as AJAX. In this case the callback function is the continuation of the call. (I\'m not going to fully explain continuations here, but\nhttp://en.wikipedia.org/wiki/Continuation is a good if intimidating place to start if you\'re into functional programming -- which I assume you are if you\'re using Caterwaul :).)\n\n  caterwaul.configuration(\'continuation.core\', function () {this.shallow(\'continuation\', {})}).\n\nUnwind protection.\nThis is how you can implement error handling. You can intercept both the normal and the escaping cases and specify a return value for each alternative. Unwind-protect ultimately compiles into\na try/catch. Also provided is the unwind[] macro, which causes an unwind through any call/cc operations until an unwind-protect is hit or the toplevel is reached, in which case it shows up as\nan error. unwind[x] is exactly equivalent to (function () {throw x})().\n\nUnwind-protect is of this form:\n\n| unwind_protect[<escape>][<body>]      // === caterwaul.continuation.unwind_protect(fn[e][<escape>], fn_[<body>])\n\nThe escape block will be run if any abnormal escaping is being performed (e.g. escaping via call/cc, unwind[], or an exception). Body is executed regardless, and if it returns normally then\nits return value is the return value of the unwind_protect block. The escape block can refer to \'e\', the escaping value. \'this\' is preserved in the body and escape blocks.\n\n  tconfiguration(\'std\', \'continuation.unwind\', function () {\n    this.configure(\'std.fn continuation.core\').continuation /se[_.unwind_protect = function (escape, f) {try {return f()} catch (e) {return escape(e)}},\n                                                                _.unwind         = function (e) {throw e}];\n    this.rmacro(qs[unwind_protect[_][_]], fn[escape, body][qse[_f(fb[e][_escape], fb_[_body])].replace({_f: new this.ref(this.continuation.unwind_protect), _escape: escape, _body: body})]).\n         rmacro(qs[unwind[_]], fn[e][qs[_f(_e)].replace({_f: new this.ref(this.continuation.unwind), _e: e})])}).\n\nCPS-conversion.\nConverting a whole program to CPS to get re-entrant continuations is a lot of work, so I\'m not even trying that. But localized CPS is really useful, especially for nested AJAX calls and such.\nHere\'s a common example:\n\n| $.getJSON(\'some-url\', fn[result]\n    [$.getJSON(\'some-other-url-#{result.property}\', fn[other_result][...])]);\n\nRather than dealing with this nesting explicitly, it\'s more convenient to use normal l-notation. That\'s exactly what l/cps does:\n\n| l/cps[result       <- $.getJSON(\'some-url\', _),\n        other_result <- $.getJSON(\'some-other-url-#{result.property}\', _)]\n  [console.log(result)];\n\nThere are a couple of things to note about this setup. First, the arrows. This is so that your continuations can be n-ary. (Javascript doesn\'t let you assign into a paren-list.)\n\n| l/cps[(x, y) <- binary_ajax_call(\'some-url\', _)][...];\n\nSecond, and this is important: l/cps returns immediately with the result of the first continuation-producing expression (so in the above example, the return value of binary_ajax_call would be\nthe value of the l/cps[][] block). This has some important ramifications, perhaps most importantly that the code in the block must be side-effectful to be productive. No magic is happening\nhere; l/cps ultimately gets translated into the set of nested functions that you would otherwise write.\n\nAs of version 0.5.5 the alternative "l/cps[x <- ...] in f(x)" notation is supported (basically, just like regular let-bindings). It\'s purely a stylistic thing.\n\nThere\'s also a shorthand form to CPS-convert functions. If you care only about the first parameter (which is true for a lot of functions), you can use the postfix /cps[] form, like this:\n\n| $.getJSON(\'foo\', _) /cps[alert(_)];\n  $.getJSON(\'foo\', _) /cps.x[alert(x)];         // Also has named form\n\nBound variants of both l/cps and /cps[] are also available:\n\n| $.getJSON(\'foo\', _) /cpb[...];\n  l/cpb[x <- foo(_)][...];\n\nThe legacy let/cps and let/cpb forms are also supported for backwards compatibility.\n\nThere\'s an interesting scoping bug in Caterwaul <= 0.5.1. Suppose you have a form that binds _ in some context, but doesn\'t intend for it to be a continuation; for example:\n\n| f(seq[xs *[_ + 1]], _) /cps[...];\n\nIn this case, _ + 1 is supposed to use the implicitly-bound _, not the outer continuation callback. However, the old continuation logic was perfectly happy to rewrite the term with two\ncontinuation functions, a semantic disaster. What happens now is a regular lexical binding for _, which has the added benefit that multiple _\'s in continuation-rewriting positions will refer\nto the same callback function rather than multiply-evaluating it (though I\'m not sure this actually matters...).\n\n  tconfiguration(\'std\', \'continuation.cps\', function () {\n    l*[cps_convert(v, f, b, bound) = qse[l[_ = _c][_f]].replace({_c: caterwaul.macroexpand(qs[_f[_v][_b]].replace({_f: bound ? qs[fb] : qs[fn]})).replace({_v: v.as(\'(\')[0], _b: b}), _f: f}),\n\n         l_cps_def(t, form, bound) = l[inductive(cs, v, f, b) = qs[l/cps[cs][_f]].replace({cs: cs, _f: cps_convert(v, f, b, bound)}), base(v, f, b) = cps_convert(v, f, b, bound)] in\n                                     t.rmacro(qs[l/_form[_, _ <- _] in _].replace({_form: form}), inductive).rmacro(caterwaul.parse(\'let/#{form.serialize()}[_, _ <- _] in _\'), inductive).\n                                       rmacro(qs[l/_form[   _ <- _] in _].replace({_form: form}), base)     .rmacro(caterwaul.parse(\'let/#{form.serialize()}[   _ <- _] in _\'), base).\n                                       rmacro(qs[l/_form[_, _ <- _][_]]  .replace({_form: form}), inductive).rmacro(caterwaul.parse(\'let/#{form.serialize()}[_, _ <- _][_]\'),   inductive).\n                                       rmacro(qs[l/_form[   _ <- _][_]]  .replace({_form: form}), base)     .rmacro(caterwaul.parse(\'let/#{form.serialize()}[   _ <- _][_]\'),   base),\n\n         cps_def(t, form, bound)   = t.rmacro(qs[_ /_form[_]].  replace({_form: form}), fn[f, b][qse[_f /_form._[_b]].replace({_form: form, _f: f, _b: b})]).\n                                       rmacro(qs[_ /_form._[_]].replace({_form: form}), fn[f, v, b][qse[l[_ = _c][_f]].replace(\n                                         {_c: caterwaul.macroexpand(qs[_f[_v][_b]].replace({_f: bound ? qs[fb] : qs[fn]})).replace({_v: v, _b: b}), _f: f})])] in\n\n    this.configure(\'std.fn continuation.core\') /se[cps_def(_, qs[cps], false), cps_def(_, qs[cpb], true), l_cps_def(_, qs[cps], false), l_cps_def(_, qs[cpb], true)]}).\n\nEscaping continuations and tail call optimization.\nThe most common use for continuations besides AJAX is escaping. This library gives you a way to escape from a loop or other function by implementing a non-reentrant call/cc. You can also use\ntail-call-optimized recursion if your functions are written as such.\n\n| call/cc[fn[cc][cc(5)]]        // returns 5\n  call/cc[fn[cc][cc(5), 6]]     // still returns 5\n  call/cc[fn[cc][19]]           // returns 19\n\nTail calls must be indicated explicitly with call/tail. (Otherwise they\'ll be regular calls.) For example:\n\n| var factorial_cps = fn[n, acc, cc][n > 0 ? call/tail[factorial_cps(n - 1, acc * n, cc)] : call/tail[cc(acc)]];\n  call/cc[fn[cc][factorial_cps(5, 1, cc)]];   // -> 120\n\nIn this example it\'s also legal to call the final continuation \'cc\' normally: cc(acc). It\'s faster to use call/tail[cc(acc)] though. Importantly, continuations lose their bindings! This means\nthat tail-calling a method won\'t do what you want:\n\n| call/tail[object.method(5)]   // calls object.method with wrong \'this\'\n\nWhat you can do instead is eta-expand or use Caterwaul\'s /mb notation (note the extra parens; they\'re necessary, just as they would be if you were invoking an /mb\'d method directly):\n\n| call/tail[fn[x][object.method(x)](5)];\n  call/tail[(object/mb/method)(5)];             // At this rate you\'re probably better off using the call_tail function directly.\n\nEither of these will invoke object.method in the right context.\n\nDelimited continuations work because call/cc uses an internal while loop to forward parameters outside of the tail call. This keeps the stack bounded by a constant. Note that tail calls work\nonly inside a call/cc context. You can use them elsewhere, but they will not do what you want. Also, tail calls really do have to be tail calls. You need to return the call/tail[...]\nexpression in order for it to work, just like you\'d have to do in Scheme or ML (except that in JS, return is explicit rather than implicit).\n\nNote that call/cc and call/tail are macros, not functions. The functions are available in normal Javascript form, however (no deep macro-magic is ultimately required to support delimited\ncontinuations). call/cc is stored as caterwaul.continuation.call_cc, and call/tail is caterwaul.continuation.call_tail. The invocation of call_tail is different from call/tail:\n\n| caterwaul.continuation.call_tail.call(f, arg1, arg2, ...);\n\n  tconfiguration(\'std\', \'continuation.delimited\', function () {\n    l[magic = this.configure(\'continuation.core\').continuation.magic = this.magic(\'continuation.delimited\')] in\n    this.continuation /se[_.call_cc     = function (f) {var escaped = false, cc = function (x) {escaped = true; throw x}, frame = {magic: magic, continuation: f, parameters: [cc]};\n                                                        try       {while ((frame = frame.continuation.apply(this, frame.parameters)) && frame && frame.magic === magic); return frame}\n                                                        catch (e) {if (escaped) return e; else throw e}},\n                          _.call_tail() = {magic: magic, continuation: this, parameters: arguments}];\n\n    this.rmacro(qs[call/cc[_]],      fn[f]      [qs[qg[_call_cc.call(this, _f)]].   replace({_call_cc:   new this.ref(this.continuation.call_cc),   _f: f})]).\n         rmacro(qs[call/tail[_(_)]], fn[f, args][qs[qg[_call_tail.call(_f, _args)]].replace({_call_tail: new this.ref(this.continuation.call_tail), _f: f, _args: args})])}).\n\nEnd-user library.\n\n  configuration(\'continuation\', function () {this.configure(\'continuation.core continuation.unwind continuation.cps continuation.delimited\')});');