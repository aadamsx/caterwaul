sdocp('sdoc::js::modules/caterwaul.macro', 'Macro-authoring configurations | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThese configurations used to belong to the Caterwaul standard library, but I\'ve moved them here given how infrequently they are used in practice.\n\n  caterwaul.\n\nMacro authoring tools (the \'defmacro\' library).\nLisp provides some handy macros for macro authors, including things like (with-gensyms (...) ...) and even (defmacro ...). Writing defmacro is simple because \'this\' inside a macroexpander\nrefers to the caterwaul function that is running. It is trivial to expand into \'null\' and side-effectfully define a new macro on that caterwaul object.\n\nAnother handy macro is \'with_gensyms\', which lets you write hygienic macros. For example:\n\n| defmacro[forEach[_][_]][fn[xs, f][with_gensyms[i, l, xs][(function() {for (var i = 0, xs = _xs, l = xs.length, it; it = xs[i], it < l; ++it) {_body}})()].replace({_xs: xs, _body: f})]];\n\nThis will prevent \'xs\', \'l\', and \'i\' from being visible; here is a sample (truncated) macroexpansion:\n\n| forEach[[1, 2, 3]][console.log(it)]   ->  (function() {for (var _gensym_gesr8o7u_10fo11_ = 0, _gensym_gesr8o7u_10fo12_ = [1, 2, 3],\n                                                                  _gensym_gesr8o7u_10fo13_ = _gensym_gesr8o7u_10fo12_.length, it;\n                                                              it = _gensym_gesr8o7u_10fo12_[_gensym_...], _gensym_... < ...; ...) {console.log(it)}})()\n\nSince nobody in their right mind would name a variable _gensym_gesr8o7u_10fo11_, it is effectively collision-proof. (Also, even if you load Caterwaul twice you aren\'t likely to have gensym\ncollisions. The probability of it is one-in-several-billion at least.)\n\nNote that macros defined with \'defmacro\' are persistent; they outlast the function they were defined in. Presently there is no way to define scoped macros. Related to \'defmacro\' is \'defsubst\',\nwhich lets you express simple syntactic rewrites more conveniently. Here\'s an example of a defmacro and an equivalent defsubst:\n\n| defmacro[_ <equals> _][fn[left, right][qs[left === right].replace({left: left, right: right})]];\n  defsubst[_left <equals> _right][_left === _right];\n\nSyntax variables are prefixed with underscores; other identifiers are literals.\n\n  tconfiguration(\'std.qs std.fn std.bind\', \'macro.defmacro\', function () {\n    l[wildcard = fn[n][n.data.constructor === String && n.data.charAt(0) === \'_\' && \'_\']] in\n    this.macro(qs[defmacro[_][_]], fn[pattern, expansion][this.rmacro(pattern, this.compile(this.macroexpand(expansion))), qs[null]]).\n         macro(qs[defsubst[_][_]], fn[pattern, expansion][this.rmacro(pattern.rmap(wildcard), l[wildcards = pattern.collect(wildcard)] in fn_[l[hash = {}, as = arguments]\n                                                            [this.util.map(fn[v, i][hash[v.data] = as[i]], wildcards), expansion.replace(hash)]]), qs[null]])}).\n\n  tconfiguration(\'std.qs std.fn std.bind\', \'macro.with_gensyms\', function () {\n    this.rmacro(qs[with_gensyms[_][_]], fn[vars, expansion][l[bindings = {}][vars.flatten(\',\').each(fb[v][bindings[v.data] = this.gensym()]),\n                                                                             qs[qs[_]].replace({_: expansion.replace(bindings)})]])}).\n\nCompile-time eval (the \'compile_eval\' library).\nThis is one way to get values into your code (though you don\'t have closure if you do it this way). Compile-time evals will be bound to the current caterwaul function and the resulting\nexpression will be inserted into the code as a reference. The evaluation is done at macro-expansion time, and any macros defined when the expression is evaluated are used.\n\n  tconfiguration(\'std.qs std.fn\', \'macro.compile_eval\', function () {\n    this.macro(qs[compile_eval[_]], fn[e][new this.ref(this.compile(this.macroexpand(qs[fn_[_]].replace({_: e}))).call(this))])}).\n\nFinal configuration.\nThis one loads the others.\n\n  configuration(\'macro\', function () {this.configure(\'macro.defmacro macro.with_gensyms macro.compile_eval\')});');