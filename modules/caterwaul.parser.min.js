caterwaul.tconfiguration('std seq continuation memoize','parser.core',function (){this.namespace('parser')/se[_.parse_state(input,i,result,memo)=undefined/se[this.input=input,this.i=i,this.result=result,this.memo=memo],_.parse_state/se.s[s.from_input(input)=new _.parse_state(input,0,null,{}),s.prototype.accept(n,r)=new this.constructor(this.input,n,r,this.memo)],_.memoize=caterwaul.memoize.from(fn[c,as,f][k in m?m[k]:(m[k]=f.apply(c,as)),where[k='#{f.original.memo_id}|#{as[0].i}',m=as[0].memo||(as[0].memo={})]]),_.promote_non_states(f)=fn[state][f.call(this,state.constructor===_.parse_state?state:_.parse_state.from_input(state))],_.identify(f)=f/se[_.memo_id=caterwaul.gensym()],_.parser(f)=_.promote_non_states(_.memoize(_.identify(f))),_.defparser(name,f)=_.parsers[name]()=_.parser(f.apply(this,arguments)),_.parsers={}]}).tconfiguration('std seq continuation','parser.c',function (){this.configure('parser.core').parser.defparser('c',fn[x][fn[state][state.accept(state.i+x.length,x),when[x===state.input.substr(state.i,x.length)]]])}).tconfiguration('std opt seq continuation','parser.seq',function (){this.configure('parser.core').parser.defparser('seq',fn_[l[as=arguments] in fn[state][call/cc[fn[cc][opt.unroll[i,as.length][(state=as[i](state))?result.push(state.result):cc(false)],state.accept(state.i,result)]],where[result=[]]]])}).tconfiguration('std seq','parser.alt',function (){this.configure('parser.core').parser.defparser('alt',fn_[l[as=seq[~arguments]] in fn[state][seq[as|[r=_(state)]]&&r,where[r=null]]])}).tconfiguration('std opt seq continuation','parser.times',function (){this.configure('parser.core').parser.defparser('times',fn[p,lower,upper][fn[state][upper&&(upper-=lower),call/cc[fn[cc][opt.unroll[i,lower][(state=p(state))?result.push(state.result):cc(false)],true]]&&call/cc[l*[count=0,loop(cc)=(!upper||++count<upper)&&(state=p(state))?result.push(state.result)&&call/tail[loop(cc)]:cc(state.accept(state.i,result))] in loop],where[result=[]]]])}).tconfiguration('std seq continuation','parser.opt',function (){this.configure('parser.core').parser.defparser('opt',fn[p][fn[state][state.accept(n,r),where*[s=p(state),n=s?s.i:state.i,r=s&&s.result]]])}).tconfiguration('std seq continuation','parser.match',function (){this.configure('parser.core').parser/se[_.defparser('match',fn[p][fn[state][p(state)/re[_&&state.accept(0,_.result)]]]),_.defparser('reject',fn[p][fn[state][p(state)/re[!_&&state.accept(0,null)]]])]}).configuration('parser',function (){this.configure('parser.core parser.c parser.seq parser.alt parser.times parser.opt parser.match')});