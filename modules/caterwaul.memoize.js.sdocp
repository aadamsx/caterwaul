sdocp('sdoc::js::modules/caterwaul.memoize', 'Memoization module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis memoizer is implemented a bit differently from Perl\'s memoize module; this one leaves more up to the user. To mitigate the difficulty involved in using it I\'ve written a couple of default\nproxy functions. The basic model is that functions are assumed to map some \'state\' (which obviously involves their arguments, but could involve other things as well) into either a return value\nor an exception. This memoization library lets you introduce a proxy around a function call:\n\n| var null_proxy = fn[context, args, f][f.apply(context, args)];                                        // Identity memoizer (does no memoization)\n  var memo_proxy = fn[context, args, f][this[args[0]] || (this[args[0]] = f.apply(context, args))];     // Memoizes on first argument\n  var identity = caterwaul.memoize.from(null_proxy);\n  var memoizer = caterwaul.memoize.from(memo_proxy);\n  var fibonacci = memoizer(fn[x][x < 2 ? x : fibonacci(x - 1) + fibonacci(x - 2)]);                     // O(n) time\n\nHere the \'fstate\' argument represents state specific to the function being memoized. \'f\' isn\'t the real function; it\'s a wrapper that returns an object describing the return value. This object\ncontains:\n\n| 1. The amount of time spent executing the function. This can be used later to expire memoized results (see the \'heap\' module for one way to do this).\n  2. Any exceptions thrown by the function.\n  3. Any value returned by the function.\n\nInternals.\nThe core interface is the proxy function, which governs the memoization process at a low level. It is invoked with three parameters: the invocation context, the original \'arguments\' object,\nand the function being memoized (wrapped by a helper, explained below). It also receives an implicit fourth as \'this\', which is bound to a generic object specific to the memoized function. The\nproxy function owns this object, so it\'s allowed to manipulate it in any way.\n\n  Helpers.\n  The function passed into the proxy isn\'t the original. It\'s been wrapped by a result handler that captures the full range of things the function can do, including throwing an exception. This\n  guarantees the following things:\n\n  | 1. The wrapped function will never throw an exception.\n    2. The wrapped function will always return a truthy value, and it will be an object.\n    3. Each invocation of the wrapped function is automatically timed, and the time is accessible via the .time attribute on its return value.\n\n  The proxy function is expected to return one of these values, which will then be translated into the corresponding real action.\n\n  caterwaul.tconfiguration(\'std seq continuation\', \'memoize\', function () {\n    this.namespace(\'memoize\') /se.m[m.wrap(f) = fn_[l[as = arguments, start = +new Date()] in unwind_protect[{error: e}][{result: f.apply(this, as)}] /se[_.time = +new Date() - start]]\n                                                /se[_.original = f],\n                                    m.perform(result) = result.error ? unwind[result.error] : result.result,\n                                    m.from(proxy) = fn[f][l[state = {}, g = m.wrap(f)] in fn_[m.perform(proxy.call(state, this, arguments, g))]]]});');