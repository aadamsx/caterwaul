sdocp('modules/caterwaul.overload.js.sdoc', 'Operator/syntax overloading module | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nOperator overloading in JS is generally slow and error-prone (if you transform your whole program), but sometimes it\'s really useful. Operators that don\'t exist for some object end up falling\nback to the default Javascript operator behavior. This is also true when the object in question is null or undefined.\n\nUsage.\nIt\'s easy to overload a region of code. Here\'s how you do it:\n\n| caterwaul.clone(\'std ... overload\')(function () {\n    var x = overload[3 + 5];\n  })();\n\nThe code that gets generated does dispatching to determine whether the operator is implemented for the given class. For this example, the code is:\n\n| var x = (function (_gensym, _gensym2) {return _gensym !== null && _gensym !== undefined && _gensym[\'+\'] ? _gensym[\'+\'](_gensym2) : (_gensym + _gensym2)}).call(this, 3, 5);\n\nThe operators that can be overloaded are:\n\n| / * % + - << >> >>> & | ^ && || u+ u- new typeof instanceof in < > <= >= == !=   === !== (be careful with these)\n  += -= *= /= &= ^= |= <<= >>= >>>= %=\n\n  caterwaul.tconfiguration(\'std seq\', \'overload\', function () {\n    let[overload_binary(op, x, y) = qse[fn[_g1, _g2][_g1 !== null && _g1 !== undefined && _g1[_op] ? _g1[_op](_g2) : qg[_g1 + _g2]].call(this, _x, _y)].\n                                    replace({_g1: caterwaul.gensym(), _g2: caterwaul.gensym(), _x: x, _y: y, _op: \'"#{op}"\', \'+\': op}),\n        overload_lvalue(op, x, y) = x.data === \'[]\' || x.data === \'.\' ? \n    });\n');