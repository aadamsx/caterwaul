# Macro authoring utilities | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Macro definitions.
# A macro is simply a partial function from source trees to source trees. It returns a falsy value if it cannot be applied to a given tree; otherwise it returns the replacement (as shown
# above). Because most macros end up replacing one pattern with another, caterwaul lets you use strings instead of requiring you to construct recognizer functions.

# The expander() method distributes across arrays. That is, you can give it an array of things that can be converted into expanders (strings, functions, syntax trees, or arrays), and it will
# build a function that runs backwards through the array, taking the last entry.

caterwaul.module('std.macro', function ($) {
  var syntax_manipulator = function (base_case) {
    var result = function (x) {if (x.constructor === Array) {for (var i = 0, l = x.length, ys = []; i < l; ++i) ys.push(result(x[i]));
                                                             return function (tree) {for (var i = ys.length - 1, r; i >= 0; --i) if (r = ys[i].call(this, tree)) return r}}

                          else return x.constructor === String   ? result($.parse(x)) :
                                      x.constructor === $.syntax ? base_case.call(this, x) : x};
    return result};

  $.pattern      = syntax_manipulator(function (pattern)     {return function (tree)  {return pattern.match(tree)}});
  $.expander     = syntax_manipulator(function (expander)    {return function (match) {return expander.replace(match)}});
  $.alternatives = syntax_manipulator(function (alternative) {throw new Error('must use replacer functions with caterwaul.alternatives()')});

  $.reexpander   = function (expander) {var e = $.expander(expander);
                                        return function (match) {var r = e.call(this, match); return r && this(r)}};

  var composer = function (expander_base_case) {
    return function (pattern, expander) {var new_pattern = $.pattern(pattern), new_expander = expander_base_case(expander);
                                         return function (tree) {var match = new_pattern.call(this, tree); return match && new_expander.call(this, match)}}};

  $.replacer   = composer($.expander);
  $.rereplacer = composer($.reexpander);

# Expression ref generators.
# This is useful when you want to write precompilable references to syntax trees. The qs[] and .qs modifiers use this so that you can include quoted code without invoking the parser. (This
# results in libraries which load more quickly, at the expense of being somewhat larger.)

  $.syntax_to_expression = function (tree) {if (tree.length) {for (var comma = new $.syntax(','), i = 0, l = tree.length; i < l; ++i) comma.push($.syntax_to_expression(tree[i]));
                                                              return nontrivial_node_template.replace({_data: '"' + tree.data.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"',
                                                                                                         _xs: comma.unflatten()})}
                                                        else return trivial_node_template.replace({_data: '"' + tree.data.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'})};

# Global macroexpansion.
# This is a shorthand to enable one-off macroexpansion. The idea is that we build a temporary caterwaul function to do some temporary work.

  $.macroexpand = function (tree) {return $($.alternatives(Array.prototype.slice.call(arguments, 1)))(tree)}});

# Generated by SDoc 
