sdocp('sdoc::js::behaviors/core/inversion', 'Inversion behavior | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nEnabling this behavior results in two interesting things. First, every function will be automatically annotated with an inverse, which is stored as a gensym-encoded attribute on the function.\nSecond, the lvalue behavior will be extended to allow functional and expression destructuring. It isn\'t possible to assign into a complex expression in JS grammar, so only parameters can be\nbound this way.\n\nInversion isn\'t guaranteed to be accurate in the general case. All it guarantees is that it is accurate under the function being inverted. That is, if f is an invertible function and fi is its\ninverse, then x === fi(f(x)) isn\'t true in general. However, f(x) === f(fi(f(x))) generally is.\n\nCombinatory inversion.\nEach kind of expression has certain inversion semantics. Some of them perform runtime type detection to figure out how best to invert something. For example, the + operator is overloaded\nacross strings and numbers, so we have to do a type check on the arguments before knowing which inversion to use. Also, different cases are taken depending on which operand is a constant.\n(Most binary operators fail with two variables.)\n\nInformation gets lost when you invert stuff, as most operators are closed within a finite type. For example, suppose x | 3 = 7. We now don\'t know the lowest two bits of x, so we arbitrarily\nset them to zero for the purposes of destructuring. (Also, if x | 3 = 6, we reject the match because we know something about the bits set by |.)\n\nInversion never degenerates into nondeterminism. That is, ambiguous multivariate cases are rejected immediately rather than explored. So, for example, if f(x, y) = x + y, you can\'t match\nagainst f(x, y) and expect it to work. You could match against f(x, 1) or f(5, y), though, since once the constants are propagated through the expression you will end up with an unambiguous\nway to invert the + operator. In some cases nondeterminism is eliminated through default behavior: if f(x, y) = x && y, then matching against f(x, y) = X will result in x = true, y = X when X\nis truthy, and x = X, y = undefined when X is falsy. || behaves similarly; x || y = X results in x = X, y = undefined when X is true, and x = false, y = X when X is falsy.\n\nConstructor inversion.\nConstructors are a bizarre case of function application, and it\'s possible to invert them with some accuracy. Basically, we track the assignment of parameters into named \'this\' properties and\nconstruct the inverse based on corresponding properties of the object being matched against. For example, the constructor fc[x, y][this.x = x, this.y = y] is invertible by pulling .x and .y\nfrom the object.\n\nDecisional inversion.\nThis isn\'t a joke; it\'s actually possible to invert a decisional sometimes. However, it may end up taking every branch. The idea is that you try the first branch; if it succeeds, then we\nassume the condition variable was true and return. If it fails, then we try the second branch and assume that the condition variable was false. So, for example:\n\n| f(cond, x, y) = cond ? {foo: x} : {bar: y};\n  g(f(b, x, y)) = \'got \' + b + \' with \' + [x, y];\n  g({foo: 10})                  // returns \'got true with 10,undefined\'\n  g({bar: 10})                  // returns \'got false with undefined,10\'\n\nIt\'s important to have decisional inversion because we might want to invert a pattern-matching function. For example:\n\n| foo(\'foo\' + bar) = \'got a foo: \' + bar\n  foo(\'bif\' + bar) = \'got a bif: \' + bar\n  g(foo(x)) = x\n  g(\'got a foo: bar\')           // returns \'foobar\'\n  g(\'got a bif: bar\')           // returns \'bifbar\'\n\nRecursive inversion.\nThis also isn\'t a joke, though you can cause an infinite loop if you\'re not careful. You shouldn\'t really use this, but it\'s a natural side-effect of the way I\'m representing inversions\nanyway. Here\'s an example:\n\n| power_of_two(n) = n === 0 ? 1 : 2 * power_of_two(n - 1);\n  g(power_of_two(x)) = x;\n  g(1)                  // -> 0\n  g(2)                  // -> 1\n  g(4)                  // -> 2\n\nHere\'s what the inverse function looks like (modulo formatting, error checking, etc):\n\n| power_of_two_inverse(x) = x === 1 ? {n: 0} : {n: 1 + power_of_two_inverse(x / 2).n};\n\nDon\'t use this feature! It\'s slow, it may infinite-loop, and it doesn\'t work for most recursive functions because of the nondeterminism limitation. I\'m also not even going to guarantee that it\nworks correctly in trivial cases like this, though if it doesn\'t it\'s probably because of a bug.');