// Module framework | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// Caterwaul often uses classes, but Javascript doesn't specify much in the way of object-oriented development. (No complaints from me about this by the way.) This behavior is an attempt to
// provide a standard basis for caterwaul's extension modules.

//   Implementing multiple inheritance.
//   Constructor functions contain links to their parents. When one of the parents is updated, its children lazily (!) pull updates from it and recompile their prototypes. This means that the
//   prototype chain is in fact flat; all updating is done in a 'soft' way:

//   | var c1 = caterwaul.module();
//     var c2 = caterwaul.module(c1);
//     c1.method('say', given.x in console.log(x));
//     c2.prototype.say                    // undefined
//     c2().say('hi');                     // logs 'hi'
//     c2.prototype.say                    // [function]

//   If you want to immediately pull updates, you can use the compile() method:

//   | c2.prototype.say                    // undefined
//     c2.compile().prototype.say          // [function]

//   There's a very important reason that updates are lazy. If they were eager, then the parent class would have to keep track of its children. But in an environment where classes can be
//   generated from functions, this would create a space leak. So back-linking is the only thing that makes sense in this case.

//   Dynamic extension.
//   Sometimes you want to assign a module's behavior to an object that already exists. This can't be done within the prototype system, but it's simple enough to use manual attribute assignment
//   to do it (which is what happens here internally). Here's an example:

//   | var i1 = c1(document.createElement('div'));
//     i1.say('hi')                        // logs 'hi'

//   In this case, c1 sees the object passed in and knows to extend it with members from its prototype. i1 won't really be a c1 as far as instanceof is concerned, but we don't have much choice
//   about that considering that we're working around Javascript's object model.

//   If you want to have accurate runtime type information about things, you can use the 'object' class:

//   | var i1 = caterwaul.object(document.createElement('div'), c1);
//     i1.is_a(c1)                 // -> c1
//     i1.is_a(HTMLDivElement)     // -> HTMLDivElement
//     i1.is_a(Object)             // -> Object
//     i1.is_a(c2)                 // -> false
//     i1.constructor              // -> HTMLDivElement (hopefully)
//     i1.object_parents()         // -> [caterwaul.object, (maybe others), c1]
//     i1.object_mode()            // -> 'instance' (if the object hadn't come from dynamic extension then this would be 'prototype')
//     i1.object_compile()         // -> updates from parent classes, returns i1

//   This class contains methods that keep track of where the object came from and how to rebuild it if one of the base classes changes. It doesn't come with every new module you create, but
//   you'll probably need it if you intend to build usable classes.

//   Collision security.
//   Caterwaul's module system uses a gensym attribute to store all private class data, so accidental collisions with existing properties are very unlikely to happen. The only downside is that
//   property lookups take marginally longer to complete.
// Generated by SDoc 
