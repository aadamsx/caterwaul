// Context-sensitive syntax tree traversal | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// A recurring pattern in previous versions of caterwaul was to clone the global caterwaul function and set it up as a DSL processor by defining a macro that manually dictated tree traversal
// semantics. This was often difficult to implement because any context had to be encoded bottom-up and in terms of searching rather than top-down inference. This library tries to solve this
// problem by implementing a grammar-like structure for tree traversal.

//   Sequence DSL example.
//   Caterwaul 0.4 introduced the seq[] macro, which enabled most Javascript operators to be reinterpreted as sequence methods. Implementing this transform was fairly gnarly; each macro needed to
//   specify whether it would expand its left/right sides, and such rules could be only one layer deep. Many of the macros looked like this (converted to caterwaul 1.0 notation):

//   | _xs *[_body]   ->  _xs.map(_body, given[_, _i])
//     _xs *~[_body]  ->  qs[_xs.map(_body, given[_, _i])].replace({_xs: match._xs, _body: macroexpand(match._body)) /given.match

//   A more useful approach is to define semantic tags for different parse states and to use those tags to expand various regions of code. For example:

//   | _xs *[_body]   ->  _xs.map(_body, given[_, _i])
//     _xs *~[_body]  ->  _xs.map(seq[_body], given[_, _i])

//   Here the seq[] tag is used to indicate expansion by the named 'seq' transformer.

//   Alternation.
//   You can create alternatives to specify what happens if one macroexpander fails to match a tree. Like a packrat grammar, the first matching alternative is taken with no backtracking. This is
//   done by specifying alternatives in an array:

//   | _node._class -> ['dom_node[_node].addClass(_class)', 'html[_node]._class']

//   The actual mechanism here uses a truth check against the output of the caterwaul function's macroexpand_single() method, which returns a falsy value if no macros matched or the
//   macroexpansion failed to transform anything. (Presumably macros that match would elect to transform the syntax tree somehow.)

//   Default behaviors.
//   A significant advantage of using a structured approach to tree-parsing is that you can define the default behavior for non-matching cases. For many operator-overloading macros we want to
//   leave non-matching cases alone but continue diving through the syntax tree. This is done internally by using 'map' with a function:

//   | seq = caterwaul.grammar();
//     seq.on(null, seq);
// Generated by SDoc 
