// Code trace behavior | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// The tracing configuration lets you create traces of code as it executes. It gives you a uniform interface to observe the evaluation of each expression in the program. To do this, first enable
// the 'trace' configuration, then add hooks. For example, here's a very simple profiler (it doesn't account for 'own time', just 'total time'):

// | var tracer  = caterwaul.clone('trace');
//   var timings = {};
//   var timers  = [];
//   tracer.trace.on_before_trace(timings[expression.id()] = timings[expression.id()] || 0, timers.push(+new Date()), given[expression]).
//                 on_after_trace(timings[expression.id()] += +new Date() - timers.pop(),                             given[expression, value]);
//   tracer(function () {...})();          // Annotations inserted during macroexpansion

// Interface details.
// Tracing things involves modifying the generated expressions in a specific way. First, the tracer marks that an expression will be evaluated. This is done by invoking a 'start' function, which
// then alerts all of the before-evaluation listeners. Then the tracer evaluates the original expression, capturing its output and alerting listeners in the process. Listeners are free to use
// and/or modify this value, but doing so may change how the program runs. (Note that value types are immutable, so in this case no modification will be possible.)

// There is currently no way to catch errors generated by the code. This requires a more aggressive and much slower method of tracing, and most external Javascript debuggers can give you a
// reasonable stack trace. (You can also deduce the error location by observing the discrepancy between before and after events.)

// Here is the basic transformation applied to the code:

// | some_expression   ->  (before_hook(qs[some_expression]), after_hook(qs[some_expression], some_expression))

// Note that the tracer inserts itself as an after-step in the compilation process. This means that if you have other after-configurations, you should think about whether you want them to operate
// on the traced or untraced code. If untraced, then you should configure caterwaul with those configurations first:

// | caterwaul.clone('X trace')    // X sees untraced code, then trace takes X's output
//   caterwaul.clone('trace X')    // X sees traced code, which is probably not what you want

// Note that because tracing uses syntax refs you can't precompile traced code. Normally you wouldn't want to anyway, but it will throw an error if you do.

// The hard part.
// If Javascript were any kind of sane language this module would be trivial to implement. Unfortunately, however, it is fairly challenging, primarily because of two factors. One is the role of
// statement-mode constructs, which can't be wrapped directly inside function calls. The other is method invocation binding, which requires either (1) no record of the value of the method itself,
// or (2) caching of the object. In this case I've written a special function to handle the caching to reduce the complexity of the generated code.

  caterwaul.configuration('core.trace', function () {this.after(this.trace.clone())}).shallow('trace', caterwaul.clone().tconfigure('core.js core.words core.quote', function () {
    this.event('before_trace', 'after_trace'),

//   Expression-mode transformations.
//   Assuming that we're in expression context, here are the transforms that apply. Notationally, H[] means 'hook this', D[] means 'hook this direct method call', I[] means 'hook this indirect
//   method call', E[] means 'trace this expression recursively', and S[] means 'trace this statement recursively'. It's essentially a simple context-free grammar over tree expressions.

    this.shallow('expression', expression.after(trace_directive_expander).configure(function () {
      this.method('assignment_operator', given.op in this.tmacro(qs[_x     = _y].replace({'=': op}), qs[H[all, _x           = E[_y]]].replace({'=': op})).
                                                          tmacro(qs[_x[_y] = _z].replace({'=': op}), qs[H[all, E[_x][E[_y]] = E[_z]]].replace({'=': op})).
                                                          tmacro(qs[_x._y  = _z].replace({'=': op}), qs[H[all, E[_x]._y     = E[_z]]].replace({'=': op}))).
           method('binary_operator',     given.op in this.tmacro(qs[_x + _y].replace({'+': op}), qs[H[all, E[_x] + E[_y]]].replace({'+': op}))).
           method('unary_operator',      given.op in this.tmacro(qs[+_x].replace({'u+': 'u#{op}'}), qs[H[all, +T[_x]]].replace({'u+': 'u#{op}'}))),

      this.tmacro('_x', 'H[_x, _x]').                                                                                   // Base case: identifier or literal
           tmacro('(_x)', '(E[_x])').                                                                                   // Destructuring of parens
           tmacro('++_x', 'H[all, ++_x]').tmacro('--_x', 'H[all, --_x]').
           tmacro('_x++', 'H[all, _x++]').tmacro('_x--', 'H[all, _x--]').                                               // Increment/decrement (can't trace original value)

           tmacro('_x, _y',                 'E[_x], E[_y]').                                                            // Preserve commas -- works in an argument list
           tmacro('_x._y',                  'H[all, E[_x]._y]').                                                        // No tracing for constant attributes
           tmacro('_o._m(_xs)',             'D[all, E[_o], _m, [E[_xs]]]').                                             // Use D[] to indicate direct method binding
           tmacro('_o[_m](_xs)',            'I[all, E[_o], E[_m], [E[_xs]]]').                                          // Use I[] to indicate indirect method binding
           tmacro('typeof _x',              'H[all, typeof _x]').                                                       // No tracing for typeof since the value may not exist
           tmacro('delete _x._y',           'H[all, delete E[_x]._y]').                                                 // Lvalue, so no tracing for the original
           tmacro('new _x(_y)',             'H[all, new H[_x](E[_y])]').                                                // Hook the constructor to prevent method-handling from happening
           tmacro('{_ps}',                  'H[all, {E[_ps]}]').                                                        // Hook the final object and distribute across k/v pairs (more)
           tmacro('_k: _v',                 '_k: E[_v]').                                                               // Ignore keys (which are constant)
           tmacro('[_xs]',                  'H[all, [E[_xs]]]').                                                        // Hook the final array and distribute across elements
           tmacro('_x ? _y : _z',           'H[all, E[_x] ? E[_y] : E[_z]]').
           tmacro('function (_xs) {_body}', 'H[all, function (_xs) {S[_body]}]'),                                       // Trace body in statement mode rather than expression mode

      this.assignment_operator(it) -over- qw('= += -= *= /= %= &= |= ^= <<= >>= >>>='),                                 // Use methods above to define these regular macros
      this.binary_operator(it)     -over- qw('() [] + - * / % < > <= >= == != === !== in instanceof ^ & | && ||'),
      this.unary_operator(it)      -over- qw('+ - void')})),

//   Statement-mode transformations.
//   A lot of the time this will drop back into expression mode. However, there are a few cases where we need disambiguation. One is the var statement, where we can't hook the result of the
//   assignment. Another is the {} construct, which can be either a block or an object literal.

//   There's some interesting stuff going on with = and commas. The reason is that sometimes you have var definitions, and they contain = and , trees that can't be traced quite the same way that
//   they are in expressions. For example consider this:

//   | var x = 5, y = 6;

//   In this case we can't evaluate 'x = 5, y = 6' in expression context; if we did, it would produce H[x = H[5]], H[y = H[6]], and this is not valid Javascript within a var statement. Instead,
//   we have to produce x = H[5], y = H[6]. The statement-mode comma and equals rules do exactly that. Note that we don't lose anything by doing this because in statement context the result of an
//   assignment is never used anyway.

    this.shallow('statement', statement.after(trace_directive_expander).configure(function () {
      this.tmacro('_x',                         'E[_x]').                         tmacro('for (_x) _y',                           'for (S[_x]) S[_y]').
           tmacro('{_x}',                       '{S[_x]}').                       tmacro('for (_x; _y; _z) _body',                'for (S[_x]; E[_y]; E[_z]) S[_body]').
           tmacro('_x; _y',                     'S[_x]; S[_y]').                  tmacro('while (_x) _y',                         'while (E[_x]) S[_y]').
                                                                                  tmacro('do _x; while (_y)',                     'do S[_x]; while (E[_y])').
           tmacro('function _f(_args) {_body}', 'function _f(_args) {S[_body]}'). tmacro('do {_x} while (_y)',                    'do {S[_x]} while (E[_y])').
           tmacro('_x, _y',                     'S[_x], S[_y]').
           tmacro('_x = _y',                    '_x = E[_y]').                    tmacro('try {_x} catch (_e) {_y}',              'try {S[_x]} catch (_e) {S[_y]}').
           tmacro('var _xs',                    'var S[_xs]').                    tmacro('try {_x} catch (_e) {_y} finally {_z}', 'try {S[_x]} catch (_e) {S[_y]} finally {S[_z]}').
           tmacro('const _xs',                  'const S[_xs]').                  tmacro('try {_x} finally {_y}',                 'try {S[_x]} finally {S[_y]}').

           tmacro('if (_x) _y',                 'if (E[_x]) S[_y]').              tmacro('return _x',                             'return E[_x]').
           tmacro('if (_x) _y; else _z',        'if (E[_x]) S[_y]; else S[_z]').  tmacro('return',                                'return').
           tmacro('if (_x) {_y} else _z',       'if (E[_x]) {S[_y]} else S[_z]'). tmacro('throw _x',                              'throw E[_x]').
                                                                                  tmacro('break _label',                          'break _label').
           tmacro('switch (_c) {_body}',        'switch (E[_c]) {S[_body]}').     tmacro('break',                                 'break').
           tmacro('with (_x) _y',               'with (E[_x]) S[_y]').            tmacro('continue _label',                       'continue _label').
                                                                                  tmacro('continue',                              'continue').
                                                                                  tmacro('_label: _stuff',                        '_label: S[_stuff]')})),

//   Hook generation.
//   Most of the actual hook generation code is fairly routine for JIT stuff. Where it gets interesting is the macro definitions that cause the code to be traversed. These aren't pre-expanded;
//   rather, they're converted into gensyms to avoid collisions with the code and then treated as macros. However, macroexpanding these definitions can't be done by the same macroexpander that
//   generates them. The reason is the existence of patterns like _x -> H[_x] -- this will loop forever, since _x matches H[_x].

//   Therefore, there's a separate caterwaul function that is preconfigured to handle the hook signals. This one recognizes the gensyms produced during the grammar expansion and creates the
//   actual hook definitions. This in turn kicks off more grammar expansions and so forth until the only expansions left are terminal ones. At this point the process halts.

//   Note that these macros actually receive two copies of the tree that they transform. One of them is the original tree prior to annotation, and the other is the annotated original (i.e. with
//   S[] and E[] markers). The reason for this separation is that we don't want to pass an annotated tree into the before_trace and after_trace hooks, since the user may want to print them and
//   won't want a bunch of weird gensyms in their code. So we stash a copy of the original. This doesn't increase memory usage much at all because of aliasing.

    this.shallow('trace_directive_expander', trace_directive_expander.configure(function () {
      this.method('tmacro', this.macro(convert_trace_directives_in(lhs), rhs) /given[lhs, rhs]).

           tmacro('H[_tree, _x]',                              given.match in expression_hook(match._tree, match._x)).
           tmacro('D[_tree, _object, _method, [_parameters]]', given.match in direct_method_hook  (match._tree, match)).
           tmacro('I[_tree, _object, _method, [_parameters]]', given.match in indirect_method_hook(match._tree, match)).

           tmacro('E[_x]',                                     given.match in expression(match._x)).
           tmacro('S[_x]',                                     given.match in statement(match._x))})),

//   Entry point.
//   This is where we the trace function starts. We assume statement context, which is required for eval-style functionality to work correctly.

    this.final_macro('_x', statement(match._x) /given.match),
    this.self_variable = self,
    this.on_bake(expression.bake() -then- statement.bake() -then- trace_directive_expander.bake() -given.invocation),

    where[self                                                = this,
          qw(s)                                               = s.split(/\s+/),

          // Tracing setup: caterwaul functions to carry out the trace annotations.
          trace_directive_aliases                             = {} /effect[o[it] = this.gensym(), over[qw('I D H S E')], where[o = it]] /effect[o[o[it]] = it, over_keys[o], where[o = it]],
          convert_trace_directives_in(tree)                   = self.ensure_syntax(tree).replace(trace_directive_aliases),

          with_tmacro()                                       = this.method('tmacro', this.final_macro(lhs, convert_trace_directives_in(rhs)) /given[lhs, rhs]),

          statement                                           = this.clone(with_tmacro),
          expression                                          = this.clone(with_tmacro),
          trace_directive_expander                            = this.clone(),

          // Hook methods: invoked from inside the generated code on runtime-generated values (though 'tree' is a ref to the syntax tree).
          before_hook(tree)                                   = self.before_trace(tree),
          after_hook(tree, value)                             = self.after_trace(tree, value) -returning- value,
          after_method_hook(tree, object, method, parameters) = self.before_trace(tree[0]) -then- self.after_trace(tree[0], resolved) -then-
                                                                after_hook(tree, resolved.apply(object, parameters)) -where[resolved = object[method]],

          before_hook_ref                                     = new this.ref(before_hook),
          after_hook_ref                                      = new this.ref(after_hook),
          after_method_hook_ref                               = new this.ref(after_method_hook),

          // Hook generators: called at compile-time to generate trees that refer to the hook methods above.
          expression_hook_template                            = qs[_before_hook(_tree), _after_hook(_tree, _expression)].as('('),
          expression_hook(original, tree)                     = expression_hook_template.replace({_before_hook: before_hook_ref, _after_hook: after_hook_ref, _tree: new self.ref(original),
                                                                                                  _expression: tree.as('(')}),

          indirect_method_hook_template                       = qs[_before_hook(_tree), _after_hook(_tree, _object, _method, [_parameters])].as('('),
          quote_method_name(method)                           = '"#{method.data.replace(/"/g, "\\\"")}"',

          method_hook(tree, object, method, parameters)       = indirect_method_hook_template.replace({_before_hook: before_hook_ref, _after_hook: after_method_hook_ref,
                                                                                                       _tree: new self.ref(tree), _object: object, _method: method, _parameters: parameters}),

          direct_method_hook(tree, match)                     = method_hook(tree, match._object, quote_method_name(match._method), match._parameters),
          indirect_method_hook(tree, match)                   = method_hook(tree, match._object, match._method, match._parameters)]}));
// Generated by SDoc 
