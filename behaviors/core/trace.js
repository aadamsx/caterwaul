// Code trace behavior | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// The tracing configuration lets you create traces of code as it executes. It gives you a uniform interface to observe the evaluation of each expression in the program. To do this, first enable
// the 'trace' configuration, then add hooks. For example, here's a very simple profiler (it doesn't account for 'own time', just 'total time'):

// | var tracer  = caterwaul.clone('trace');
//   var timings = {};
//   var timers  = [];
//   tracer.on_before_trace(timings[expression.id()] = timings[expression.id()] || 0, timers.push(+new Date()), given[expression]).
//           on_after_trace(timings[expression.id()] += +new Date() - timers.pop(),                             given[expression, value]);

// Interface details.
// Tracing things involves modifying the generated expressions in a specific way. First, the tracer marks that an expression will be evaluated. This is done by invoking a 'start' function, which
// then alerts all of the before-evaluation listeners. Then the tracer evaluates the original expression, capturing its output and alerting listeners in the process. Listeners are free to use
// and/or modify this value, but doing so may change how the program runs. (Note that value types are immutable, so in this case no modification will be possible.)

// There is currently no way to catch errors generated by the code. This requires a more aggressive and much slower method of tracing, and most external Javascript debuggers can give you a
// reasonable stack trace. (You can also deduce the error location by observing the discrepancy between before and after events.)

// Here is the basic transformation applied to the code:

// | some_expression   ->   (before_hook(qs[some_expression]), after_hook(qs[some_expression], some_expression))

// Note that the tracer inserts itself as an after-step in the compilation process. This means that if you have other after-configurations, you should think about whether you want them to operate
// on the traced or untraced code. If untraced, then you should configure caterwaul with those configurations first:

// | caterwaul.clone('X trace')    // X sees untraced code, then trace takes X's output
//   caterwaul.clone('trace X')    // X sees traced code, which is probably not what you want

// Note that because tracing uses syntax refs you can't precompile traced code. Normally you wouldn't want to anyway, but it will throw an error if you do.

// The hard part.
// If Javascript were any kind of sane language this module would be trivial to implement. Unfortunately, however, it is fairly challenging, primarily because of two factors. One is the role of
// statement-mode constructs, which can't be wrapped directly inside function calls. The other is method invocation binding, which requires either (1) no record of the value of the method itself,
// or (2) caching of the object. In this case I've written a special function to handle the caching to reduce the complexity of the generated code.

// Gory details.
// Here's the list of transformations broken down by construct. Transformation is denoted by T[], and the generic hook transformation is denoted by H[]. T is understood to be recursive, since it
// drives the tree descent. First, here are the statement-mode transformations:

// | T[function foo (x, y) {body}]                                 -> function foo (x, y) {T[body]}
//   T[var x = y, z = w]                                           -> var x = T[y], z = T[w]
//   T[var x]                                                      -> var x
//   T[const x = y, z = w]                                         -> const x = T[y], z = T[w]                     // Most people don't use this, but just in case...
//   T[if (x) y; else z]                                           -> if (T[x]) T[y]; else T[z];
//   T[if (x) y;]                                                  -> if (T[x]) T[y];
//   T[for (x; y; z) w;]                                           -> for (T[x]; T[y]; T[z]) T[w];
//   T[for (x in y) z;]                                            -> for (x in T[y]) T[z];                        // Exceptional case: can't transform x because lvalue is implied
//   T[for (var x in y) z;]                                        -> for (var x in T[y]) T[z];
//   T[while (x) y;]                                               -> while (T[x]) T[y];
//   T[do x; while (y);]                                           -> do T[x]; while (T[y]);
//   T[try {x} catch (e) {y} finally {z}]                          -> try {T[x]} catch (e) {T[y]} finally {T[z]}
//   T[try {x} catch (e) {y}]                                      -> try {T[x]} catch (e) {T[y]}
//   T[return x]                                                   -> return T[x]
//   T[return]                                                     -> return
//   T[throw x]                                                    -> throw T[x]
//   T[break label]                                                -> break label                                  // Exceptional case: labels aren't transformed
//   T[break]                                                      -> break
//   T[continue label]                                             -> continue label
//   T[continue]                                                   -> continue
//   T[label: for ...]                                             -> label: T[for ...]
//   T[label: while ...]                                           -> label: T[while ...]
//   T[switch (x) {case v1: e1; break; ...; default: en}]          -> switch (T[x]) {case v1: T[e1]; break; ...; default: T[en]}
//   T[with (x) y;]                                                -> with (T[x]) T[y];
//   T[x; y]                                                       -> T[x]; T[y]
//   T[{x}]                                                        -> {T[x]}                                       // Done by context on statement-level things (because we trace object literals)

  caterwaul.configuration('core.trace', function () {this.after(this.trace)}).shallow('trace', caterwaul.clone().configure(caterwaul.clone('core.js core.words core.quote')(function () {
    this.event('before_trace', 'after_trace').method('tmacro', this.macro(lhs, expand_traces(rhs)) /given[lhs, rhs]).

//   Expression-mode transformations.
//   Assuming that we're in expression context, here are the transforms that apply. Notationally, H[] means 'hook this', M[] means 'hook this method call', E[] means 'trace this expression
//   recursively', and S[] means 'trace this statement recursively'. It's essentially a context-free grammar over tree expressions.

    expression.tmacro('_x',                        'H[_x]').
               tmacro('_x, _y',                    'E[_x], E[_y]').
               tmacro('_x._y',                     'H[E[_x]._y]').

               tmacro('_x = _y',                   'H[_x = E[_y]]').
               tmacro('_x += _y',                  'H[_x += E[_y]]').
               tmacro('_x -= _y',                  'H[_x -= E[_y]]').
               tmacro('_x *= _y',                  'H[_x *= E[_y]]').
               tmacro('_x /= _y',                  'H[_x /= E[_y]]').
               tmacro('_x %= _y',                  'H[_x %= E[_y]]').
               tmacro('_x ^= _y',                  'H[_x ^= E[_y]]').
               tmacro('_x &= _y',                  'H[_x &= E[_y]]').
               tmacro('_x |= _y',                  'H[_x |= E[_y]]').
               tmacro('_x <<= _y',                 'H[_x <<= E[_y]]').
               tmacro('_x >>= _y',                 'H[_x >>= E[_y]]').
               tmacro('_x >>>= _y',                'H[_x >>>= E[_y]]').

               tmacro('_x[_y] = _z',               'H[E[_x][E[_y]] = E[_z]]').

               tmacro('_x._y = _z',                'H[E[_x]._y = E[_z]]').

               tmacro('_f(_xs)',                   'H[E[_f](E[_xs])]').
               tmacro('typeof _x',                 'H[typeof _x]').
               tmacro('void _x',                   'H[void E[_x]]').
               tmacro('delete _x._y',              'H[delete E[_x]._y]').
               tmacro('new _f(_xs)',               'H[new E[_f](E[_xs])]').
               tmacro('_o._m(_xs)',                'M[E[_o], _m, [E[_xs]]]').
               tmacro('{_ps}',                     'H[{E[_ps]}]').
               tmacro('_k: _v',                    '_k: E[_v]').
               tmacro('[_xs]',                     'H[[E[_xs]]]').
               tmacro('++_x',                      'H[++_x]').
               tmacro('--_x',                      'H[--_x]').
               tmacro('_x++',                      'H[_x++]').
               tmacro('_x--',                      'H[_x--]').
               tmacro('+_x',                       'H[+E[_x]]').
               tmacro('_x + _y',                   'H[E[_x] + E[_y]]').
               tmacro('_x ? _y : _z',              'H[E[_x] ? E[_y] : E[_z]]').
               tmacro('function (_xs) {_body}',    'H[function (_xs) {S[_body]}]').
               tmacro('(_x)',                      'E[_x]').

//   Statement-mode transformations.

    where[self                                                 = this,


          before_hook(tree)                                    = self.before_trace(tree),
          after_hook(tree, value)                              = self.after_trace(tree, value) -returning- value,
          after_method_hook(tree, object, method, parameters)  = self.before_trace(tree[0]) -then- self.after_trace(tree[0], resolved) -then-
                                                                 self.after_trace(tree, resolved.apply(object, parameters)) -where[resolved = object[method]],

          before_hook_ref                                      = new this.ref(before_hook),
          after_hook_ref                                       = new this.ref(after_hook),
          after_method_hook_ref                                = new this.ref(after_method_hook),

          expression_hook_template                             = qs[_before_hook(_tree, _index), _after_hook(_tree, _index, _expression)].as('('),
          expression_hook(tree, index)                         = expression_hook_template.replace({_before_hook: before_hook, _after_hook: after_hook, _tree: new self.ref(tree),
                                                                                                   _index: index.toString(), _expression: tree}),

          indirect_method_hook_template                        = qs[_before_hook(_tree, _index), _after_hook(_tree, _index, _object, _method, [_parameters])].as('('),
          quote_method_name(method)                            = '"#{method.data.replace(/"/g, "\\\"")}"',

          method_hook(tree, index, object, method, parameters) = indirect_method_hook_template.replace({_before_hook: this.before_method_hook, _after_hook: this.after_method_hook,
                                                                                                        _tree: new this.ref(tree), _index: index.toString(), _object: object, _method: method,
                                                                                                        _parameters: parameters}),

          direct_method_hook(tree, index, match)               = method_hook(tree, index, match._object, quote_method_name(match._method), match._parameters),
          indirect_method_hook(tree, index, match)             = method_hook(tree, index, match._object, match._method, match._parameters)]})));
// Generated by SDoc 
