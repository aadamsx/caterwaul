// Code trace behavior | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// The tracing configuration lets you create traces of code as it executes. It gives you a uniform interface to observe the evaluation of each expression in the program. To do this, first enable
// the 'trace' configuration, then add hooks. For example, here's a very simple profiler (it doesn't account for 'own time', just 'total time'):

// | var tracer  = caterwaul.clone('trace');
//   var timings = {};
//   var timers  = [];
//   tracer.on_before_trace(timings[expression.id()] = timings[expression.id()] || 0, timers.push(+new Date()), given[expression]).
//           on_after_trace(timings[expression.id()] += +new Date() - timers.pop(),                             given[expression, value]);

// Interface details.
// Tracing things involves modifying the generated expressions in a specific way. First, the tracer marks that an expression will be evaluated. This is done by invoking a 'start' function, which
// then alerts all of the before-evaluation listeners. Then the tracer evaluates the original expression, capturing its output and alerting listeners in the process. Listeners are free to use
// and/or modify this value, but doing so may change how the program runs. (Note that value types are immutable, so in this case no modification will be possible.)

// There is currently no way to catch errors generated by the code. This requires a more aggressive and much slower method of tracing, and most external Javascript debuggers can give you a
// reasonable stack trace. (You can also deduce the error location by observing the discrepancy between before and after events.)

// Here is the basic transformation applied to the code:

// | some_expression   ->   (before_hook(qs[some_expression]), after_hook(qs[some_expression], some_expression))

// Note that the tracer inserts itself as an after-step in the compilation process. This means that if you have other after-configurations, you should think about whether you want them to operate
// on the traced or untraced code. If untraced, then you should configure caterwaul with those configurations first:

// | caterwaul.clone('X trace')    // X sees untraced code, then trace takes X's output
//   caterwaul.clone('trace X')    // X sees traced code, which is probably not what you want

// Note that because tracing uses syntax refs you can't precompile traced code. Normally you wouldn't want to anyway, but it will throw an error if you do.

// The hard part.
// If Javascript were any kind of sane language this module would be trivial to implement. Unfortunately, however, it is fairly challenging, primarily because of two factors. One is the role of
// statement-mode constructs, which can't be wrapped directly inside function calls. The other is method invocation binding, which requires either (1) no record of the value of the method itself,
// or (2) caching of the object. In this case I've written a special function to handle the caching to reduce the complexity of the generated code.

  caterwaul.configuration('core.trace', function () {this.after(this.trace)}).shallow('trace', caterwaul.clone().configure(caterwaul.clone('core.js core.words core.quote')(function () {
    this.event('before_trace', 'after_trace').method('tmacro', this.macro(lhs, expand_traces(rhs)) /given[lhs, rhs]),

//   Expression-mode transformations.
//   Assuming that we're in expression context, here are the transforms that apply. Notationally, H[] means 'hook this', M[] means 'hook this method call', E[] means 'trace this expression
//   recursively', and S[] means 'trace this statement recursively'. It's essentially a context-free grammar over tree expressions.

    this.shallow('expression', this.clone(function () {
      this.variadic('assignment_operator', this.tmacro(qs[_x     = _y].replace({'=': op}), qs[H[_x           = E[_y]]].replace({'=': op})).
                                                tmacro(qs[_x[_y] = _z].replace({'=': op}), qs[H[E[_x][E[_y]] = E[_z]]].replace({'=': op})).
                                                tmacro(qs[_x._y  = _z].replace({'=': op}), qs[H[E[_x]._y     = E[_z]]].replace({'=': op})) | given.op).
           variadic('binary_operator',     this.tmacro(qs[_x + _y].replace({'+': op}), qs[H[E[_x] + E[_y]]].replace({'+': op}))            | given.op).
           variadic('unary_operator',      this.tmacro(qs[+_x].replace({'u+': 'u#{op}'}), qs[H[+T[_x]]].replace({'u+': 'u#{op}'}))         | given.op),

      this.tmacro('_x', 'H[_x]').                                                                                       // Base case: identifier or literal
           tmacro('(_x)', '(E[_x])').                                                                                   // Destructuring of parens
           tmacro('++_x', 'H[++_x]').tmacro('--_x', 'H[--_x]').tmacro('_x++', 'H[_x++]').tmacro('_x--', 'H[_x--]').     // Increment/decrement (can't trace original value)

           tmacro('_x, _y',                 'E[_x], E[_y]').                                                            // Preserve commas -- works in an argument list
           tmacro('_x._y',                  'H[E[_x]._y]').                                                             // No tracing for constant attributes
           tmacro('typeof _x',              'H[typeof _x]').                                                            // No tracing for typeof since the value may not exist
           tmacro('delete _x._y',           'H[delete E[_x]._y]').                                                      // Lvalue, so no tracing for the original
           tmacro('_o._m(_xs)',             'M[E[_o], _m, [E[_xs]]]').                                                  // Use M[] to provide correct binding via apply()
           tmacro('{_ps}',                  'H[{E[_ps]}]').                                                             // Hook the final object and distribute across k/v pairs (more)
           tmacro('_k: _v',                 '_k: E[_v]').                                                               // Ignore keys (which are constant)
           tmacro('[_xs]',                  'H[[E[_xs]]]').                                                             // Hook the final array and distribute across elements
           tmacro('_x ? _y : _z',           'H[E[_x] ? E[_y] : E[_z]]').
           tmacro('function (_xs) {_body}', 'H[function (_xs) {S[_body]}]'),                                            // Trace body in statement mode rather than expression mode

      this.assignment_operator(it) -over- qw('= += -= *= /= %= &= |= ^= <<= >>= >>>='),                                 // Use methods above to define these regular macros
      this.binary_operator(it)     -over- qw('() [] + - * / % < > <= >= == != === !== in instanceof ^ & | && ||'),
      this.unary_operator(it)      -over- qw('+ - void new')})),

//   Statement-mode transformations.
//   A lot of the time this will drop back into expression mode. However, there are a few cases where we need disambiguation. One is the var statement, where we can't hook the result of the
//   assignment. Another is the {} construct, which can be either a block or an object literal.

    this.shallow('statement', this.clone(function () {
      this.tmacro('_x',                                    'E[_x]').
           tmacro('{_x}',                                  '{S[_x]}').
           tmacro('_x; _y',                                'S[_x]; S[_y]').

           tmacro('function _f(_args) {_body}',            'function _f(_args) {S[_body]}').
           tmacro('_x, _y',                                'S[_x], S[_y]').
           tmacro('_x = _y',                               '_x = E[_y]').
           tmacro('var _xs',                               'var S[_xs]').
           tmacro('const _xs',                             'const S[_xs]').

           tmacro('if (_x) _y',                            'if (E[_x]) S[_y]').
           tmacro('if (_x) _y; else _z',                   'if (E[_x]) S[_y]; else S[_z]').
           tmacro('if (_x) {_y} else _z',                  'if (E[_x]) {S[_y]} else S[_z]').

           tmacro('switch (_c) {_body}',                   'switch (E[_c]) {S[_body]}').
           tmacro('with (_x) _y',                          'with (E[_x]) S[_y]').

           tmacro('for (_x) _y',                           'for (S[_x]) S[_y]').
           tmacro('for (_x; _y; _z) _body',                'for (S[_x]; E[_y]; E[_z]) S[_body]').
           tmacro('while (_x) y',                          'while (E[_x]) S[_y]').
           tmacro('do _x; while (_y)',                     'do S[_x]; while (E[_y])').
           tmacro('do {_x} while (_y)',                    'do {S[_x]} while (E[_y])').

           tmacro('try {_x} catch (_e) {_y}',              'try {S[_x]} catch (_e) {S[_y]}').
           tmacro('try {_x} catch (_e) {_y} finally {_z}', 'try {S[_x]} catch (_e) {S[_y]}').

           tmacro('return _x',                             'return E[_x]').
           tmacro('return',                                'return').
           tmacro('throw _x',                              'throw E[_x]').
           tmacro('break _label',                          'break _label').
           tmacro('break',                                 'break').
           tmacro('continue _label',                       'continue _label').
           tmacro('continue',                              'continue').
           tmacro('_label: _stuff',                        '_label: S[_stuff]')})),

    where[self                                                 = this,
          qw(s)                                                = s.split(/\s+/),

          expand_traces_in(tree)                               = 

          before_hook(tree)                                    = self.before_trace(tree),
          after_hook(tree, value)                              = self.after_trace(tree, value) -returning- value,
          after_method_hook(tree, object, method, parameters)  = self.before_trace(tree[0]) -then- self.after_trace(tree[0], resolved) -then-
                                                                 self.after_trace(tree, resolved.apply(object, parameters)) -where[resolved = object[method]],

          before_hook_ref                                      = new this.ref(before_hook),
          after_hook_ref                                       = new this.ref(after_hook),
          after_method_hook_ref                                = new this.ref(after_method_hook),

          expression_hook_template                             = qs[_before_hook(_tree, _index), _after_hook(_tree, _index, _expression)].as('('),
          expression_hook(tree, index)                         = expression_hook_template.replace({_before_hook: before_hook, _after_hook: after_hook, _tree: new self.ref(tree),
                                                                                                   _index: index.toString(), _expression: tree}),

          indirect_method_hook_template                        = qs[_before_hook(_tree, _index), _after_hook(_tree, _index, _object, _method, [_parameters])].as('('),
          quote_method_name(method)                            = '"#{method.data.replace(/"/g, "\\\"")}"',

          method_hook(tree, index, object, method, parameters) = indirect_method_hook_template.replace({_before_hook: this.before_method_hook, _after_hook: this.after_method_hook,
                                                                                                        _tree: new this.ref(tree), _index: index.toString(), _object: object, _method: method,
                                                                                                        _parameters: parameters}),

          direct_method_hook(tree, index, match)               = method_hook(tree, index, match._object, quote_method_name(match._method), match._parameters),
          indirect_method_hook(tree, index, match)             = method_hook(tree, index, match._object, match._method, match._parameters)]})));
// Generated by SDoc 
