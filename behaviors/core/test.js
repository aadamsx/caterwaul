// Unit/integration testing behavior | Spencer Tipping
// Licensed under the terms of the MIT source code license

// Introduction.
// This behavior provides words that are useful for unit testing. It also creates functions on caterwaul to define and handle unit tests. For example, using the unit testing library you can do
// stuff like this:

// | var t = caterwaul.test('string', function () {
//     'foo'.length.should.be(3);
//     'foo'.charAt(0).should.be('f');
//     'bar'.charAt(0).should.be('f');       // failing assertion
//     // etc
//   });

// The key here is the introduction of the 'should' postfix modifier, which builds a wrapper around both the value and the syntax that generated it. Test cases are automatically traced so that
// you can ask for a list of recently evaluated expressions:

// | t.failed()    // -> true
//   t.log()       // -> [{time: 1303480366440, tree: qs[...], value: v}, ...]

// You can then interactively inspect these if you're running your tests in a REPL environment. You can also change stuff and rerun a test:

// | t.run()       // clears previous state and tries again

// Functions passed to the test() method are customized by the caterwaul's test_transform function, which is a caterwaul instance customized for unit testing. By default it's configured with
// core.js and core.test, but doesn't have much in the way of standard-library features. You can change this by configuring it, or by cloning your caterwaul and configuring the clone's
// test_transform function.

// Assertions.
// The 'should' word is implemented by a modifier macro that creates an instance of caterwaul.test.should_wrapper. 

  caterwaul.tconfiguration('core.js core.words', 'core.test', function () {


    this.event ('test_defined', 'test_passed', 'test_failed'),
    this.method('test', given[name, f] in this.test_transform(f) -effect[this.merge(it, this.test_methods)] -effect[this.test_defined(name, it)])});
// Generated by SDoc 
