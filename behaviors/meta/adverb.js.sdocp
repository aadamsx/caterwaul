sdocp('sdoc::js::behaviors/meta/adverb', 'Adverbial modifier pattern | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nBefore version 1.0 most caterwaul macros were defined ad-hoc; as such the standard library felt chaotic and irregular. Caterwaul 1.0 introduces macro-patterns, which are abstractions to make\nit easier to define regular and predictable syntax macros. Starting with caterwaul 1.0, many macros are defined in terms of their meaning rather than their appearance. One of these meanings is\nan \'adverb.\'\n\nAn adverb modifies something about how an expression works. For instance, \'where\' is a common adverb used to bind local variables within an expression. \'when\' and \'unless\' determine whether an\nexpression is run. \'until\', new in caterwaul 1.0, is used to iterate an expression. These adverbs are no longer defined using qs[]. Instead, they are defined using adverb(), which takes the\nname of the adverb and a function that transforms the modified expression and any modifiers passed to the adverb.\n\nThe advantage to this separation is that later on you can establish new ways for adverbs to be used in your code. For instance, if you were writing in Coffeescript you wouldn\'t have access to\nbrackets with commas. In that case you\'d want to use a regular function, so you would say this:\n\n| my_caterwaul.adverb_form(qs[_ /_adverb(_)]);       // after this, \'x /where(x = 10)\' would be a valid way to say \'x /where[x = 10]\'\n  my_caterwaul.adverb_form(qs[_(_adverb(_))]);       // enables \'x where x = 10\', which is more Coffeescript-idiomatic\n\nAdverb forms always have the modifiers following the expression to be modified; this keeps relevant information first.\n\n  caterwaul.shallow(\'adverbs\', []).shallow(\'adverb_forms\', []).\n\n    method(\'adverb\',      function (name, definition) {for (var i = 0, l = this.adverb_forms.length; i < l; ++i) this.define_adverb(name, definition, this.adverb_forms[i]);\n                                                       return this.adverbs.push({name: name, definition: definition}), this}).\n\n    method(\'adverb_form\', function (form)             {for (var i = 0, l = this.adverbs.length; i < l; ++i) this.define_adverb(this.adverbs[i].name, this.adverbs[i].description, form);\n                                                       return this.adverb_forms.push(form), this}).\n\nAdverb macro construction.\nThis is fairly straightforward; macros are built directly from the forms.\n\n    method(\'define_adverb\', function (name, definition, form) {return this.rmacro(form.replace({_adverb: name}), definition)});');