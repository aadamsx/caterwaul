sdocp('sdoc::js::core/caterwaul.macroexpander.jit', 'JIT macroexpander.\nThis macroexpander examines the syntax trees used as macro patterns, constructs a breadth-first decision tree, and JITs a custom macroexpander function for those trees. Because this is a\nfairly tine-consuming operation the process is memoized in the macro list.\n\nAt first I was using a context-free probabilistic model to optimize the order of decisions, but this requires knowing something about the syntax tree -- which means that each macroexpand()\ncall involves generating a new function. This proved to be very expensive (worse than naive macroexpansion!), so I\'m going with a model that can be used without knowing anything about the\nsyntax trees being transformed.\n\nFor history\'s sake I\'ve left some of the theoretical notes involving probability, but in practice we don\'t know what the probability will be when we\'re building the decision tree.\n\n  var jit_macroexpander = (function () {\n\n  Irrelevance of discrimination.\n  Suppose you have two macro trees, each with the same form (i.e. same arity of each node and same wildcard positions). I propose that the traversal order doesn\'t require any extensive\n  optimization beyond one thing: How much information is being gained per comparison? This is very different from discrimination, which was the focus of the probabilistic JIT macroexpander\n  design. Here is an example.\n\n  | (, (_) (* (where) ([] ([ (=  (_) (_))))))               <- the macro patterns\n    (, (_) (* (where) ([] ([ (== (_) (_))))))\n\n  Suppose we run into a syntax tree that starts with \',\'. The likelihood of a comma occurring anyway is P(\',\'), so we now have 1 / P(\',\') information. It doesn\'t matter that this fails to\n  discriminate between the two macro patterns. We needed to know it anyway if we were going to perform a match, and it let us jump out early if it wasn\'t there. The left-hand side of each\n  expansion tells us nothing, so we don\'t bother inspecting that yet. We instead go to the right-hand side, which we\'ll reject with probability (1 - P(\'*\')). We then follow the right-hand side\n  recursively downwards, continuing to match the non-wildcard nodes.\n\n  Once all non-wildcard nodes are matched, we will have eliminated one macro pattern or the other. (This won\'t be true if we have overlapping macro definitions, but it is in this case.) At\n  that point we will have both verified the macro pattern and reduced the macro-space as much as possible.\n\n  Heterogeneous tree forms.\n  Most of the time heterogeneity doesn\'t matter. The reason for this is that there are few variadic nodes. However, they do sometimes come up. One case is \'return\', which sometimes occurs\n  without a child. In this case we might have macro patterns like this:\n\n  | (return (foo))\n    (return)\n\n  We\'ll obviously have to compare the \'return\' first, but what happens with the subtree in the first case? The answer is that the tree length is compared when the data is. This gives us an\n  extra bailout condition. So comparing the \'return\' will eliminate one possibility or the other, since the length check will fail for one of them. So we have a nice invariant: All trees under\n  consideration will have the same shape.\n\n  This check isn\'t reflected in the traversal path construction below, but it is generated in the final pattern-matching code. It\'s also generated in the intermediate treeset object\n  representation.\n\n  Traversal path.\n  The pattern matcher uses both depth-first and breadth-first traversal of the pattern space. The idea is that each motion through the tree is fairly expensive, so we do a comparison at each\n  point. However, we can decide which branch to progress down without losing progress. For example, suppose we have this:\n\n  | (+ (* (a) (b)) (/ (a) (b)))\n\n  The first comparison to happen is +, regardless of what the rest of the tree looks like. If we don\'t bail out, then without loss of generality suppose we take the * branch. At this point we\n  have two nodes stored in local variables; one is the root + node, and the other is the child * node. The total child set is now (a), (b), and (/ (a) (b)). We take whichever one of these\n  children is most likely to bail out, which let\'s suppose is (b). Because (b) has no children, we now have (a) and (/ (a) (b)). Now suppose that / is the next lowest-probability symbol; we\n  then visit that node, producing the children (a) and (b). (b) is the lower-probability one, so we test that, leaving the total child list at (a), (a). The order of these last two comparisons\n  doesn\'t matter.\n\n  We need an intermediate representation for the path-finder decisions. The reason is that these decisions are used to both (1) partition the tree set, and (2) generate code. (2) isn\'t\n  particularly difficult using just stack-local data, but (1) ends up being tricky because of the potential for breadth-first searching. The problem is a subtle one but is demonstrated by this\n  example:\n\n  | (+ (* (/ (a) (b)) (c)) (+ (a) (b)))\n    (+ (* (* (a) (b)) (c)) (- (a) (b)))\n\n  Suppose here that we search subtree [0] first. Further, suppose that we end up progressing into subtree [0][0]. At this point we\'ll create a branch, so we have partitioned the original tree\n  space into two fragments. As such, we need to know to ask for just the probability of \'+\' or \'-\' on its own, not the sum, since we\'ll be able to bail out immediately if the wrong one is\n  present. This kind of coupling means that we need to be able to query the original trees in their entirety and from the root point. This in turn requires a logical path representation that\n  can be used to both partition trees, and to later generate code to do the same thing. (An interesting question is why we wouldn\'t use the JIT to do this for us. It would be a cool solution,\n  but I think it would also be very slow to independently compile that many functions.)\n\n  Paths are represented as strings, each of whose characters\' charCodes is an index into a subtree. The empty string refers to the root. I\'m encoding it this way so that paths can be used as\n  hash keys, which makes it very fast to determine which paths have already been looked up. Also, most macro paths will be fewer than five characters, so even on eager-consing runtimes the\n  quadratic nature of it isn\'t that bad.\n\n  Treeset partitions are returned as objects that map the arity and data to an array of trees. The arity is encoded as a single character whose charCode is the actual arity. So, for example,\n  partition_treeset() might return this object:\n\n  | {\'\\002+\': [(+ (x) (y)), (+ (x) (z))],\n     \'\\002-\': [(- (x) (y)), (- (x) (z))]}\n\n    var resolve_tree_path = function (tree,  path) {for (var i = 0, l = path.length; i < l; ++i) if (! (tree = tree[path.charCodeAt(i)])) return tree; return tree},\n        partition_treeset = function (trees, path) {for (var r = {}, i = 0, l = trees.length, t, ti; i < l; ++i)\n                                                        (t = resolve_tree_path(ti = trees[i], path)) ? (t = String.fromCharCode(t.length) + t.data) : (t = \'\'), (r[t] || (r[t] = [])).push(ti);\n                                                    return r},\n\n  Pathfinder logic.\n  For optimization\'s sake the hash of visited paths maps each path to the arity of the tree that it points to. This makes it very easy to generate adjacent paths without doing a whole bunch of\n  path resolution.\n\n  Partitioning is done by visit_path, which first partitions the tree-space along the path, and then returns new visited[] hashes along with the partitions. The visited[] hash ends up being\n  split because different partitions will have different traversal orders. In practice this means that we copy visited[] into several new hashes. The other reason we need to split visited[] is\n  that the arity of the path may be different per partition. So the result of visit_path looks like this:\n\n  | {\'aritydata\': {visited: {new_visited_hash}, trees: [...]},\n     \'aritydata\': ...}\n\n  The base case is when there is no visited history; then we return \'\' to get the process started with the root path.\n\n  As explained in \'Full specification detection\', next_path needs to skip over any paths that refer to wildcards.\n\n    next_path = function (visited, trees) {if (! visited) return \'\';\n                                           for (var k in visited) if (visited.hasOwnProperty(k)) for (var i = 0, l = visited[k], p; i < l; ++i)\n                                             if (! ((p = k + String.fromCharCode(i)) in visited)) {\n                                               for (var j = 0, lj = trees.length, skip; j < lj; ++j) if (skip = resolve_tree_path(trees[j], p).data === \'_\') break;\n                                               if (! skip) return p}},\n\n    visit_path = function (path, visited, trees) {var partitions = partition_treeset(trees, path), kv = function (k, v) {var r = {}; r[k] = v; return r};\n                                                  for (var k in partitions) if (partitions.hasOwnProperty(k))\n                                                      partitions[k] = {trees: partitions[k], visited: merge({}, visited, kv(path, k.charCodeAt(0)))};\n                                                  return partitions},\n\n  Full specification detection.\n  Sometimes no path resolves the treeset. At that point one or more trees are fully specified, so we need to find and remove those trees from the list. This will produce an array of results\n  [treeset, treeset, treeset, ...]. The property is that each treeset will contain trees that either (1) are all fully specified with respect to the set of visited paths, or (2) are all not\n  fully specified with respect to the paths. Order is also preserved from the original treeset.\n\n  Note that the first treeset always represents trees which are not fully specified, then each subsequent treeset alternates in its specification. This way you can use a shorthand such as i&1\n  to determine whether a given treeset is final. (Because of all of this, the first treeset may be empty. All other ones, if they exist, will be populated.)\n\n  This is actually a much more straightforward task than it sounds like, because the number of non-wildcard nodes for each tree is already stored in pattern_data. This means that we just need\n  to find trees for which the number of non-wildcard nodes equals the number of visited paths.\n\n  There\'s a kind of pathological case that also needs to be considered. Suppose you\'ve got a couple of macro patterns like this:\n\n  | (a (b) (_))\n    (a (_) (b))\n\n  In this case we may very well have to try both even though technically neither tree will be specified yet (and hence we don\'t think there\'s any ambiguity). The way to address this is to make\n  sure that any trees we put into an \'unspecified\' partition are all unspecified in the same place. So the two trees above would go into separate partitions, even though they\'re both\n  unspecified. Then next_path() will be able to provide a single path that increases specificity, not one that hits a wildcard.\n\n  This case can be recognized because non-wildcards will occur in different positions. A greedy algorithm will suffice; the idea is that we build a list of indexes that refer to non-wildcards\n  and intersect it with each tree we consider. If the next tree results in a zero list then we defer it to the next partition. The way I\'m doing this is finishing off the current partition,\n  inserting an empty fully-specified partition, and then kicking off a new partition of unspecified trees. This probably isn\'t the most efficient way to go about it, but the code generator\n  knows how to deal with empty partitions gracefully.\n\n    split_treeset_on_specification = function (trees, pattern_data, visited) {\n                                       var r = [], visited_count = 0, available_paths = {}, available_count = 0;\n                                       if (visited != null) {for (var k in visited) if (visited.hasOwnProperty(k)) {\n                                                              ++visited_count;\n                                                              for (var i = 0, l = visited[k]; i < l; ++i) available_paths[k + String.fromCharCode(i)] = ++available_count}}\n                                       else available_paths = {\'\': available_count = 1};\n\n                                       for (var p = [], s = false, remaining_paths = null, remaining_count = 0, i = 0, l = trees.length, t, td; i < l; ++i)\n                                         if (((td = pattern_data[(t = trees[i]).id()]).non_wildcards === visited_count) !== s) r.push(p), p = [t], s = !s, remaining_paths = null;\n                                         else if (s) p.push(t);\n                                         else {\n                                           if (remaining_paths === null) remaining_paths = merge({}, available_paths), remaining_count = available_count;\n                                           for (var ps = td.wildcard_paths, j = 0, lj = ps.length, pj; j < lj; ++j)\n                                             remaining_count -= remaining_paths.hasOwnProperty(pj = ps[j]), delete remaining_paths[pj];\n                                           if (remaining_count) p.push(t);\n                                           else                 r.push(p), r.push([]), p = [t], remaining_paths = null}\n\n                                       p.length && r.push(p);\n                                       return r},\n\n  Pattern data.\n  We end up with lots of subarrays of the original pattern list. However, we need to be able to get back to the original expander for a given pattern, so we keep a hash of pattern data indexed\n  by the ID of the pattern tree. The pattern data consists of more than just the expander; we also store the number of non-wildcard nodes per pattern tree. This is used to determine which\n  trees are fully resolved. We also need a list of wildcard paths for each tree; this is used to efficiently construct the arrays that are passed into the expander functions.\n\n  By convention I call the result of this function pattern_data, which shadows this function definition. (Seems somehow appropriate to do it this way.)\n\n    wildcard_paths = function (t) {for (var r = t.data === \'_\' ? [\'\'] : [], i = 0, l = t.length; i < l; ++i)\n                                     for (var ps = t[i] && wildcard_paths(t[i]), j = 0, lj = ps.length; j < lj; ++j) r.push(String.fromCharCode(i) + ps[j]);\n                                   return r},\n\n    pattern_data = function (ps, es) {for (var r = {}, i = 0, l = ps.length, p; i < l; ++i)\n                                        r[(p = ps[i]).id()] = {expander: es[i], non_wildcards: non_wildcard_node_count(p), wildcard_paths: wildcard_paths(p)};\n                                      return r},\n\n  Code generation.\n  This is the last step and it\'s where the algorithm finally comes together. Two big things are going on here. One is the traversal process, which uses next_path to build the piecewise\n  traversal order. The other is the code generation process, which conses up a code tree according to the treeset partitioning that guides the traversal. These two processes happen in\n  parallel.\n\n  The original JIT design goes over a lot of the code generation, but I\'m duplicating it here for clarity. (There are also some changes in this design, though the ideas are the same since\n  they\'re both fundamentally just decision trees.)\n\n    Function body.\n    This is largely uninteresting, except that it provides the base context for path dereferencing (see \'Variable allocation\' below). It also provides a temporary \'result\' variable, which is\n    used by the macroexpander invocation code.\n\n      pattern_match_function_template = parse(\'function (t) {var result; _body}\'),\n      empty_variable_mapping_table    = function () {return {\'\': \'t\'}},\n\n    Partition encoding.\n    Each time we partition the tree set, we generate a switch() statement. The switch operates both on arity and on the data, just like the partitions would suggest. (However these two things\n    are separate conditionals, unlike their representation in the partition map.) The layout looks like this:\n\n    | switch (tree.length) {\n        case 0:\n          switch (tree.data) {\n            case \'foo\': ...\n            case \'bar\': ...\n          }\n          break;\n        case 1:\n          switch (tree.data) {\n            case \'bif\': ...\n            case \'baz\': ...\n          }\n          break;\n      }\n\n    Note that we can\'t return false immediately after hitting a failing case. The reason has to do with overlapping macro definitions. If we have two macro definitions that would both\n    potentially match the input, we have to proceed to the second if the first one rejects the match.\n\n      partition_template        = parse(\'switch (_value) {_cases}\'),\n      partition_branch_template = parse(\'case _value: _body; break\'),\n\n    Attempting a macro match is kind of interesting. We need a way to use \'break\' to escape from a match, so we construct a null while loop that lets us do this. Any \'break\' will then send the\n    code into the sequential continuation, not escape from the function.\n\n      single_macro_attempt_template = parse(\'do {_body} while (false)\'),\n\n    Variable allocation.\n    Variables are allocated to hold temporary trees. This reduces the amount of dereferencing that must be done. If at any point we hit a variable that should have a value but doesn\'t, we bail\n    out of the pattern match. A table keeps track of path -> variable name mappings. The empty path always maps to \'t\', which is the input tree.\n\n    Incremental path references can be generated anytime we have a variable that is one dereference away from the given path. generate_incremental_path_reference does two things. First, it\n    creates a unique temporary name and stashes it into the path -> variable mapping, and then it returns a syntax tree that uses that unique name and existing entries in the path -> variable\n    mapping. The path\'s index is hard-coded. Note that if the path isn\'t properly adjacent you\'ll end up with an array instead of a syntax tree, and things will go downhill quickly from there.\n\n      indexed_path_reference_template  = parse(\'_base[_index]\'),\n      absolute_path_reference_template = parse(\'_base\'),\n      generate_path_reference          = function (variables, path) {\n                                           return variables[path] ? absolute_path_reference_template.replace({_base: variables[path]}) :\n                                                                    indexed_path_reference_template .replace({_base: generate_path_reference(variables, path.substr(0, path.length - 1)),\n                                                                                                              _index: \'\' + path.charCodeAt(path.length - 1)})},\n      path_variable_template = parse(\'var _temp = _value; if (! _temp) break\'),\n      path_exists_template   = parse(\'null\'),\n      generate_path_variable = function (variables, path) {if (variables[path]) return path_exists_template;\n                                                           var name = \'t\' + genint(), replacements = {_value: generate_path_reference(variables, path), _temp: name};\n                                                           return variables[path] = name, path_variable_template.replace(replacements)},\n\n    Macroexpander invocation encoding.\n    The actual macroexpander functions are invoked by embedding ref nodes in the syntax tree. If one function fails, it\'s important to continue processing with whatever assumptions have been\n    made. (This is actually one of the trickier points of this implementation.) Detecting this isn\'t too bad though. It\'s done above by split_treeset_on_specification.\n\n      non_wildcard_node_count = function (tree) {var r = 0; tree.reach(function (node) {r += node.data !== \'_\'}); return r},\n\n    Invocations of the macroexpander should be fast, so there\'s some kind of interesting logic to quickly match wildcards with a minimum of array consing. This optimization requires a\n    simplifying assumption that all _ nodes are leaf nodes, but this is generally true. (It\'s possible to build macro patterns that don\'t have this property, but they won\'t, and never would\n    have, behaved properly.) The idea is that once we have a fully-specified macro pattern we can simply go through each visited path, grab the direct children of each node, and detect\n    wildcards. We then encode these wildcard paths as hard-coded offsets from the tree variables. So, for example:\n\n    | (+ (/ (_) (b)) (* (a) (_)))\n      visited: [0], [0][1], [1], [1][0]\n      children: (_), (b), (a), (_)\n      parameters: [paths[0][0], paths[1][1]]\n\n    This requires a lexicographic sort of the paths to make sure the tree is traversed from left to right.\n\n    Note that a new array is consed per macroexpander invocation. I\'m not reusing the array from last time because (1) it\'s too much work, and (2) the fallthrough-macro case is already fairly\n    expensive and uncommon; a new array cons isn\'t going to make much difference at that point.\n\n      path_reference_array_template = parse(\'[_elements]\'),\n      generate_path_reference_array = function (variables, paths) {for (var refs = [], i = 0, l = paths.length; i < l; ++i) refs.push(generate_path_reference(variables, paths[i]));\n                                                                   return path_reference_array_template.replace({_elements: refs.length > 1 ? new syntax_node(\',\', refs) : refs[0]})},\n\n      macroexpander_invocation_template = parse(\'if (result = _expander.apply(this, _path_reference_array)) return result\'),\n      generate_macroexpander_invocation = function (pattern_data, pattern, variables) {return macroexpander_invocation_template.replace(\n                                                   {_expander:             new ref(pattern_data[pattern.id()].expander),\n                                                    _path_reference_array: generate_path_reference_array(variables, pattern_data[pattern.id()].wildcard_paths)})},\n\n    Multiple match handling.\n    When one or more macros are fully specified, we need to go through them in a particular order. Failover is handled gracefully; we just separate the macro patterns by a semicolon, since a\n    success side-effects via return and a failure\'s side-effect is its sequential continuation. (This is why we needed \'break\' instead of \'return false\' when generating case statements above.)\n\n    Here the pattern_data variable refers to a hash that maps each pattern\'s identity to some data about it, including which macroexpander belongs to the pattern in the first place. Note that\n    because I\'m using identities this way, you can\'t add the same pattern (referentially speaking) to map to two different macroexpanders. It would be a weird thing to do, so I don\'t\n    anticipate that it would happen by accident. But it will cause bogus macroexpansion results if you do.\n\n      First case: underspecified trees.\n      In this case we create a switch on the tree length first. Then we subdivide into the data comparison. We create the tree-length switch() even if only one tree matches; the reason is that\n      we still need to know that the tree we\'re matching against has the right length, even if it doesn\'t narrow down the macro space at all.\n\n        length_reference_template = parse(\'_value.length\'),\n        data_reference_template   = parse(\'_value.data\'),\n\n        generate_partitioned_switch = function (trees, visited, variables, pattern_data) {\n                                        var path = next_path(visited, trees), partitions = visit_path(path, visited, trees), lengths = {}, length_pairs = [];\n                                        for (var k in partitions) if (partitions.hasOwnProperty(k)) (lengths[k.charCodeAt(0)] || (lengths[k.charCodeAt(0)] = [])).push(k.substr(1));\n                                        for (var k in lengths)    if (lengths.hasOwnProperty(k))    length_pairs.push([k, lengths[k]]);\n\n                                        var new_variables = merge({}, variables), path_reference_variable = generate_path_variable(new_variables, path), variable = new_variables[path],\n                                            length_reference = length_reference_template.replace({_value: variable}), data_reference = data_reference_template.replace({_value: variable});\n\n                                        for (var length_cases = new syntax_node(\';\'), i = 0, l = length_pairs.length, pair; i < l; ++i) {\n                                          for (var data_cases = new syntax_node(\';\'), length = (pair = length_pairs[i])[0], values = pair[1], j = 0, lj = values.length, p, v; j < lj; ++j)\n                                            p = partitions[String.fromCharCode(length) + (v = values[j])],\n                                            data_cases.push(partition_branch_template.replace({_value: \'"\' + v.replace(/([\\\\"])/g, \'\\\\$1\') + \'"\',\n                                                                                               _body:  generate_decision_tree(p.trees, path, p.visited, new_variables, pattern_data)}));\n                                          lj &&\n                                          length_cases.push(partition_branch_template.replace({_value: \'\' + length_pairs[i][0],\n                                                                                               _body:  partition_template.replace({_value: data_reference, _cases: data_cases})}))}\n                                        return single_macro_attempt_template.replace({_body:\n                                                 new syntax_node(\';\', path_reference_variable,\n                                                                      length_cases.length ? partition_template.replace({_value: length_reference, _cases: length_cases}) : [])})},\n\n      Second case: specified trees (base case).\n      This is fairly simple. We just generate a sequence of invocations, since each tree has all of the constants assumed.\n\n        generate_unpartitioned_sequence = function (trees, variables, pattern_data) {for (var r = new syntax_node(\';\'), i = 0, l = trees.length; i < l; ++i)\n                                                                                       r.push(generate_macroexpander_invocation(pattern_data, trees[i], variables));\n                                                                                     return r},\n\n      Inductive step.\n      This is where we delegate either to the partitioned switch logic or the sequential sequence logic.\n\n        generate_decision_tree = function (trees, path, visited, variables, pattern_data) {\n                                   for (var r = new syntax_node(\';\'), sts = split_treeset_on_specification(trees, pattern_data, visited), i = 0, l = sts.length; i < l; ++i)\n                                     sts[i].length && r.push(i & 1 ? generate_unpartitioned_sequence(sts[i], variables, pattern_data) :\n                                                                     generate_partitioned_switch(sts[i], visited, variables, pattern_data));\n                                   return r};\n\n  Macroexpansion generator.\n  This is where all of the logic comes together. The only remotely weird thing we do here is reverse both the pattern and expansion lists so that the macros get applied in the right order.\n\n    return function (patterns, expanders) {for (var i = patterns.length - 1, rps = [], res = []; i >= 0; --i) rps.push(patterns[i]), res.push(expanders[i]);\n                                           return compile(pattern_match_function_template.replace(\n                                             {_body: generate_decision_tree(rps, null, null, empty_variable_mapping_table(), pattern_data(rps, res))}))}})(),\n\n  macro_expander_baked = function (t, f, context) {return t.rmap(function (n) {return f.call(context, n)})};');