// Composition behavior.
// New in 0.6.4 is the ability to compose caterwaul functions. This allows you to write distinct macroexpanders that might not be idempotent (as is the case for the Figment translator, for
// example: http://github.com/spencertipping/figment). Composition is achieved by invoking after(), which governs the behavior of the macroexpand() function. The list of functions to be invoked
// after a caterwaul function can be inspected by invoking after() with no arguments.

// | var f = caterwaul.clone(), g = caterwaul.clone();
//   f.after(g);           // Causes g to be run on f's output; that is, g is an after-effect of f.
//   f.after(h);           // Adds another after function, to be run after all of the others.
//   f.after();            // -> [g, h]

// The design for this feature is different in 0.6.5. The problem with the original design, in which after() returned a clone of the original function, was that you couldn't set up
// after-composition from within a configuration (since, reasonably enough, configuration is closed over the caterwaul instance).

// New in caterwaul 1.0 is the ability to define before-methods. Use this carefully. Also, before and after functions are now executed in the context of the caterwaul function that they are
// running on.

  caterwaul_global.class_eval(function (def) {
    this.attr_lazy('before_functions', Array).
         attr_lazy('after_functions',  Array);

    def('before', function () {return arguments.length ? this.before_functions(this.before_functions.concat(Array.prototype.slice.call(arguments))) : this.before_functions()});
    def('after',  function () {return arguments.length ? this. after_functions(this. after_functions.concat(Array.prototype.slice.call(arguments))) : this. after_functions()});

    def('apply_before_functions', function (x) {for (var xs = this.before_functions(), i = 0, l = xs.length; i < l; ++i) x = xs[i].call(this, x); return x});
    def('apply_after_functions',  function (x) {for (var xs = this.after_functions(),  i = 0, l = xs.length; i < l; ++i) x = xs[i].call(this, x); return x})});
// Generated by SDoc 
