sdocp('sdoc::js::core/caterwaul.compiler', 'Environment-dependent compilation.\nIt\'s possible to bind variables from \'here\' (i.e. this runtime environment) inside a compiled function. The way we do it is to create a closure using a gensym. (Another reason that gensyms\nmust really be unique.) Here\'s the idea. We use the Function constructor to create an outer function, bind a bunch of variables directly within that scope, and return the function we\'re\ncompiling. The variables correspond to gensyms placed in the code, so the code will have closure over those variables.\n\nAn optional second parameter \'environment\' can contain a hash of variable->value bindings. These will be defined as locals within the compiled function.\n\nNew in caterwaul 0.6.5 is the ability to specify a \'this\' binding to set the context of the expression being evaluated.\n\n  var compile = function (tree, environment) {      // Despite the coincidence of \'tree\' and \'environment\' on this line, I\'m seriously not pushing a green agenda :)\n    var vars = [], values = [], bindings = merge({}, environment || {}, tree.bindings()), s = gensym(); for (var k in bindings) if (has(bindings, k)) vars.push(k), values.push(bindings[k]);\n    var code = map(function (v) {return v === \'this\' ? \'\' : \'var \' + v + \'=\' + s + \'.\' + v}, vars).join(\';\') + \';return(\' + tree.serialize() + \')\';\n    try {return (new Function(s, code)).call(bindings[\'this\'], bindings)} catch (e) {throw new Error(\'Caught \' + e + \' while compiling \' + code)}};');