sdocp('sdoc::js::core/caterwaul.parser-data', 'Shared parser data.\nThis data is used both for parsing and for serialization, so it\'s made available to all pieces of caterwaul.\n\n  Precomputed table values.\n  The lexer uses several character lookups, which I\'ve optimized by using integer->boolean arrays. The idea is that instead of using string membership checking or a hash lookup, we use the\n  character codes and index into a numerical array. This is guaranteed to be O(1) for any sensible implementation, and is probably the fastest JS way we can do this. For space efficiency,\n  only the low 256 characters are indexed. High characters will trigger sparse arrays, which may degrade performance. (I\'m aware that the arrays are power-of-two-sized and that there are\n  enough of them, plus the right usage patterns, to cause cache line contention on most Pentium-class processors. If we are so lucky to have a Javascript JIT capable enough to have this\n  problem, I think we\'ll be OK.)\n\n  The lex_op table indicates which elements trigger regular expression mode. Elements that trigger this mode cause a following / to delimit a regular expression, whereas other elements would\n  cause a following / to indicate division. By the way, the operator ! must be in the table even though it is never used. The reason is that it is a substring of !==; without it, !== would\n  fail to parse. (See test/lex-neq-failure for examples.)\n\n   var lex_op = hash(\'. new ++ -- u++ u-- u+ u- typeof u~ u! ! * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || ? = += -= *= /= %= &= |= ^= <<= >>= >>>= : , \' +\n                     \'return throw case var const break continue void else u; ;\'),\n\n    lex_table = function (s) {for (var i = 0, xs = [false]; i < 8; ++i) xs.push.apply(xs, xs); for (var i = 0, l = s.length; i < l; ++i) xs[s.charCodeAt(i)] = true; return xs},\n    lex_float = lex_table(\'.0123456789\'),    lex_decimal = lex_table(\'0123456789\'),  lex_integer = lex_table(\'0123456789abcdefABCDEFx\'),  lex_exp = lex_table(\'eE\'),\n    lex_space = lex_table(\' \\n\\r\\t\'),        lex_bracket = lex_table(\'()[]{}\'),       lex_opener = lex_table(\'([{\'),                    lex_punct = lex_table(\'+-*/%&|^!~=<>?:;.,\'),\n      lex_eol = lex_table(\'\\n\\r\'),     lex_regexp_suffix = lex_table(\'gims\'),          lex_quote = lex_table(\'\\\'"/\'),                   lex_slash = \'/\'.charCodeAt(0),\n     lex_star = \'*\'.charCodeAt(0),              lex_back = \'\\\\\'.charCodeAt(0),             lex_x = \'x\'.charCodeAt(0),                     lex_dot = \'.\'.charCodeAt(0),\n     lex_zero = \'0\'.charCodeAt(0),     lex_postfix_unary = hash(\'++ --\'),              lex_ident = lex_table(\'$_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\'),\n\n  Parse data.\n  The lexer and parser aren\'t entirely separate, nor can they be considering the complexity of Javascript\'s grammar. The lexer ends up grouping parens and identifying block constructs such\n  as \'if\', \'for\', \'while\', and \'with\'. The parser then folds operators and ends by folding these block-level constructs.\n\n    parse_reduce_order = map(hash, [\'function\', \'( [ . [] ()\', \'new delete\', \'u++ u-- ++ -- typeof u~ u! u+ u-\', \'* / %\', \'+ -\', \'<< >> >>>\', \'< > <= >= instanceof in\', \'== != === !==\', \'&\',\n                                    \'^\', \'|\', \'&&\', \'||\', \'case\', \'?\', \'= += -= *= /= %= &= |= ^= <<= >>= >>>=\', \':\', \',\', \'return throw break continue void\', \'var const\',\n                                    \'if else try catch finally for switch with while do\', \';\']),\n\nparse_associates_right = hash(\'= += -= *= /= %= &= ^= |= <<= >>= >>>= ~ ! new typeof u+ u- -- ++ u-- u++ ? if else function try catch finally for switch case with while do\'),\n   parse_inverse_order = (function (xs) {for (var  o = {}, i = 0, l = xs.length; i < l; ++i) for (var k in xs[i]) has(xs[i], k) && (o[k] = i); return annotate_keys(o)}) (parse_reduce_order),\n   parse_index_forward = (function (rs) {for (var xs = [], i = 0, l = rs.length, _ = null; _ = rs[i], xs[i] = true, i < l; ++i)\n                                           for (var k in _) if (has(_, k) && (xs[i] = xs[i] && ! has(parse_associates_right, k))) break; return xs}) (parse_reduce_order),\n\n              parse_lr = hash(\'[] . () * / % + - << >> >>> < > <= >= instanceof in == != === !== & ^ | && || = += -= *= /= %= &= |= ^= <<= >>= >>>= , : ;\'),\n   parse_r_until_block = annotate_keys({\'function\':2, \'if\':1, \'do\':1, \'catch\':1, \'try\':1, \'for\':1, \'while\':1, \'with\':1, \'switch\':1}),\n         parse_accepts = annotate_keys({\'if\':\'else\', \'do\':\'while\', \'catch\':\'finally\', \'try\':\'catch\'}),  parse_invocation = hash(\'[] ()\'),\n      parse_r_optional = hash(\'return throw break continue else\'),              parse_r = hash(\'u+ u- u! u~ u++ u-- new typeof finally case var const void delete\'),\n           parse_block = hash(\'; {\'),  parse_invisible = hash(\'i;\'),            parse_l = hash(\'++ --\'),     parse_group = annotate_keys({\'(\':\')\', \'[\':\']\', \'{\':\'}\', \'?\':\':\'}),\n parse_ambiguous_group = hash(\'[ (\'),    parse_ternary = hash(\'?\'),   parse_not_a_value = hash(\'function if for while catch\'), parse_also_expression = hash(\'function\');');