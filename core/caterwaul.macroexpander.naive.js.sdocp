sdocp('sdoc::js::core/caterwaul.macroexpander.naive', 'Naive macroexpander implementation.\nThis is the macroexpander used in Caterwaul 0.6.x and prior. It offers reasonable performance when there are few macros, but for high-macro cases it becomes prohibitive. Version 0.7.0 and\nforward use the optimizing JIT macroexpander defined in sdoc::js::core/caterwaul.macroexpander.jit. (Note that this macroexpander is still here to reduce the amount of compilation overhead for\nsmall macroexpansions.)\n\n  Expansion.\n  Uses the straightforward brute-force algorithm to go through the source tree and expand macros. At first I tried to use indexes, but found that I couldn\'t think of a particularly good way to\n  avoid double-expansion -- that is, problems like qs[qs[foo]] -- the outer must be expanded without the inner one. Most indexing strategies would not reliably (or if reliably, not profitably)\n  index the tree in such a way as to encode containment. Perhaps at some point I\'ll find a faster macroexpander, especially if this one proves to be slow. At this point macroexpansion is by\n  far the most complex part of this system, at O(nki) where n is the number of parse tree nodes, k is the number of macros, and i is the number of nodes in the macro pattern tree. (Though in\n  practice it\'s generally not quite so bad.)\n\n  Note! This function by default does not re-macroexpand the output of macros. That is handled at a higher level by Caterwaul\'s macro definition facility (see the \'rmacro\' method).\n\n  Note that as of version 0.5, macroexpansion proceeds backwards. This means that the /last/ matching macro is used, not the first. It\'s an important feature, as it lets you write new macros\n  to override previous definitions. This ultimately lets you define sub-caterwaul functions for DSLs, and each can define a default case by matching on qs[_] (thus preventing access to other\n  macro definitions that may exist).\n\n  caterwaul_global.method(\'macro_expand_naive\', function (t, macros, expanders) {\n                           return t.rmap(function (n) {for (var i = macros.length - 1, macro, match, replacement; i >= 0 && (macro = macros[i]); --i)\n                                                         if ((match = macro_try_match(macro, n)) && (replacement = expanders[i].apply(this, match))) return replacement})});');