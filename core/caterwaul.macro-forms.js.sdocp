sdocp('sdoc::js::core/caterwaul.macro-forms', 'Macro forms.\nBefore version 1.0 most caterwaul macros were defined ad-hoc; as such the standard library felt chaotic and irregular. Caterwaul 1.0 introduces macro-patterns, which are abstractions to make\nit easier to define regular and predictable syntax macros. Starting with caterwaul 1.0, many macros are defined in terms of their meaning rather than their appearance. One of these meanings is\nan \'adverb.\'\n\nAn adverb modifies something about how an expression works. For instance, \'where\' is a common adverb used to bind local variables within an expression. \'when\' and \'unless\' determine whether an\nexpression is run. \'until\', new in caterwaul 1.0, is used to iterate an expression. These adverbs are no longer defined using qs[]. Instead, they are defined using adverb(), which takes the\nname of the adverb and a function that transforms the modified expression and any modifiers passed to the adverb.\n\nThe advantage to this separation is that later on you can establish new ways for adverbs to be used in your code. For instance, if you were writing in Coffeescript you wouldn\'t have access to\nbrackets with commas. In that case you\'d want to use a regular function, so you would say this:\n\n| my_caterwaul.adverb_form(qs[_ /_adverb(_)]);       // after this, \'x /where(x = 10)\' would be a valid way to say \'x /where[x = 10]\'\n  my_caterwaul.adverb_form(qs[_(_adverb(_))]);       // enables \'x where x = 10\', which is more Coffeescript-idiomatic\n\nAdverb forms always have the modifiers following the expression to be modified; this keeps relevant information first.\n\n  Defining a macro form.\n  You can define a new macro form using caterwaul\'s macro_form() method. This takes the name of the form to define and a function that accepts a name, definition, and form and performs the\n  actual macro definition. For example, this is how you might define adverbs as described above:\n\n  | caterwaul.macro_form(\'adverb\', function (name, definition, form) {\n      this.rmacro(form.replace({_adverb: name}), definition);\n    });\n\n  The function you give it will be invoked for each new adverb or adverb form. This function is also bound as a method called \'define_adverb\'.\n\n  caterwaul_global.\n    method(\'macro_form\', function () {for (var i = 0, l = arguments.length - 1; i < l; ++i) this.define_macro_form(arguments[i], arguments[l]); return this}).\n    method(\'define_macro_form\', function (name, define) {\n      var names = name + \'s\', form = name + \'_form\', forms = name + \'_forms\', define_name = \'define_\' + name;\n\n      return this.\n        shallow(names, []).\n         method(name, function (name, definition) {for (var i = 0, fs = this[forms], l = fs.length, d = this[define_name]; i < l; ++i) d.call(this, name, definition, fs[i]);\n                                                   return this[names].push({name: name, definition: definition}), this}).\n        shallow(forms, []).\n         method(form, function (form)             {form = this.ensure_syntax(form);\n                                                   for (var i = 0, xs = this[names], l = xs.length, d = this[define_name]; i < l; ++i) d.call(this, xs[i].name, xs[i].description, form);\n                                                   return this[forms].push(form), this}).\n\n         method(define_name, function () {return define.apply(this, arguments), this})});');