// Profiling extensions for performance tuning | Spencer Tipping
// Licensed under the terms of the MIT source code license

var all_profiled_functions = {};
var recursion              = {};
Function.prototype.profiled = function (name, no_recursion) {
  var f = this;
  recursion[name] || (recursion[name] = no_recursion ? NaN : 0);
  return function () {
    var k = name + ' (' + ++recursion[name] + ')';
    var data = all_profiled_functions[k] || (all_profiled_functions[k] = {invocations: 0, total: 0, max: 0});
    var t1 = +new Date();
    var result = f.apply(this, arguments);
    var time = +new Date() - t1;

    ++data.invocations;
    data.total += time;
    if (recursion[name] > 1) all_profiled_functions[name + ' (' + (recursion[name] - 1) + ')'].total -= time;
    time > data.max && (data.max = time);
    --recursion[name];
    return result;
  };
};

setTimeout(function () {
  var fs = [];
  for (var k in all_profiled_functions) all_profiled_functions[k].average = (all_profiled_functions[k].total / all_profiled_functions[k].invocations).toFixed(3),
                                        all_profiled_functions[k].name = k,
                                        fs.push(all_profiled_functions[k]);

  fs.sort(function (x, y) {return x.total - y.total});
  console.log(fs);
}, 0);
// Generated by SDoc 
