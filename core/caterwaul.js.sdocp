sdocp('sdoc::js::core/caterwaul', 'Caterwaul JS | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\n(function (f) {return f(f)}) (function (self, undefined) {\n\nIntroduction.\nCaterwaul implements a very small Lisp in Javascript syntax. The syntax ends up looking much more like McCarthy\'s M-expressions than traditional S-expressions, due to the ease of embedding\nthose in a JS-compatible grammar. Also, Javascript convention makes square-bracket calls such as qs[foo] relatively uncommon, so I\'m using that as the macro syntax (though of course you can\ndefine macros with other forms as well).\n\nThe most important thing Caterwaul does is provide a quotation operator. For example:\n\n| caterwaul.clone(\'std\')(function () {\n    return qs[x + 1];\n  });\n\nThis function returns a syntax tree representing the expression \'x + 1\'. Caterwaul also includes macro-definition and quasiquoting (not quite like Lisp, though I imagine you could write a\nmacro for that):\n\n| caterwaul.configure(\'std\')(function () {\n    caterwaul.macro(qs[let (_ = _) in _], function (variable, value, expression) {\n      return qs[(function (variable) {return expression}).call(this, value)].replace({variable: variable, expression: expression, value: value});\n    });\n    // Macro usable in future caterwaul()ed functions\n  });\n\nOr, more concisely (since macro definitions can be used inside other macro definitions when you define with rmacro):\n\n| var f = caterwaul.configure(\'std\')(function () {\n    caterwaul.rmacro(qs[let (_ = _) in _], fn[variable, value, expression]\n                                             [qs[(fn[variable][expression]).call(this, value)].replace({variable: variable, expression: expression, value: value})]);\n  });\n\nNote that \'caterwaul\' inside a transformed function refers to the transforming function, not to the global Caterwaul function.\n\nSee the \'Macroexpansion\' section some distance below for more information about defining macros.\n\n  Coding style.\n  I like to code using syntactic minimalism, and since this project is a hobby instead of work I\'ve run with that style completely. This has some advantages and some disadvantages. Advantages\n  include (1) a very small gzipped/minified footprint (especially since these comments make up most of the file), (2) few lines of code, though they are very long, and (3) lots of semantic\n  factoring that should make modification relatively simple. Disadvantages are (1) completely impenetrable logic (especially without the comments) and (2) possibly suboptimal performance in\n  the small scale (depending on whether your JS interpreter is optimized for statements or expressions).\n\n  There are a couple of things worth knowing about as you\'re reading through this code. One is that invariants are generally coded as such; for example, the \'own\' property lookup is factored\n  out of the \'has\' function even though it would be trivial to write it inside. This is to indicate to Javascript that Object.prototype.hasOwnProperty is relatively invariant, and that saves\n  some lookups as the code is running. Another is that I use the (function (variable) {return expression})(value) form to emulate let-bindings. (Reading the code with this in mind will make it\n  much more obvious what\'s going on.)\n\n  Global management.\n  Caterwaul creates a global symbol, caterwaul. Like jQuery, there\'s a mechanism to get the original one back if you don\'t want to replace it. You can call caterwaul.deglobalize() to return\n  caterwaul and restore the global that was there when Caterwaul was loaded (might be useful in the unlikely event that someone else named their library Caterwaul). Note that deglobalize() is\n  available only on the global caterwaul() function. It wouldn\'t make much sense for clones to inherit it.\n\n  var _caterwaul = typeof caterwaul === \'undefined\' ? undefined : caterwaul;\n\n- pinclude pp::js::core/caterwaul.utilities\n- pinclude pp::js::core/caterwaul.tree\n- pinclude pp::js::core/caterwaul.parser\n- pinclude pp::js::core/caterwaul.compiler\n- pinclude pp::js::core/caterwaul.macroexpander\n- pinclude pp::js::core/caterwaul.configuration\n- pinclude pp::js::core/caterwaul.behaviors\n\n  var caterwaul_global = caterwaul = caterwaul_core(merge(replica(), {deglobalize: function () {caterwaul = _caterwaul; return this}}));\n  return caterwaul_global});');