sdocp('sdoc::js::core/caterwaul.composition', 'Composition behavior.\nNew in 0.6.4 is the ability to compose caterwaul functions. This allows you to write distinct macroexpanders that might not be idempotent (as is the case for the Figment translator, for\nexample: http://github.com/spencertipping/figment). Composition is achieved by invoking after(), which governs the behavior of the macroexpand() function. The list of functions to be invoked\nafter a caterwaul function can be inspected by invoking after() with no arguments.\n\n| var f = caterwaul.clone(), g = caterwaul.clone();\n  f.after(g);           // Causes g to be run on f\'s output; that is, g is an after-effect of f.\n  f.after(h);           // Adds another after function, to be run after all of the others.\n  f.after();            // -> [g, h]\n\nThe design for this feature is different in 0.6.5. The problem with the original design, in which after() returned a clone of the original function, was that you couldn\'t set up\nafter-composition from within a configuration (since, reasonably enough, configuration is closed over the caterwaul instance).\n\nThere is deliberately no before() method. The reason for this is that when you define a macro on a caterwaul function, it should take precedence over all other macros that get run. Obviously\nthis doesn\'t happen for g if g comes after f, but generally that relationship is obvious from the setup code (which it might not be if a before() method could be invoked by configurations).\n\n  caterwaul_global.shallow(\'after_functions\', []).\n                    method(\'after\', function () {if (arguments.length) {for (var i = 0, l = arguments.length; i < l; ++i) this.after_functions.push(arguments[i]); return this}\n                                                 else                  return this.after_functions});');