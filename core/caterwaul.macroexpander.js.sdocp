sdocp('sdoc::js::core/caterwaul.macroexpander', 'Macroexpansion.\nCaterwaul is a Lisp, which in this case means that it provides the ability to transform code before that code is compiled. Lisp does macroexpansion inline; that is, as the code is being read\n(or compiled -- there are several stages I believe). Caterwaul provides offline macros instead; that is, you define them separately from their use. This gives Caterwaul some opportunity to\noptimize macro-rewriting.\n\nDefining offline macros is done in the normal execution path. For example:\n\n| caterwaul(function () {\n    caterwaul.rmacro(qs[let (_ = _) in _], fn[n, v, e][qs[fn[args][body].call(this, values)].replace({args: n, body: e, values: v})]);\n  }) ();        // Must invoke the function\n\n| // Macro is usable in this function:\n  caterwaul(function () {\n    let (x = 5) in console.log(x);\n  });\n\nWrapping the first function in caterwaul() wasn\'t necessary, though it was helpful to get the qs[] and fn[] shorthands. In this case, the macro is persistent to the caterwaul function that it\nwas called on. (So any future caterwaul()ed functions would have access to it.) You can also define conditional macros, though they will probably be slower. For example:\n\n| caterwaul(function () {\n    caterwaul.rmacro(qs[let (_) in _], fn[bs, e][bs.data === \'=\' && ...]);\n  }) ();\n\nHere, returning a falsy value indicates that nothing should be changed about this syntax tree. It is replaced by itself and processing continues normally. You should try to express things in\nterms of patterns; there are theoretical optimizations that can cut the average-case runtime of pattern matching to a fraction of a full linear scan. The worst possible case is when you match\non a universal pattern and restrict later:\n\n| caterwaul(function () {\n    caterwaul.rmacro(qs[_], fn[x][...]);\n  }) ();\n\nThis will call your macroexpander once for every node in the syntax tree, which for large progams is costly. If you really do have such a variant structure, your best bet is to define separate\nmacros, one for each case:\n\n| caterwaul(function () {\n    var patterns = [qs[foo], qs[bar], qs[bif]];\n    patterns.map (function (p) {\n      caterwaul.rmacro(p, fn[x][...]);\n    });\n  }) ();\n\nCaterwaul implements several optimizations that make it much faster to macroexpand code when the macro patterns are easily identified.\n\n  (function () {\n\n  Pitfalls of macroexpansion.\n  Macroexpansion as described here can encode a lambda-calculus. The whole point of having macros is to make them capable, so I can\'t complain about that. But there are limits to how far I\'m\n  willing to go down the pattern-matching path. Let\'s suppose the existence of the let-macro, for instance:\n\n  | let (x = y) in z   ->   (function (x) {return z}) (y)\n\n  If you write these macros:\n\n  | foo[x, y]   ->   let (x = y)\n    bar[x, y]   ->   x in y\n\n  Caterwaul is not required to expand bar[foo[x, y], z] into (function (x) {return z}) (y). It might just leave it at let (x = y) in z instead. The reason is that while the individual\n  macroexpansion outputs are macroexpanded, a fixed point is not run on macroexpansion in general. (That would require multiple-indexing, which in my opinion isn\'t worth the cost.) To get the\n  extra macroexpansion you would have to wrap the whole expression in another macro, in this case called \'expand\':\n\n  | caterwaul.configure(function () {\n      this.rmacro(expand[_], fn[expression][caterwaul.macroexpand(expression)]);\n    });\n\n  This is an eager macro; by outputting the already-expanded contents, it gets another free pass through the macroexpander.\n\n  Things that are not guaranteed:\n\n  | 1. Reassembly of different pieces (see above).\n    2. Anything at all, if you modify the syntax tree in the macro code. Returning a replacement is one thing, but modifying one will break things.\n    3. Performance bounds.\n\n  Matching.\n  macro_try_match returns null if two syntax trees don\'t match, or a possibly empty array of wildcards if the given tree matches the pattern. Wildcards are indicated by \'_\' nodes, as\n  illustrated in the macro definition examples earlier in this section. Note that this function is O(n) in the number of nodes in the pattern. It is optimized, though, to reject invalid nodes\n  quickly -- that is, if there is any mismatch in arity or data.\n\n    caterwaul_global.method(\'macro_try_match\', function (pattern, t) {if (pattern.data === \'_\')                                   return [t];\n                                                                      if (pattern.data !== t.data || pattern.length !== t.length) return null;\n                                                                      for (var i = 0, l = pattern.length, wildcards = [], match = null; i < l; ++i)\n                                                                        if (match = macro_try_match(pattern[i], t[i])) Array.prototype.push.apply(wildcards, match);\n                                                                        else                                           return null;\n                                                                      return wildcards});\n\nMacroexpansion behavior.\nCaterwaul exposes macroexpansion as a contained interface. This lets you write your own compilers with macroexpansion functionality, even if the syntax trees weren\'t created by Caterwaul.\n(Though you won\'t be able to precompile these.) In order for this to work, your syntax trees must:\n\n| 1. Look like arrays -- that is, have a .length property and be indexable by number (e.g. x[0], x[1], ..., x[x.length - 1])\n  2. Implement an rmap() method. This should perform a depth-first traversal of the syntax tree, invoking a callback function on each node. If the callback returns a value, that value should\n     be subsituted for the node passed in and traversal should continue on the next node (not the one that was grafted in). Otherwise traversal should descend into the unmodified node. The\n     rmap() method defined for Caterwaul syntax trees can be used as a reference implementation. (It\'s fairly straightforward.)\n  3. Implement a .data property. This represents an equivalence class for syntax nodes under ===. Right now there is no support for using other equivalence relations.\n\nAs of version 0.7.0 this compatibility may change without notice. The reason is that the macroexpansion logic used by Caterwaul is becoming more sophisticated to increase performance, which\nmeans that it may become arbitrarily optimized.\n\n  Macro vs. rmacro.\n  macro() defines a macro whose expansion is left alone. rmacro(), on the other hand, will macroexpand the expansion, letting you emit macro-forms such as fn[][]. Most of the time you will\n  want to use rmacro(), but if you want to have a literal[] macro, for instance, you would use macro():\n\n  | caterwaul.configure(function () {\n      // Using macro() instead of rmacro(), so no further expansion:\n      this.macro(qs[literal[_]], fn[x][x]);\n    });\n\n  While macro() is marginally faster than rmacro(), the difference isn\'t significant in most cases.\n\n  New in caterwaul 1.0 is the ability to specify multiple macro patterns that share an expander by passing more than two arguments to macro() and rmacro().\n\n    var variadic_definition = function (f) {return function () {for (var i = 0, l = arguments.length - 1; i < l; ++i) f.call(this, arguments[i], arguments[l]); return this}};\n\n    caterwaul_global.shallow(\'macro_patterns\', []).\n                     shallow(\'macro_expanders\', []).\n\n          method_until_baked(\'macro\',  variadic_definition(function (pattern, expander) {if (! expander.apply) throw new Error(\'macro: cannot define macro with non-function expander\');\n                                                                                         else return this.macro_patterns.push(pattern), this.macro_expanders.push(expander), this})).\n\n          method_until_baked(\'rmacro\', variadic_definition(function (pattern, expander) {if (! expander.apply) throw new Error(\'rmacro: cannot define macro with non-function expander\');\n                                                                                         else return this.macro(pattern, function () {var t = expander.apply(this, arguments);\n                                                                                                                                      return t && this.macroexpand(t)})})).\n                      method(\'macroexpand\', function (t) {return macro_expand_naive(t, this.macro_patterns, this.macro_expanders, this)}).\n                  when_baked(function () {var f = this.create_baked_macroexpander(this.macro_patterns, this.macro_expanders);\n                                          this.method(\'macroexpand\', function (t) {return t.rmap(function (n) {return f.call(this, n)})})})})();');