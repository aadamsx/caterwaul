sdocp('sdoc::js::core/caterwaul.tree', 'Syntax data structures.\nThere are two data structures used for syntax trees. At first, paren-groups are linked into doubly-linked lists, described below. These are then folded into immutable array-based specific\nnodes. At the end of folding there is only one child per paren-group.\n\n  (function () {\n\n  Doubly-linked paren-group lists.\n  When the token stream is grouped into paren groups it has a hierarchical linked structure that conceptually has these pointers:\n\n  |                       +--------+\n                 +------  |  node  |  ------+\n                 |   +->  |        |  <--+  |\n          first  |   |    +--------+     |  |  last\n                 |   | parent     parent |  |\n                 V   |                   |  V\n              +--------+               +--------+\n              |  node  |   --- r -->   |  node  |  --- r ---/\n   /--- l --- |        |   <-- l ---   |        |\n              +--------+               +--------+\n\n  The primary operation performed on this tree, at least initially, is repeated folding. So we have a chain of linear nodes, and one by one certain nodes fold their siblings underneath them,\n  breaking the children\'s links and linking instead to the siblings\' neighbors. For example, if we fold node (3) as a binary operator:\n\n  |     (1) <-> (2) <-> (3) <-> (4) <-> (5)             (1) <--> (3) <--> (5)\n        / \\     / \\     / \\     / \\     / \\     -->     / \\     /   \\     / \\\n                                                               /     \\\n                                                             (2)     (4)        <- No link between children\n                                                             / \\     / \\           (see \'Fold nodes\', below)\n\n  Fold nodes.\n  Once a node has been folded (e.g. (3) in the diagram above), none of its children will change and it will gain no more children. The fact that none of its children will change can be shown\n  inductively: suppose you\'ve decided to fold the \'+\' in \'x + y\' (here x and y are arbitrary expressions). This means that x and y are comprised of higher-precedence operators. Since there is\n  no second pass back to high-precedence operators, x and y will not change nor will they interact with one another. The fact that a folded node never gains more children arrives from the fact\n  that it is folded only once; this is by virtue of folding by index instead of by tree structure. (Though a good tree traversal algorithm also wouldn\'t hit the same node twice -- it\'s just\n  less obvious when the tree is changing.)\n\n  Anyway, the important thing about fold nodes is that their children don\'t change. This means that an array is a completely reasonable data structure to use for the children; it certainly\n  makes the structure simpler. It also means that the only new links that must be added to nodes as they are folded are links to new children (via the array), and links to the new siblings.\n  Once we have the array-form of fold nodes, we can build a query interface similar to jQuery, but designed for syntactic traversal. This will make routine operations such as macro\n  transformation and quasiquoting far simpler later on.\n\n  Both grouping and fold nodes are represented by the same data structure. In the case of grouping, the \'first\' pointer is encoded as [0] -- that is, the first array element. It doesn\'t\n  contain pointers to siblings of [0]; these are still accessed by their \'l\' and \'r\' pointers. As the structure is folded, the number of children of each paren group should be reduced to just\n  one. At this point the remaining element\'s \'l\' and \'r\' pointers will both be null, which means that it is in hierarchical form instead of linked form.\n\n  After the tree has been fully generated and we have the root node, we have no further use for the parent pointers. This means that we can use subtree sharing to save memory. Once we\'re past\n  the fold stage, push() should be used instead of append(). append() works in a bidirectionally-linked tree context (much like the HTML DOM), whereas push() works like it does for arrays\n  (i.e. no parent pointer).\n\n    var syntax_node_inspect = function (x) {return x ? x.inspect() : \'(<>)\'},  syntax_node_tostring = function (x) {return x ? x.serialize ? x.serialize() : x.toString() : \'\'},\n\n  Syntax node functions.\n  These functions are common to various pieces of syntax nodes. Not all of them will always make sense, but the prototypes of the constructors can be modified independently later on if it\n  turns out to be an issue.\n\n    syntax_structure_common = {\n\n    Mutability.\n    These functions let you modify nodes in-place. They\'re used during syntax folding and shouldn\'t really be used after that (hence the underscores).\n\n       _replace: function (n) {return (n.l = this.l) && (this.l.r = n), (n.r = this.r) && (this.r.l = n), this},  _append_to: function (n) {return n && n._append(this), this},\n      _reparent: function (n) {return this.p && this.p[0] === this && (this.p[0] = n), this},  _fold_l: function (n) {return this._append(this.l && this.l._unlink(this))},\n        _append: function (n) {return (this[this.length++] = n) && (n.p = this), this},        _fold_r: function (n) {return this._append(this.r && this.r._unlink(this))},\n       _sibling: function (n) {return n.p = this.p, (this.r = n).l = this},                                                            _fold_lr: function () {return this._fold_l()._fold_r()},\n          _wrap: function (n) {return n.p = this._replace(n).p, this._reparent(n), delete this.l, delete this.r, this._append_to(n)},  _fold_rr: function () {return this._fold_r()._fold_r()},\n        _unlink: function (n) {return this.l && (this.l.r = this.r), this.r && (this.r.l = this.l), delete this.l, delete this.r, this._reparent(n)},\n\n    These methods are OK for use after the syntax folding stage is over (though because syntax nodes are shared it\'s generally dangerous to go modifying them):\n\n            pop: function () {return --this.length, this},  push: function (x) {return this[this.length++] = x, this},\n\n    Identification.\n    You can request that a syntax node identify itself, in which case it will give you an identifier if it hasn\'t already. The identity is not determined until the first time it is requested,\n    and after that it is stable. As of Caterwaul 0.7.0 the mechanism works differently (i.e. isn\'t borked) in that it replaces the prototype definition with an instance-specific closure the\n    first time it gets called. This may reduce the number of decisions in the case that the node\'s ID has already been computed.\n\n      id: function () {var id = genint(); return (this.id = function () {return id})()},\n\n    Traversal functions.\n    each() is the usual side-effecting shallow traversal that returns \'this\'. map() distributes a function over a node\'s children and returns the array of results, also as usual. Two variants,\n    reach and rmap, perform the process recursively. reach is non-consing; it returns the original as a reference. rmap, on the other hand, follows some rules to cons a new tree. If the\n    function passed to rmap() returns the node verbatim then its children are traversed. If it returns a distinct node, however, then traversal doesn\'t descend into the children of the newly\n    returned tree but rather continues as if the original node had been a leaf. For example:\n\n    |           parent          Let\'s suppose that a function f() has these mappings:\n               /      \\\n           node1      node2       f(parent) = parent   f(node1) = q\n           /   \\        |                              f(node2) = node2\n         c1     c2      c3\n\n    In this example, f() would be called on parent, node1, node2, and c3 in that order. c1 and c2 are omitted because node1 was replaced by q -- and there is hardly any point in going through\n    the replaced node\'s previous children. (Nor is there much point in forcibly iterating over the new node\'s children, since presumably they are already processed.) If a mapping function\n    returns something falsy, it will have exactly the same effect as returning the node without modification.\n\n    Using the old s() to do gensym-safe replacement requires that you invoke it only once, and this means that for complex macroexpansion you\'ll have a long array of values. This isn\'t ideal,\n    so syntax trees provide a replace() function that handles replacement more gracefully:\n\n    | qs[(foo(_foo), _before_bar + bar(_bar))].replace({_foo: qs[x], _before_bar: qs[3 + 5], _bar: qs[foo.bar]})\n\n    There is a map() variant called nmap() (and a corresponding rnmap()) that lets you insert falsy nodes into the syntax tree. This is used by replace(), which lets you replace named nodes\n    with falsy things if you want them to go away. (The exact behavior is that falsy nodes are not added to the syntax tree at all, rather than remaining in their original state.)\n\n      each: function (f) {for (var i = 0, l = this.length; i < l; ++i) f(this[i], i); return this},\n       map: function (f) {for (var n = new this.constructor(this), i = 0, l = this.length;    i < l; ++i) n.push(f(this[i], i) || this[i]); return n},\n      nmap: function (f) {for (var n = new this.constructor(this), i = 0, l = this.length, r; i < l; ++i) (r = f(this[i], i)) && n.push(r); return n},\n     reach: function (f) {f(this); this.each(function (n) {n && n.reach(f)}); return this},\n      rmap: function (f) {var r = f(this); return ! r || r === this ? this. map(function (n) {return n && n. rmap(f)}) :      r.data === undefined ? new this.constructor(r) : r},\n     rnmap: function (f) {var r = f(this); return        r === this ? this.nmap(function (n) {return n && n.rnmap(f)}) : r && r.data === undefined ? new this.constructor(r) : r},\n\n     clone: function () {return this.rmap(function () {return false})},\n\n   collect: function (p)  {var ns = []; this.reach(function (n) {p(n) && ns.push(n)}); return ns},\n   replace: function (rs) {return this.rnmap(function (n) {return own.call(rs, n.data) ? rs[n.data] : n})},\n\n    Alteration.\n    These functions let you make "changes" to a node by returning a modified copy.\n\n      repopulated_with: function (xs)   {return new this.constructor(this.data, xs)},\n                change: function (i, x) {return se(new this.constructor(this.data, Array.prototype.slice.call(this)), function (n) {n[i] = x})},\n        compose_single: function (i, f) {return this.change(i, f(this[i]))},\n\n    General-purpose traversal.\n    This is a SAX-style traversal model, useful for analytical or scope-oriented tree traversal. You specify a callback function that is invoked in pre-post-order on the tree (you get events\n    for entering and exiting each node, including leaves). Each time a node is entered, the callback is invoked with an object of the form {entering: node}, where \'node\' is the syntax node\n    being entered. Each time a node is left, the callback is invoked with an object of the form {exiting: node}. The return value of the function is not used. Any null nodes are not traversed,\n    since they would fail any standard truthiness tests for \'entering\' or \'exiting\'.\n\n    I used to have a method to perform scope-annotated traversal, but I removed it for two reasons. First, I had no use for it (and no tests, so I had no reason to believe that it worked).\n    Second, Caterwaul is too low-level to need such a method. That would be more appropriate for an analysis extension.\n\n      traverse: function (f) {f({entering: this}); f({exiting: this.each(function (n) {n && n.traverse(f)})}); return this},\n\n    Structural transformation.\n    Having nested syntax trees can be troublesome. For example, suppose you\'re writing a macro that needs a comma-separated list of terms. It\'s a lot of work to dig through the comma nodes,\n    each of which is binary. Javascript is better suited to using a single comma node with an arbitrary number of children. (This also helps with the syntax tree API -- we can use .map() and\n    .each() much more effectively.) Any binary operator can be transformed this way, and that is exactly what the flatten() method does. (flatten() returns a new tree; it doesn\'t modify the\n    original.)\n\n    The tree flattening operation looks like this for a left-associative binary operator:\n\n    |        (+)\n            /   \\              (+)\n         (+)     z     ->     / | \\\n        /   \\                x  y  z\n       x     y\n\n    This flatten() method returns the nodes along the chain of associativity, always from left to right. It is shallow, since generally you only need a localized flat tree. That is, it doesn\'t\n    descend into the nodes beyond the one specified by the flatten() call. It takes an optional parameter indicating the operator to flatten over; if the operator in the tree differs, then the\n    original node is wrapped in a unary node of the specified operator. The transformation looks like this:\n\n    |                                  (,)\n           (+)                          |\n          /   \\   .flatten(\',\')  ->    (+)\n         x     y                      /   \\\n                                     x     y\n\n    Because \',\' is a binary operator, a \',\' tree with just one operand will be serialized exactly as its lone operand would be. This means that plurality over a binary operator such as comma\n    or semicolon degrades gracefully for the unary case (this sentence makes more sense in the context of macro definitions; see in particular \'let\' and \'where\' in std.bind).\n\n    The unflatten() method performs the inverse transformation. It doesn\'t delete a converted unary operator in the tree case, but if called on a node with more than two children it will nest\n    according to associativity.\n\n      flatten:   function (d) {d = d || this.data; return d !== this.data ? this.as(d) : ! (has(parse_lr, d) && this.length) ? this : has(parse_associates_right, d) ?\n                                                     se(new this.constructor(d), bind(function (n) {for (var i = this;     i && i.data === d; i = i[1]) n.push(i[0]); n.push(i)}, this)) :\n                                                     se(new this.constructor(d), bind(function (n) {for (var i = this, ns = []; i.data === d; i = i[0]) i[1] && ns.push(i[1]); ns.push(i);\n                                                                                                    for (i = ns.length - 1; i >= 0; --i) n.push(ns[i])}, this))},\n\n      unflatten: function  () {var right = has(parse_associates_right, this.data); return this.length <= 2 ? this : se(new this.constructor(this.data), bind(function (n) {\n                                 if (right) for (var i = 0, l = this.length - 1; i  < l; ++i) n = n.push(this[i]).push(i < l - 2 ? new this.constructor(this.data) : this[i])[1];\n                                 else       for (var i = this.length - 1;        i >= 1; --i) n = n.push(i > 1 ? new this.constructor(this.data) : this[0]).push(this[i])[0]}, this))},\n\n    Wrapping.\n    Sometimes you want your syntax tree to have a particular operator, and if it doesn\'t have that operator you want to wrap it in a node that does. Perhaps the most common case of this is\n    when you have a possibly-plural node representing a variable or expression -- often the case when you\'re dealing with argument lists -- and you want to be able to assume that it\'s wrapped\n    in a comma node. Calling node.as(\',\') will return the node if it\'s a comma, and will return a new comma node containing the original one if it isn\'t.\n\n      as: function (d) {return this.data === d ? this : new this.constructor(d).push(this)},\n\n    Type detection and retrieval.\n    These methods are used to detect the literal type of a node and to extract that value if it exists. You should use the as_x methods only once you know that the node does represent an x;\n    otherwise you will get misleading results. (For example, calling as_boolean on a non-boolean will always return false.)\n\n    Other methods are provided to tell you higher-level things about what this node does. For example, is_contextualized_invocation() tells you whether the node represents a call that can\'t be\n    eta-reduced (if it were, then the \'this\' binding would be lost).\n\n               is_string: function () {return /[\'"]/.test(this.data.charAt(0))},           as_escaped_string: function () {return this.data.substr(1, this.data.length - 2)}, \n               is_number: function () {return /^-?(0x|\\d|\\.\\d+)/.test(this.data)},                 as_number: function () {return Number(this.data)},\n              is_boolean: function () {return this.data === \'true\' || this.data === \'false\'},     as_boolean: function () {return this.data === \'true\'},\n               is_regexp: function () {return /^\\/./.test(this.data)},                     as_escaped_regexp: function () {return this.data.substring(1, this.data.lastIndexOf(\'/\'))},\n\n       has_grouped_block: function () {return has(parse_r_until_block, this.data)},                 is_block: function () {return has(parse_block, this.data)},\n    is_blockless_keyword: function () {return has(parse_r_optional, this.data)},        is_null_or_undefined: function () {return this.data === \'null\' || this.data === \'undefined\'},\n\n             is_constant: function () {return this.is_number() || this.is_string() || this.is_boolean() || this.is_regexp() || this.is_null_or_undefined()},\n          left_is_lvalue: function () {return /=$/.test(this.data) || /\\+\\+$/.test(this.data) || /--$/.test(this.data)},\n                is_empty: function () {return !this.length},                              has_parameter_list: function () {return this.data === \'function\' || this.data === \'catch\'},\n         has_lvalue_list: function () {return this.data === \'var\' || this.data === \'const\'},  is_dereference: function () {return this.data === \'.\' || this.data === \'[]\'},\n           is_invocation: function () {return this.data === \'()\'},              is_contextualized_invocation: function () {return this.is_invocation() && this[0] && this[0].is_dereference()},\n\n            is_invisible: function () {return has(parse_invisible, this.data)},           is_binary_operator: function () {return has(parse_lr, this.data)},\nis_prefix_unary_operator: function () {return has(parse_r, this.data)},            is_postfix_unary_operator: function () {return has(parse_l,  this.data)},\n       is_unary_operator: function () {return this.is_prefix_unary_operator() || this.is_postfix_unary_operator()},\n\n                 accepts: function (e) {return parse_accepts[this.data] && this.accepts[parse.data] === (e.data || e)},\n\n    Value construction.\n    Syntax nodes sometimes represent hard references to values instead of just syntax. (See \'References\' for more information.) In order to compile a syntax tree in the right environment you\n    need a mapping of symbols to these references, which is what the bindings() method returns. (It also collects references for all descendant nodes.) It takes an optional argument to\n    populate, in case you already had a hash set aside for bindings -- though it always returns the hash.\n\n    A bug in Caterwaul 0.5 and earlier failed to bind falsy values. This is no longer the case; nodes which bind values should indicate that they do so by setting a binds_a_value attribute\n    (ref nodes do this on the prototype), indicating that their value should be read from the \'value\' property. (This allows other uses of a \'value\' property while making it unambiguous\n    whether a particular node intends to bind something.)\n\n      bindings: function (hash) {var result = hash || {}; this.reach(function (n) {if (n.binds_a_value) result[n.data] = n.value}); return result},\n\n    Matching.\n    Syntax trees can use the Caterwaul match function to return a list of wildcards.\n\n         match: function (pattern) {return macro_try_match(pattern, this)},\n\n    Inspection and syntactic serialization.\n    Syntax nodes can be both inspected (producing a Lisp-like structural representation) and serialized (producing valid Javascript code). Each representation captures stray links via the \'r\'\n    pointer. In the serialized representation, it is shown as a comment /* -> */ containing the serialization of whatever is to the right. This has the property that it will break tests but\n    won\'t necessarily break code (though if it happens in the field then it\'s certainly a bug).\n\n    Block detection is required for multi-level if/else statements. Consider this code:\n\n    | if (foo) for (...) {}\n      else bif;\n\n    A naive approach (the one I was using before version 0.6) would miss the fact that the \'for\' was trailed by a block, and insert a spurious semicolon, which would break compilation:\n\n    | if (foo) for (...) {};    // <- note!\n      else bif;\n\n    What we do instead is dig through the tree and find out whether the last thing in the \'if\' case ends with a block. If so, then no semicolon is inserted; otherwise we insert one. This\n    algorithm makes serialization technically O(n^2), but nobody nests if/else blocks to such an extent that it would matter.\n\n ends_with_block: function () {var block = this[parse_r_until_block[this.data]];\n                               return this.data === \'{\' || has(parse_r_until_block, this.data) && (this.data !== \'function\' || this.length === 3) && block && block.ends_with_block()},\n\n    There\'s a hack here for single-statement if-else statements. (See \'Grab-until-block behavior\' in the parsing code below.) Basically, for various reasons the syntax tree won\'t munch the\n    semicolon and connect it to the expression, so we insert one automatically whenever the second node in an if, else, while, etc. isn\'t a block.\n\n    Update for Caterawul 0.6.6: I had removed mandatory spacing for unary prefix operators, but now it\'s back. The reason is to help out the host Javascript lexer, which can misinterpret\n    postfix increment/decrement: x + +y will be serialized as x++y, which is invalid Javascript. The fix is to introduce a space in front of the second plus: x+ +y, which is unambiguous.\n\n        toString: function ()   {return this.inspect()},\n         inspect: function ()   {return (this.l ? \'(left) <- \' : \'\') + \'(\' + this.data + (this.length ? \' \' + map(syntax_node_inspect, this).join(\' \') : \'\') + \')\' +\n                                        (this.r ? \' -> \' + this.r.inspect() : \'\')},\n\n    An improvement that could be made to serialize() is to use one big array that is then join()ed for serialization, rather than appending all of these little strings. Based on the\n    benchmarking I\'ve done, the compilation phase is fairly zippy; but if it ever ends up being a problem then I\'ll look into optimizations like this.\n\n       serialize: function (xs) {var op = this.data, space = /\\w/.test(op.charAt(op.length - 1)) ? \' \' : \'\';\n                                 return               op === \';\' ? this.length ? map(syntax_node_tostring, this).join(\';\\n\') : \';\' :\n                                        has(parse_invisible, op) ? map(syntax_node_tostring, this).join(space) :\n                                       has(parse_invocation, op) ? map(syntax_node_tostring, [this[0], op.charAt(0), this[1], op.charAt(1)]).join(space) :\n                                          has(parse_ternary, op) ? map(syntax_node_tostring, [this[0], op, this[1], parse_group[op], this[2]]).join(space) :\n                                            has(parse_group, op) ? op + map(syntax_node_tostring, this).join(space) + parse_group[op] :\n                                               has(parse_lr, op) ? this.length ? map(syntax_node_tostring, this).join(space + op + space) : op :\n                   has(parse_r, op) || has(parse_r_optional, op) ? op.replace(/^u/, \' \') + space + (this[0] ? this[0].serialize() : \'\') :\n                                    has(parse_r_until_block, op) ? has(parse_accepts, op) && this[1] && this[2] && parse_accepts[op] === this[2].data && ! this[1].ends_with_block() ?\n                                                                     op + space + map(syntax_node_tostring, [this[0], this[1], \';\\n\', this[2]]).join(\'\') :\n                                                                     op + space + map(syntax_node_tostring, this).join(\'\') :\n                                                has(parse_l, op) ? (this[0] ? this[0].serialize() : \'\') + space + op : op}};\n\n    caterwaul_global.method(\'define_syntax_structure\', function (name, ctor) {return this.field(name, extend(ctor, syntax_structure_common))}).\n                     method(\'ensure_syntax\',           function (thing)      {return thing && thing.constructor === String ? this.parse(thing) : thing}).\n                      field(\'syntax_structure_common\', syntax_structure_common).\n\n  References.\n  You can drop references into code that you\'re compiling. This is basically variable closure, but a bit more fun. For example:\n\n  | caterwaul.compile(qs[fn_[_ + 1]].replace({_: new caterwaul.ref(3)})()    // -> 4\n\n  What actually happens is that caterwaul.compile runs through the code replacing refs with gensyms, and the function is evaluated in a scope where those gensyms are bound to the values they\n  represent. This gives you the ability to use a ref even as an lvalue, since it\'s really just a variable. References are always leaves on the syntax tree, so the prototype has a length of 0.\n\n    define_syntax_structure(\'ref\', function (value) {if (value instanceof this.constructor) {this.value = value.value; this.data = value.data}\n                                                     else                                   {this.value = value;       this.data = gensym()}}, {length: 0, binds_a_value: true}).\n\n  Syntax node constructor.\n  Here\'s where we combine all of the pieces above into a single function with a large prototype. Note that the \'data\' property is converted from a variety of types; so far we support strings,\n  numbers, and booleans. Any of these can be added as children. Also, I\'m using an instanceof check rather than (.constructor ===) to allow array subclasses such as Caterwaul finite sequences\n  to be used.\n\n    define_syntax_structure(\'syntax\', function (data) {if (data instanceof this.constructor) this.data = data.data, this.length = 0;\n                                                       else {this.data = data && data.toString(); this.length = 0;\n                                                         for (var i = 1, l = arguments.length, _; _ = arguments[i], i < l; ++i)\n                                                           for (var j = 0, lj = _.length, it, itc; _ instanceof Array ? (it = _[j], j < lj) : (it = _, ! j); ++j)\n                                                             this._append((itc = it.constructor) === String || itc === Number || itc === Boolean ? new this.constructor(it) : it)}})})();');