#!/bin/bash

# Caterwaul build script | Spencer Tipping
# Licensed under the terms of the MIT source code license

# Unit testing functions.
# These helper functions are used for unit tests. Because node.js doesn't accept multiple JS files as arguments, we first concatenate the files together and then hand that to node.js. Each test
# is run separately to get an idea of what percentage of the codebase works, although it would also be semantically valid to run all of the tests together in the same environment.

  start() {
    echo starting $*
  }

  fail() {
    echo fail $* >> .test-log
    echo -e "\033[1;31mfail $*\033[0;0m:"
    return 1
  }

  pass() {
    echo pass $*
    echo pass $* >> .test-log
  }

  run-node() {
    sleep 0.1
    cat "$@" > tmp.js

    if which gjs > /dev/null; then
      start gjs $*
      gjs tmp.js || fail gjs $* || return 1
      pass gjs $*
    fi

    if which d8 > /dev/null; then
      start d8 $*
      d8 tmp.js || fail d8 $* || return 1
      pass d8 $*
    fi

    start node $*
    node tmp.js || fail node $* || return 1
    pass node $*

    rm -f tmp.js
  }

# Build phases.
# There are a few different things that happen here. First, SDoc needs to be run to update the main source, tests, and modules. This happens regardless of what we're doing. Next the minified JS
# files need to be generated. Each of these things requires little enough time that I'm willing to have them run automatically on every build (anything to avoid using a makefile!).

# Caterwaul is particular about the order in which scripts are loaded. Because that's a pain to deal with, I'm generating a precompiled file called 'caterwaul.all.js' (and a corresponding
# min.js) that loads all of the usual stuff in the right order.

  minify() {
    node lib/minify.js < $1.js > $1.min.js
  }

  generate() {
    sdoc -p . lib test modules modules/*.test

    # Production-worthy files get minified:
    minify caterwaul
    minify modules/caterwaul.std
    minify modules/caterwaul.opt
    minify modules/caterwaul.seq
    minify modules/caterwaul.format
    minify modules/caterwaul.continuation

    cat caterwaul.js modules/caterwaul.{std,opt,continuation,seq}.js > caterwaul.all.js
    minify caterwaul.all

    # Keep the test page up-to-date:
    testpage
  }

# REPL.
# Node provides a nice REPL shell. All we have to do is put in some JavaScript to enable it:

  repl() {
    generate
    echo 'require("repl").start("caterwaul> ")' > /tmp/caterwaul-repl.js
    run-node caterwaul.js modules/*.min.js /tmp/caterwaul-repl.js
  }

# Test driver.
# Unit tests are run after the code is generated. You can run the build script without running unit tests, but only for trivial things such as getting LOC counts. Unit tests are a part of the
# packaging process.

  unit() {
    generate
    rm -f .test-log
    for file in test/$1*.js modules/*.test/$1*.js; do
      [[ -f $file ]] && run-node caterwaul.js     modules/caterwaul.{std,opt,continuation,seq}.js     lib/unit.js $file &&
                        run-node caterwaul.min.js modules/caterwaul.{std,opt,continuation,seq}.min.js lib/unit.js $file
    done
    grep '^fail' .test-log && return 1
    return 0
  }

# Browser testing.
# I'm too lazy to manually update the test page every time I add a new unit test, so this script generates it from the list of tests that get run when you run build unit. The client-side test
# code is now factored into lib/unit.client.js.

  testpage() {
    rm -f test/index.html
    echo '<html><head><title>Caterwaul tests</title><script src="../lib/unit.js"></script><script src="../lib/unit.client.js"></script>' >> test/index.html
    echo '<script src="../caterwaul.all.min.js"></script></head>'                                                                        >> test/index.html
    echo '<body><p>Any failing tests will produce log messages below.</p><div id="log"></div>'                                           >> test/index.html

    find -wholename './test/*.js'           | sed 's/^/<script src="..\//;s/$/"><\/script>/' >> test/index.html
    find -wholename './modules/*.test/*.js' | sed 's/^/<script src="..\//;s/$/"><\/script>/' >> test/index.html

    echo '</body></html>' >> test/index.html
  }

# Version packaging.
# Caterwaul is versioned in the stable/ directory. All production-worthy (i.e. minified) files are included in a versioned release, and a commit ID is also included.

  package() {
    if [[ -d stable/$1 ]]; then
      echo package: version $1 already exists
      return 1
    fi
    unit || return 1
    mkdir stable/$1
    cp *.min.js modules/*.min.js stable/$1/
    git add stable/$1
    git commit -am "Automatic commit for version $1"
    git tag version-$1
    cp .git/refs/heads/master stable/$1/commit-id
    tar -cj stable/$1 > stable/$1.tar.bz2
    git add stable/$1*
    git commit -am "Automatic commit for version $1 deployment"
  }

# Informational stuff.
# Trivial build rules that don't actually do anything, but exist to provide information about the code.

  loc() {
    generate
    echo "core gzip bytes:    $(gzip -c9 caterwaul.min.js | wc -c)"
    echo "core compact bytes: $(cat caterwaul.min.js | wc -c)"

    rm -f *.min.js modules/*.min.js caterwaul.all.js
    echo "total LOC/chars:          $(cat test/*.js modules/*.js modules/*.test/*.js caterwaul.js | wc -lm)"
    echo "core SLOC/chars:          $(grep -v '//' < caterwaul.js | grep -v '^$' | wc -lm)"
    echo "core comment LOC/chars:   $(grep '//' < caterwaul.js | wc -lm)"
    echo "core test SLOC/chars:     $(cat test/*.js | grep -v '//' | grep -v '^$' | wc -lm)"
    echo

    for m in modules/*.js; do
      echo "Module ${m#modules/}:"
      echo "  SLOC/chars:        $(cat $m | grep -v '//' | grep -v '^$' | wc -lm)"
      echo "  comment LOC/chars: $(cat $m | grep '//' | wc -lm)"
      [[ -d ${m/js/test} ]] && echo "  test SLOC/chars:   $(cat ${m/js/test}/*.js | grep -v '//' | grep -v '^$' | wc -lm)"
      echo
    done

    generate

    echo "caterwaul.all.min chars/gzip bytes: $(cat caterwaul.all.min.js | wc -m) / $(gzip -c caterwaul.all.min.js | wc -c)"
  }

# Main loop.
# There are only a few things that the main loop provides, mainly to keep the interface simple.

  if [[ build.sdoc -nt build ]]; then
    sdoc -p build.sdoc
    $0 "$@"
  else
    command=$1
    shift
    case $command in
      repl)     repl "$@" ;;
      unit)     unit "$@" ;;
      generate) generate "$@" ;;
      package)  package "$@" ;;
      loc)      loc "$@" ;;
      *)        echo "usage: $0 {unit|package|loc}" ;;
    esac
  fi

# Generated by SDoc 
