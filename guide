#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result;
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name");
};

meta::meta('configure', <<'__25976e07665878d3fae18f050160343f');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__25976e07665878d3fae18f050160343f

meta::meta('externalize', <<'__9141b4e8752515391385516ae94b23b5');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9141b4e8752515391385516ae94b23b5

meta::meta('externalize_template', <<'__1e90e7ccb5fea1d498bbaaa6e7e43851');
sub meta::externalize_template {
  my ($name, $implementation) = @_;
  meta::externalize "template::$name", "template::$name", $implementation;
}
__1e90e7ccb5fea1d498bbaaa6e7e43851

meta::meta('functor::code-templates', <<'__8438e73e45c87188c8b46d0c43eb4971');
package code;

# Templates for generating named source files.
sub template {
  my ($name, $implementation) = @_;
  $implementation ||= sub {
    my ($line, $block) = @_;
    my $append         = $line =~ s/^\h*>>\h*//o;

    $line =~ s/\s+.*$//o;
    file::write(&{'::source-directory'}() . "/$line", ($append && "\n") . $block, mkpath => 1, append => $append);
    "\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{${name}code}\n$block \\end{${name}code}";
  };

  meta::externalize_template $name, $implementation;
}
__8438e73e45c87188c8b46d0c43eb4971

meta::meta('functor::editable', <<'__bbfdc65c8d51695de1cd6050232555bd');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return &{$options{default}}(retrieve($attribute))                                    if ref $options{default} eq 'CODE'                                          and not defined $command;
      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return retrieve($attribute);
    };
  };
}
__bbfdc65c8d51695de1cd6050232555bd

meta::meta('functor::tex-templates', <<'__34a5da8558897a4388fc22ed4b0c3c6b');
package tex;

# A wrapper for TeX templates. The idea is always the same, so I'm abstracting out the
# common externalization logic here.
sub template_for(&) {
  my ($implementation) = @_;
  sub {
    my %names = @_;
    for my $name (keys %names) {
      ::meta::externalize_template $name, sub {
        &$implementation($names{$name}, @_);
      };
    }
  };
}

sub id {
  map {$_ => $_} @_;
}

# Creates a one-line or multiline template based on normal TeX syntax. It's a straight
# transfer into TeX with no preprocessing.
*template = template_for {
  my ($name, $line, $block) = @_;
  $block ? "\\begin{$name}\n$block\n\\end{$name}" : "\\$name\{$line\}";
};

# Creates a labeled one-line template. This is just like normal TeX, but assumes the
# specification of a label name after a pipe character.
*labeled_template = template_for {
  my ($name, $line, undef) = @_;
  my ($real_stuff, $label) = split /\h*\|\h*/, $line;
  "\\$name\{$real_stuff\}" . ($label && "\\label{$label}");
};
__34a5da8558897a4388fc22ed4b0c3c6b

meta::meta('template::code', 'code::template $_ for qw/java cpp asm javascript html resource/;');
meta::meta('template::document', 'tex::template tex::id(qw/document tableofcontents maketitle title author date abstract documentclass verbatim/);');
meta::meta('template::enumeration', 'tex::template tex::id(qw/enumerate itemize description item/);');
meta::meta('template::math', <<'__2ea173a12f781eec97f4a0d3bfe80f75');
tex::template align => 'align*', nalign => 'align';
tex::template tex::id(qw/theorem proof lemma corollary conjecture definition proposition/);
__2ea173a12f781eec97f4a0d3bfe80f75

meta::meta('template::sections', <<'__0bf14cbc6a0e77d9b82dd185d8d8a9a0');
tex::labeled_template(s1 => 'section', s2 => 'subsection', s3 => 'subsubsection', s4 => 'paragraph', s5 => 'subparagraph');
tex::labeled_template(sc => 'chapter', sp => 'part');
__0bf14cbc6a0e77d9b82dd185d8d8a9a0

meta::meta('type::bootstrap', <<'__297d03fb32df03b46ea418469fc4e49e');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__297d03fb32df03b46ea418469fc4e49e

meta::meta('type::configuration', <<'__d67e10a128e6b1d958c5b9d3bbe25aa4');
meta::functor::editable 'configuration', inherit => 0, extension => '.conf', default => sub {
  # Any lines starting with #, with or without leading whitespace, are treated as comments.
  # Comments are not parsed in option text; that is, you could specify an option that contained
  # a # and the # and following text would be considered part of that option.
  my ($data) = @_;
  my @options = grep /:/o && ! /^\h*#/o && ! /^\h*$/o, split(/\v+/o, $data);
  s/^\h+//o for @options;
  my @key_values = map split(/\s*:\s*/o, $_, 2), @options;
  $key_values[$_ << 1] and $key_values[$_ << 1] =~ s/\s/_/go for 0 .. @key_values >> 1;
  $key_values[$_ << 1] and $key_values[$_ << 1] = lc $key_values[$_ << 1] for 0 .. @key_values >> 1;
  @key_values;
};
__d67e10a128e6b1d958c5b9d3bbe25aa4

meta::meta('type::data', 'meta::functor::editable \'data\', extension => \'\', inherit => 0, default => \'cat\';');
meta::meta('type::function', <<'__d93b3cc15693707dac518e3d6b1f5648');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__d93b3cc15693707dac518e3d6b1f5648

meta::meta('type::inc', <<'__c95915391b969734305f2f492d5ca8e3');
meta::configure 'inc', inherit => 1, extension => '.pl';
meta::define_form 'inc', sub {
  use File::Path 'mkpath';
  use File::Basename qw/basename dirname/;

  my ($name, $value) = @_;
  my $tmpdir   = basename($0) . '-' . $$;
  my $filename = "/tmp/$tmpdir/$name";

  push @INC, "/tmp/$tmpdir" unless grep /^\/tmp\/$tmpdir$/, @INC;

  mkpath(dirname($filename));
  unless (-e $filename) {
    open my $fh, '>', $filename;
    print $fh $value;
    close $fh;
  }
};
__c95915391b969734305f2f492d5ca8e3

meta::meta('type::internal_function', <<'__34abb44c67c7e282569e28ef6f4d62ab');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__34abb44c67c7e282569e28ef6f4d62ab

meta::meta('type::library', <<'__a9c0193f297bbc96a78eb5e27727fd30');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__a9c0193f297bbc96a78eb5e27727fd30

meta::meta('type::message_color', <<'__794bf137c425293738f07636bcfb5c55');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__794bf137c425293738f07636bcfb5c55

meta::meta('type::meta', <<'__640f25635ce2365b0648962918cf9932');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__640f25635ce2365b0648962918cf9932

meta::meta('type::note', 'meta::functor::editable \'note\', extension => \'\', inherit => 0, default => \'edit\';');
meta::meta('type::parent', <<'__607e9931309b1b595424bedcee5dfa45');
meta::define_form 'parent', \&meta::bootstrap::implementation;
meta::configure 'parent', extension => '', inherit => 1;
__607e9931309b1b595424bedcee5dfa45

meta::meta('type::resource', 'meta::functor::editable \'resource\', extension => \'.cltex\', inherit => 1, default => \'edit\';');
meta::meta('type::section', 'meta::functor::editable \'section\', extension => \'.cltex\', inherit => 0, default => \'edit\';');
meta::meta('type::state', <<'__c1f29670be26f1df6100ffe4334e1202');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__c1f29670be26f1df6100ffe4334e1202

meta::meta('type::template', <<'__25f4d6eafb1d3eea6d5d3d9a71a5623e');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__25f4d6eafb1d3eea6d5d3d9a71a5623e

meta::meta('type::vim_highlighter', 'meta::functor::editable \'vim_highlighter\', extension => \'.vim\', inherit => 1, default => \'edit\';');
meta::meta('type::watch', 'meta::functor::editable \'watch\', prefix => \'watch::\', inherit => 1, extension => \'.pl\', default => \'cat\';');
meta::bootstrap('initialization', <<'__baa43e5e8e6e1cd76d4e2de828ceaa4d');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result;
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name");
};

__baa43e5e8e6e1cd76d4e2de828ceaa4d

meta::data('default-action', 'shell');
meta::data('license', <<'__3c6177256de0fddb721f534c3ad8c0ee');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__3c6177256de0fddb721f534c3ad8c0ee

meta::data('name', 'guide');
meta::data('output-dir', '/tmp');
meta::data('pdf-output-file', '/tmp/guide.BStW/document.pdf');
meta::data('pdf-reader', '/usr/bin/evince');
meta::data('pdftex-command', 'pdflatex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__');
meta::data('quiet', '1');
meta::data('source-directory', '.');
meta::data('table-of-contents', '1');
meta::data('tex-command', 'latex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__');
meta::data('watching', '0');
meta::function('cat', 'join "\\n", retrieve(@_);');
meta::function('child', <<'__3eeb4b4fd37a502b53f0008e7835b5de');
my ($child_name) = @_;

# Make the child inherit from this object. The easiest way to do that is to
# grab $0, which is presumably executable, and have the child update from it.
hypothetically(sub {
  associate('data::name', $child_name);
  clone($child_name);
});

enable();
qx($child_name update-from $0 -nu);
disable();
__3eeb4b4fd37a502b53f0008e7835b5de

meta::function('clean', <<'__1269c1a312062a1598dcde16eb6134e2');
my $output_directory = &{'pdf-output-file'}();
$output_directory =~ s+/.*++g;
unlink <$output_directory/*>;
rmdir $output_directory;
__1269c1a312062a1598dcde16eb6134e2

meta::function('clone', <<'__5a30a4ba6293e250ed22884d609e4781');
for (grep length, @_) {
  file::write($_, serialize(), noclobber => 1);
  chmod(0700, $_);
}
__5a30a4ba6293e250ed22884d609e4781

meta::function('compile', <<'__59d02438dafea67f3f12c2b74f4a8bfb');
my $tex_command         = &{'tex-command'}();
my $pdftex_command      = &{'pdftex-command'}();
my $filename            = 'document';

my $contents            = tex();
my $output_directory    = &{'output-dir'}();
chomp $output_directory;

my $temporary_directory = temporary_name();
$temporary_directory =~ s+^.*/++;
$temporary_directory = "$output_directory/$temporary_directory";

$tex_command    =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$tex_command    =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

$pdftex_command =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$pdftex_command =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

mkdir $temporary_directory;
file::write("$temporary_directory/$filename.tex", $contents);

my $result = &{'table-of-contents'}() ? system($tex_command) || system($tex_command) || system($pdftex_command) : system($pdftex_command);

associate('data::pdf-output-file', "$temporary_directory/$filename.pdf", execute => 1);
$result;
__59d02438dafea67f3f12c2b74f4a8bfb

meta::function('cp', <<'__d33fe9aa270eeee6dcc3ee445447a6a7');
my ($from, $to) = @_;
my $exists = exists $data{$from};
associate($to, retrieve($from)) if $exists;
die "No such attribute $from" unless $exists;
retrieve($from);
__d33fe9aa270eeee6dcc3ee445447a6a7

meta::function('create', <<'__97e5444422f5f6087371f59ddc3e1b8c');
my ($name, $value) = @_;

return edit($name) if exists $data{$name};

if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__97e5444422f5f6087371f59ddc3e1b8c

meta::function('current-state', <<'__d83ae43551c0f58d1d0ce576402a315a');
my @valid_keys   = grep ! /^state::/, sort keys %data;
my @ordered_keys = (grep(/^meta::/, @valid_keys), grep(! /^meta::/, @valid_keys));
join "\n", map serialize_single($_), @ordered_keys;
__d83ae43551c0f58d1d0ce576402a315a

meta::function('disable', 'chmod_self(sub {$_[0] & 0666});');
meta::function('edit', <<'__6912fb43aad413e79cbf45e134866b6e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

die "Attribute $name does not exist." unless exists $data{$name};
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, attribute => $name, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__6912fb43aad413e79cbf45e134866b6e

meta::function('enable', 'chmod_self(sub {$_[0] | $_[0] >> 2});');
meta::function('export', <<'__6c445eea603f9863df0f8db445fd708e');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  die 'Not enough arguments';
}
__6c445eea603f9863df0f8db445fd708e

meta::function('extern', '&{$_[0]}(retrieve(@_[1 .. $#_]));');
meta::function('grep', <<'__ccbc55153c3f45db829686632273b93b');
# Looks through attributes for a pattern. Usage is grep pattern [options], where
# [options] is the format as provided to select_keys.

my $pattern              = shift @_ or die 'Must specify a pattern to search for';
my ($options, @criteria) = separate_options(@_);
my @attributes           = select_keys(%$options, '--criteria' => join('|', @criteria));
my $color                = $$options{'-c'};

my @matching_attributes;
my @matching_line_numbers;
my @matching_lines;

for my $k (@attributes) {
  my @lines = split /\n/, retrieve($k);
  for (0 .. $#lines) {
    next unless $lines[$_] =~ /$pattern/;

    $lines[$_] =~ s/($pattern)/\033[1;31m\1\033[0;0m/g if $color;

    push @matching_attributes,   $k;
    push @matching_line_numbers, $_ + 1;
    push @matching_lines,        $lines[$_];
  }
}

if ($color) {
  s/^/\033[1;34m/o                    for @matching_attributes;
  s/^/\033[1;32m/o && s/$/\033[0;0m/o for @matching_line_numbers;
}

table_display([@matching_attributes], [@matching_line_numbers], [@matching_lines]);
__ccbc55153c3f45db829686632273b93b

meta::function('hash', <<'__7c4145cf6e97dfb9ab04a613866751d3');
my ($data) = @_;
fast_hash($data);
__7c4145cf6e97dfb9ab04a613866751d3

meta::function('import', <<'__84d29edfe7ad2119465fdcf7d037ed1c');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__84d29edfe7ad2119465fdcf7d037ed1c

meta::function('import-bundle', <<'__4c7139ed5c9f65f38a33cf8f8a6cae27');
eval join '', <STDIN>;
die $@ if $@;
__4c7139ed5c9f65f38a33cf8f8a6cae27

meta::function('load-state', <<'__878f141333993ead4d272027ad301eee');
my ($state_name) = @_;
my $state = retrieve("state::$state_name");

terminal::message('state', 'Saving current state into _...');
&{'save-state'}('_');

terminal::message('state', 'Removing attributes from %data and unexternalizing functions...');
delete $data{$_} for grep ! /^state::/ && ! /^internal::runtime$/, keys %data;
%externalized_functions = ();

terminal::message('state', "Restoring state $state_name...");
eval($state);
terminal::message('error', $@) if $@;
reload();
verify();
__878f141333993ead4d272027ad301eee

meta::function('lock', 'chmod_self(sub {$_[0] & 0555});');
meta::function('ls', <<'__ffe7609f16d647b7eb9ed9693dd12c23');
my ($options, @criteria) = separate_options(@_);

my ($all, $shadows, $dereference, $sizes, $flags) = @$options{qw(-a -s -d -z -l)};
$all   ||= $dereference;
$sizes ||= $flags;

return table_display([grep ! defined $data{$externalized_functions{$_}}, sort keys %externalized_functions]) if $shadows;

my $criteria    = join('|', @criteria);
my @definitions = select_keys('--criteria' => $criteria, %$options);

my %inverses  = map {$externalized_functions{$_} => $_} keys %externalized_functions;
my @externals = map $inverses{$_}, @definitions;
my @sizes     = map sprintf('%6d %6d', length(serialize_single($_)), length(retrieve($_))), @definitions if $sizes;

my %flag_hashes = map {$_ => {map {$_ => 1} select_keys("-$_" => 1)}} qw(m u i) if $flags;
my @flags       = map {my $k = $_; join '', map($flag_hashes{$_}{$k} ? $_ : '-', sort keys %flag_hashes)} @definitions if $flags;

join "\n", map strip($_), split /\n/, table_display($all ? [@definitions] : [grep length, @externals], $dereference ? ([@externals]) : (),
                                                    $sizes ? ([@sizes]) : (), $flags ? ([@flags]) : ());
__ffe7609f16d647b7eb9ed9693dd12c23

meta::function('ls-a', 'ls(\'-ad\', @_);');
meta::function('make', <<'__9a3d7e3c7e0017f4c9b239f3858aaf03');
compile() || view();
clean();
__9a3d7e3c7e0017f4c9b239f3858aaf03

meta::function('mv', <<'__09f350db8406303ade06d229477d79ad');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

die "'$from' does not exist" unless exists $data{$from};
die "The namepsace '$destination_namespace' does not exist" unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__09f350db8406303ade06d229477d79ad

meta::function('note', <<'__bcbfeac6dd2112f47296265444570a6e');
# Creates a note with a given name, useful for jotting things down.
create("note::$_[0]");
__bcbfeac6dd2112f47296265444570a6e

meta::function('parents', 'join "\\n", grep s/^parent:://o, sort keys %data;');
meta::function('perl', <<'__f2b57dd342923797e8e2287c3095803f');
my $result = eval(join ' ', @_);
$@ ? terminal::message('error', $@) : $result;
__f2b57dd342923797e8e2287c3095803f

meta::function('preprocess', <<'__66e539d29e9afa903569efad0eb7c886');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__66e539d29e9afa903569efad0eb7c886

meta::function('reload', 'execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;');
meta::function('render', <<'__ccb26db43115329651cc3c0527a3e849');
use File::Copy 'copy';
compile();
copy(&{'pdf-output-file'}(), &{'source-directory'}() . '/' . name() . '.pdf') or die "Copy failed: $!";
__ccb26db43115329651cc3c0527a3e849

meta::function('rm', <<'__963fdd3d9f6a0ba279b001b1f5679a38');
for my $to_be_deleted (@_) {
  terminal::message('warning', "$to_be_deleted does not exist") unless exists $data{$to_be_deleted};
}

delete @data{@_};
__963fdd3d9f6a0ba279b001b1f5679a38

meta::function('save', <<'__ca9ab587c78ff2024ef9ad8ca634db5b');
if (! verify()) {
  die "$0 has not been updated";
} else {
  my $serialized_data = serialize();
  eval {file::write($0, $serialized_data)};
  die $@ if $@;
  terminal::message('info', "$0 saved successfully.");
}
__ca9ab587c78ff2024ef9ad8ca634db5b

meta::function('save-state', <<'__5c5b586331e25951140ced6442d9fe2b');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
associate("state::$state_name", &{'current-state'}(), execute => 1);
__5c5b586331e25951140ced6442d9fe2b

meta::function('serialize', <<'__023436ac07471e2f2cf016e2172c8d73');
my ($options, @criteria) = separate_options(@_);
my $partial              = $$options{'-p'};
my $criteria             = join '|', @criteria;
my @attributes           = map serialize_single($_), select_keys(%$options, '-m' => 1, '--criteria' => $criteria), select_keys(%$options, '-M' => 1, '--criteria' => $criteria);
my @final_array          = @{$partial ? \@attributes : [retrieve('bootstrap::initialization'), @attributes, 'internal::main();', '', '__END__']};

join "\n", @final_array;
__023436ac07471e2f2cf016e2172c8d73

meta::function('serialize_single', <<'__48005281edde632b0df2e346c094b7bd');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $meta_function_name = 'meta::' . namespace($name);
my $invocation_name    = attribute($name);
my $escaped            = $contents;
$escaped =~ s/\\/\\\\/go;
$escaped =~ s/'/\\'/go;

return "$meta_function_name('$invocation_name', '$escaped');" unless $escaped =~ /\v/;

my $delimiter = '__' . fast_hash($contents);
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__48005281edde632b0df2e346c094b7bd

meta::function('shell', <<'__c6ef6c31734c0b330f6076543fef8f1f');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $output = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      chomp(my $result = eval {&$function_name(@args)});
      terminal::message('error', translate_backtrace($@)) if $@;
      print $output $result, "\n" unless $@;
    } else {
      terminal::message('warning', "Command not found: '$function_name' (use 'ls' to see available commands)");
    }
  }

  if (watching()) {
    for (grep /^watch::/, sort keys %data) {
      my $watch = retrieve($_);
      terminal::message('watch', "$_ => " . meta::eval_in($watch, $_));
    }
  }

  $prompt = name() . '$ ';
}
__c6ef6c31734c0b330f6076543fef8f1f

meta::function('size', 'length(serialize());');
meta::function('snapshot', <<'__787158a5844d36cbfd29e5b74c9167e1');
my ($name) = @_;
file::write(my $finalname = temporary_name($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('state', "Created snapshot at $finalname.");
__787158a5844d36cbfd29e5b74c9167e1

meta::function('state', <<'__e17520e3a5d81d788ae995fd8ac47cb9');
my @keys = sort keys %data;
my $hash = fast_hash(scalar @keys);
$hash = fast_hash($hash . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__e17520e3a5d81d788ae995fd8ac47cb9

meta::function('tex', <<'__5bb8bf491e1b442858096acf711135f9');
my ($document) = @_;
$document ||= 'main';
preprocess(retrieve("section::$document"));
__5bb8bf491e1b442858096acf711135f9

meta::function('unlock', 'chmod_self(sub {$_[0] | 0200});');
meta::function('update', '&{\'update-from\'}(@_, grep s/^parent:://o, sort keys %data);');
meta::function('update-from', <<'__f927cc6b2e1c93ce2e969845e01ba839');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.
#
# Note that this assumes you trust the remote script. If you don't, then you shouldn't update from it.

my ($options, @targets) = separate_options(@_);

my %options = %$options;
@targets or die 'Must specify at least one target to update from';

my $save_state = ! ($options{'-n'} || $options{'--no-save'});
my $no_parents =    $options{'-P'} || $options{'--no-parent'} || $options{'--no-parents'};
my $force      =    $options{'-f'} || $options{'--force'};
my $unique     =    $options{'-u'} || $options{'--unique'};

my $unique_option = $unique ? '-u' : '';

&{'save-state'}('before-update') if $save_state;
terminal::message('warning', 'Not saving state, as requested; to save it, omit the -n option.') unless $save_state;

for my $target (@targets) {
  terminal::message('info', "Updating from $target");

  my $attributes = join '', qx($target ls -aiu);
  terminal::message('warning', "Skipping unreachable object $target") unless $attributes;

  if ($attributes) {
    rm(split /\n/, retrieve("parent::$target")) if $data{"parent::$target"};
    associate("parent::$target", $attributes) unless $no_parents;

    terminal::message('info', 'Updating meta attributes...');
    eval qx($target serialize -ipm $unique_option);
    terminal::message('warning', $@) if $@;

    terminal::message('info', 'Updating non-meta attributes...');
    eval qx($target serialize -ipM $unique_option);
    terminal::message('warning', $@) if $@;
    reload();

    if (verify()) {
      terminal::message('info', "Successfully updated from $_[0]. Run 'load-state before-update' to undo this change.") if $save_state;
    } elsif ($force) {
      terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
      terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
      terminal::message('info',    'Run "load-state before-update" to undo the update and return to a working state.') if $save_state;
    } else {
      terminal::message('error',   'Verification failed after the upgrade was complete.');
      terminal::message('info',    "$0 has been reverted to its pre-upgrade state.") if $save_state;
      terminal::message('info',    "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.") if $save_state;
      return &{'load-state'}('before-update') if $save_state;
    }
  }
}
__f927cc6b2e1c93ce2e969845e01ba839

meta::function('usage', <<'__25615bcd877fcf7e5c823dec475f0a31');
<<"EOD" . ls ('-d');
Usage: $0 action [arguments]
Defined actions (and the attribute that defines them):
EOD
__25615bcd877fcf7e5c823dec475f0a31

meta::function('verify', <<'__e8ff828f42cdc7d759b70bb81721ddb6');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
$transient{temporary_filename} = $temporary_filename;
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
unlink $temporary_filename if $result;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;

$result;
__e8ff828f42cdc7d759b70bb81721ddb6

meta::function('view', <<'__72064117780244bd9dd38659573b9f2c');
my $pdf_reader      = &{'pdf-reader'}();
my $pdf_output_file = &{'pdf-output-file'}();
chomp $pdf_reader;
system("$pdf_reader '$pdf_output_file'");
__72064117780244bd9dd38659573b9f2c

meta::function('vim', <<'__bd231af998c353790253bc6660be0b90');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__bd231af998c353790253bc6660be0b90

meta::internal_function('associate', <<'__80f0728190bf3b0d4c94807cfdc12a22');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
die "Namespace $namespace does not exist" unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__80f0728190bf3b0d4c94807cfdc12a22

meta::internal_function('attribute', <<'__62efb9f22157835940af1d5feae98d98');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__62efb9f22157835940af1d5feae98d98

meta::internal_function('chmod_self', <<'__b13487447c65f2dc790bd6b21dde89dd');
my ($mode_function)      = @_;
my (undef, undef, $mode) = stat $0;
chmod &$mode_function($mode), $0;
__b13487447c65f2dc790bd6b21dde89dd

meta::internal_function('complete', <<'__f14ae2337c0653b6bb6fd02bb6493646');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__f14ae2337c0653b6bb6fd02bb6493646

meta::internal_function('debug_trace', <<'__f887289259890731458a66398b628cdc');
quiet() or terminal::message('debug', join ', ', @_);
wantarray ? @_ : $_[0];
__f887289259890731458a66398b628cdc

meta::internal_function('execute', <<'__4b4efc33bc6767a7aade7f427eedf83f');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(attribute($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__4b4efc33bc6767a7aade7f427eedf83f

meta::internal_function('fast_hash', <<'__ac70f469e697725cfb87629833434ab1');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__ac70f469e697725cfb87629833434ab1

meta::internal_function('file::read', <<'__186bbcef8f6f0dd8b72ba0fdeb1de040');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__186bbcef8f6f0dd8b72ba0fdeb1de040

meta::internal_function('file::write', <<'__eb7b1efebe0db73378b0cce46681788d');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

open my($handle), $options{append} ? '>>' : '>', $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__eb7b1efebe0db73378b0cce46681788d

meta::internal_function('fnv_hash', <<'__8d001a3a7988631bab21a41cee559758');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__8d001a3a7988631bab21a41cee559758

meta::internal_function('hypothetically', <<'__33ee2e1595d3877bd1d9accaa72305c8');
# Applies a temporary state and returns a serialized representation.
# The original state is restored after this, regardless of whether the
# temporary state was successful.

my %data_backup   = %data;
my ($side_effect) = @_;
my $return_value  = eval {&$side_effect()};
%data = %data_backup;

die $@ if $@;
$return_value;
__33ee2e1595d3877bd1d9accaa72305c8

meta::internal_function('internal::main', <<'__acb38ec5971c89f794f486f1c30900e6');
disable();

$SIG{'INT'} = sub {
  snapshot();
  exit 1;
};

my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
terminal::message('warning', "Unknown action: '$function_name'") and $function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

save() unless $initial_state eq state();

END {
  enable();
}
__acb38ec5971c89f794f486f1c30900e6

meta::internal_function('invoke_editor_on', <<'__7c798760d79429e5b52d9fa934e889d8');
my ($data, %options) = @_;
my $editor           = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} ||
                       die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options          = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $extension        = $options{extension} || '';
my $attribute        = $options{attribute} || '';

my $filename         = temporary_name() . "-$attribute" . $extension;

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__7c798760d79429e5b52d9fa934e889d8

meta::internal_function('main', <<'__cb63fed16dd9ee83dcbd15aa72643d74');
$SIG{'INT'} = sub {
  snapshot();
  exit 1;
};

my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
terminal::message('warning', "Unknown action: '$function_name'") and $function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

save() unless $initial_state eq state();
__cb63fed16dd9ee83dcbd15aa72643d74

meta::internal_function('namespace', <<'__93213d60cafb9627e0736b48cd1f0760');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__93213d60cafb9627e0736b48cd1f0760

meta::internal_function('retrieve', <<'__0e9c1ae91f6cf6020cf1a05db7d51d72');
my @results = map defined $data{$_} ? $data{$_} : file::read($_), @_;
wantarray ? @results : $results[0];
__0e9c1ae91f6cf6020cf1a05db7d51d72

meta::internal_function('select_keys', <<'__9f1f6ed4c1df5aa5f62cfd0ded8e6ae6');
my %options   = @_;
my %inherited = map {$_ => 1} split /\n/o, join "\n", retrieve(grep /^parent::/o, sort keys %data) if $options{'-u'} or $options{'-U'};
my $criteria  = $options{'--criteria'} || $options{'--namespace'} && "^$options{'--namespace'}::" || '.';

grep /$criteria/ && (! $options{'-u'} || ! $inherited{$_}) &&
                    (! $options{'-U'} ||   $inherited{$_}) &&
                    (! $options{'-i'} ||   $transient{inherit}{namespace($_)}) &&
                    (! $options{'-I'} || ! $transient{inherit}{namespace($_)}) &&
                    (! $options{'-S'} || ! /^state::/o) &&
                    (! $options{'-m'} ||   /^meta::/o) &&
                    (! $options{'-M'} || ! /^meta::/o), sort keys %data;
__9f1f6ed4c1df5aa5f62cfd0ded8e6ae6

meta::internal_function('separate_options', <<'__d47e8ee23fe55e27bb523c9fcb2f5ca1');
# Things with one dash are short-form options, two dashes are long-form.
# Characters after short-form are combined; so -auv4 becomes -a -u -v -4.
# Also finds equivalences; so --foo=bar separates into $$options{'--foo'} eq 'bar'.
# Stops processing at the -- option, and removes it. Everything after that
# is considered to be an 'other' argument.

# The only form not supported by this function is the short-form with argument.
# To pass keyed arguments, you need to use long-form options.

my @parseable;
push @parseable, shift @_ until ! @_ or $_[0] eq '--';

my @singles = grep /^-[^-]/, @parseable;
my @longs   = grep /^--/,    @parseable;
my @others  = grep ! /^-/,   @parseable;

my @singles = map /-(.{2,})/ ? map("-$_", split(//, $1)) : $_, @singles;

my %options;
  $options{$1} = $2 for grep /^([^=]+)=(.*)$/, @longs;
++$options{$_}      for grep ! /=/, @singles, @longs;

({%options}, @others, @_);
__d47e8ee23fe55e27bb523c9fcb2f5ca1

meta::internal_function('strip', 'wantarray ? map {s/^\\s*|\\s*$//g; $_} @_ : $_[0] =~ /^\\s*(.*?)\\s*$/ && $1;');
meta::internal_function('table_display', <<'__8a6897e093f36bf05477a3889b84a61d');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map strip(sprintf($format, @$_)), @row_major;
__8a6897e093f36bf05477a3889b84a61d

meta::internal_function('temporary_name', <<'__0fb1402061581b69822f913631b4a9d9');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__0fb1402061581b69822f913631b4a9d9

meta::internal_function('translate_backtrace', <<'__06fad3d85833a6484e426401b95e0206');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__06fad3d85833a6484e426401b95e0206

meta::library('terminal', <<'__6999988eaf441c9b1282e03e1db427b5');
# Functions for nice-looking terminal output.
package terminal;

my %color_conversions = (black  => "0;0", red  => "1;31", yellow => "1;33", green => "1;32",
                                          blue => "1;34", purple => "1;35", cyan  => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color   'debug',   'blue';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}\[\033[${color}m$prefix\033[0;0m] $message\n";
}
__6999988eaf441c9b1282e03e1db427b5

meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::message_color('watch', 'blue');
meta::note('orthogonality', 'Right now, the stack language isn\'t at all orthogonal. It\'s hard to remember and needs to be cleaned up before it\'s very useful.');
meta::parent('/home/spencertipping/bin/literate-project', <<'__db24da081d7ec99943b65e5c7bcf0979');
function::clean
function::compile
function::make
function::render
function::tex
function::view
internal_function::main
meta::externalize_template
meta::functor::code-templates
meta::functor::tex-templates
meta::template::code
meta::template::document
meta::template::enumeration
meta::template::math
meta::template::sections
meta::type::resource
meta::type::section
parent::development
resource::header
resource::header-languages
resource::header-listings
resource::header-packages
resource::header-refs
resource::header-resource
template::item[]
vim_highlighter::cltex
__db24da081d7ec99943b65e5c7bcf0979

meta::parent('/home/spencertipping/bin/object', <<'__2fa5e2565231e24d8c3ba43abc0403c4');
bootstrap::initialization
function::cat
function::child
function::clone
function::cp
function::create
function::current-state
function::disable
function::edit
function::enable
function::export
function::extern
function::grep
function::hash
function::import
function::import-bundle
function::load-state
function::lock
function::ls
function::ls-a
function::mv
function::parents
function::perl
function::reload
function::rm
function::save
function::save-state
function::serialize
function::serialize_single
function::shell
function::size
function::snapshot
function::state
function::unlock
function::update
function::update-from
function::usage
function::verify
internal_function::associate
internal_function::attribute
internal_function::chmod_self
internal_function::complete
internal_function::debug_trace
internal_function::execute
internal_function::fast_hash
internal_function::file::read
internal_function::file::write
internal_function::fnv_hash
internal_function::hypothetically
internal_function::internal::main
internal_function::invoke_editor_on
internal_function::namespace
internal_function::retrieve
internal_function::select_keys
internal_function::separate_options
internal_function::strip
internal_function::table_display
internal_function::temporary_name
internal_function::translate_backtrace
library::terminal
message_color::state
message_color::states
message_color::watch
meta::configure
meta::externalize
meta::functor::editable
meta::type::bootstrap
meta::type::data
meta::type::function
meta::type::inc
meta::type::internal_function
meta::type::library
meta::type::message_color
meta::type::meta
meta::type::parent
meta::type::state
meta::type::watch
__2fa5e2565231e24d8c3ba43abc0403c4

meta::parent('configuration', <<'__511208c99d8bc2caa3067db9f1824163');
meta::type::configuration
parent::/home/spencertipping/bin/object
__511208c99d8bc2caa3067db9f1824163

meta::parent('development', <<'__4ad4d4e680cfb5934a6e72241f8dd17c');
parent::configuration
parent::notes
parent::preprocessor
parent::vim-highlighters
__4ad4d4e680cfb5934a6e72241f8dd17c

meta::parent('notes', <<'__320d51928ec8e2e370d67d30abe059b5');
function::note
meta::type::note
parent::object
__320d51928ec8e2e370d67d30abe059b5

meta::parent('object', <<'__2fa5e2565231e24d8c3ba43abc0403c4');
bootstrap::initialization
function::cat
function::child
function::clone
function::cp
function::create
function::current-state
function::disable
function::edit
function::enable
function::export
function::extern
function::grep
function::hash
function::import
function::import-bundle
function::load-state
function::lock
function::ls
function::ls-a
function::mv
function::parents
function::perl
function::reload
function::rm
function::save
function::save-state
function::serialize
function::serialize_single
function::shell
function::size
function::snapshot
function::state
function::unlock
function::update
function::update-from
function::usage
function::verify
internal_function::associate
internal_function::attribute
internal_function::chmod_self
internal_function::complete
internal_function::debug_trace
internal_function::execute
internal_function::fast_hash
internal_function::file::read
internal_function::file::write
internal_function::fnv_hash
internal_function::hypothetically
internal_function::internal::main
internal_function::invoke_editor_on
internal_function::namespace
internal_function::retrieve
internal_function::select_keys
internal_function::separate_options
internal_function::strip
internal_function::table_display
internal_function::temporary_name
internal_function::translate_backtrace
library::terminal
message_color::state
message_color::states
message_color::watch
meta::configure
meta::externalize
meta::functor::editable
meta::type::bootstrap
meta::type::data
meta::type::function
meta::type::inc
meta::type::internal_function
meta::type::library
meta::type::message_color
meta::type::meta
meta::type::parent
meta::type::state
meta::type::watch
__2fa5e2565231e24d8c3ba43abc0403c4

meta::parent('preprocessor', <<'__9c447d98a6cfad0ea5444db7eb4b75de');
function::preprocess
meta::type::template
parent::object
template::comment
template::eval
template::failing_conditional
template::include
__9c447d98a6cfad0ea5444db7eb4b75de

meta::parent('vim-highlighters', <<'__1258d5867978f2068c8efd130c2066f7');
function::vim
meta::type::vim_highlighter
parent::object
__1258d5867978f2068c8efd130c2066f7

meta::resource('header', <<'__efe6254be4f73fb4170ab1980a1888d5');
- include resource::header-packages
- include resource::header-listings

- include resource::header-refs

- include resource::header-languages
- include resource::header-resource
__efe6254be4f73fb4170ab1980a1888d5

meta::resource('header-languages', <<'__637a18cf607b727dec3feab552be05e2');
\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
__637a18cf607b727dec3feab552be05e2

meta::resource('header-listings', <<'__4caf6ff3ff152cce49ad5d1775ad0703');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__4caf6ff3ff152cce49ad5d1775ad0703

meta::resource('header-packages', <<'__5a7e0bd196996326e6278b6dc308371c');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__5a7e0bd196996326e6278b6dc308371c

meta::resource('header-refs', '\\newcommand{\\Ref}[2]{\\hyperref[#2]{#1 \\ref*{#2}}}');
meta::resource('header-resource', '\\lstnewenvironment{resourcecode}{}{}');
meta::section('building-functions', <<'__423ef2acb211939a073c075fc1f7e6b5');
- sc Building Functions | sec:building-functions
  Just like the original Divergence, this version is all about building functions. Also just like the old version, it specifies conversions to promote any built-in data type into a function,
  and lets you use your own data types if they provide {\tt .fn()} methods.

  - s1 Numbers | sec:building-functions-numbers
    Numbers are now much more expressive. Just like before, 0, 1, 2, 3, and 4 map to the first five positional parameters. However, there are some new cases:

    - s2 Large positive integers | sec:building-functions-large-positive-integers
      Integers larger than 4 are converted into hexadecimal and interpreted, where each digit is a command in a stack-based language. The stack's initial contents are the positional
      parameters, where {\tt arguments[0]} is at the top and {\tt arguments[arguments.length - 1]} is at the bottom. Digits are interpreted from left-to-right; so, for example, the number {\tt
      0xab} is interpreted as the command {\tt a} followed by the command {\tt b}. The following commands are understood (along with mnemonics in the footnotes):

      - enumerate << end
        - item[] {\tt 5}
          Swap the top two stack entries.\footnote{``5'' looks kind of like ``S'', which stands for Swap.}

        - item[] {\tt 6}
          Drop the top stack entry.\footnote{``6'' is a backwards ``d'', which stands for Drop.}

        - item[] {\tt 7}
          If the next digit is a 0, 1, 2, 3, or 4, then push that digit as a number onto the stack. Otherwise, push the stack depth onto the stack and process the next digit
          normally. As a special case, the command ``77'' deletes all but the top stack entry.\footnote{``7'', when rotated $180^\circ$, looks like the letter ``L'', which stands for Literal
          or Length.}

        - item[] {\tt 8}
          Duplicate the top stack entry.\footnote{``8'' looks like two ``0''s.}

        - item[] {\tt 9}
          Drop the second entry.\footnote{``9'' is ``6'' upside-down, and {\tt 6} drops the top entry.}

        - item[] {\tt a}
          Add the two arguments on the top of the stack, and push the result. This also works on strings. If the top of the stack is an array, then push a new array consisting of the stack top
          concatenated with the second stack element; that is, {\tt stack[0].concat([stack[1]])}.\footnote{``a'' stands for Add or Append.}

        - item[] {\tt b}
          Subtract {\tt stack[1]} from {\tt stack[0]}, pop both, and push the result. If either argument is non-numeric, then this operator applies {\tt ||} to the top two stack entries
          instead; that is, {\tt stack[0] || stack[1]}.\footnote{``b'' stands for suBtract.}

        - item[] {\tt c}
          Pop twice, multiply, and push. If either argument is non-numeric, then this operator applies \verb|&&| to the top two stack entries instead; that is,
          \verb|stack[0] && stack[1]|.\footnote{``c'' stands for Combine, which in regular algebra is generally multiply, and multiplication translates to {\tt and} in Boolean algebra.}

        - item[] {\tt d}
          Pop twice, divide, and push. Operands are ordered the same way as they are for subtraction. If either argument is non-numeric, then this operator dereferences the stack top by the
          stack second instead of performing division; that is, {\tt stack[0][stack[1]]}. If the stack top is undefined or null, then the second argument is dropped silently instead of being
          used for dereferencing.\footnote{``d'' stands for Divide or Dereference.}

        - item[] {\tt e}
          Negate the top stack entry if it's a number. If it's not a number, then apply logical negation.\footnote{``e'' stands for nEgate.}

        - item[] {\tt f}
          Invoke the top stack entry on the next one, and return the result. If the top of the stack isn't a function, then the current {\tt d()} (that is, the one being used to convert this
          number to a function in the first place) is used to convert the stack top to a function first.\footnote{``f'' stands for Function, obviously.}
      - end

      The digits 0-4 push those positional parameters onto the top of the stack. For example, 0 pushes {\tt arguments[0]}, 1 pushes {\tt arguments[1]}, etc.
      
      Here are some examples:

      - javascript examples/large-integer-functions.js << end
        d(0xa)          // => function (x, y) {return x + y}          (if numeric)
        d(0xa)          // => function (x, y) {return x.concat([y])}  (if x is an array)
        d(0xb)          // => function (x, y) {return x - y}          (if numeric)
        d(0xb)          // => function (x, y) {return x || y}         (if non-numeric)
        d(0xc)          // => function (x, y) {return x * y}          (if numeric)
        d(0xc)          // => function (x, y) {return x && y}         (if non-numeric)
        d(0xd)          // => function (x, y) {return x / y}          (if numeric)
        d(0xd)          // => function (x, y) {return x[y]}           (if x is non-numeric)

        d(0x8a)         // => function (x)    {return x + x}          (if numeric)
        d(0x8aa)        // => function (x, y) {return x + x + y}      (if numeric)

        d(0x65b)        // => function (x, y, z) {return z - y}       (if numeric)
        d(0x95b)        // => function (x, y, z) {return z - x}       (if numeric)
        d(0xdd)         // => function (x, y, z) {return x[y][z]}     (if non-numeric)
        d(0xdd)         // => function (x, y, z) {return (x / y) / z} (if numeric)

        d(0x88cc)       // => function (x) {return x * x * x}         (if numeric)
        d(0xee)         // => function (x) {return !!x}               (if non-numeric)
        d(0x7a)         // => function (x) {return x + 1}             (if numeric)
        d(0x74a)        // => function (x) {return x + 4}             (if numeric)
        d(0x748cc)      // => function (x) {return x * 16}            (if numeric)
        d(0x25f15f)     // => function (f, x, y) {return f(y)(x)}
        d(0x7)          // => function () {return arguments.length}
      - end

      To be portable, you should use at most seven hex digits. Some browsers have integer math that can change the sign if the 32-bit is set.\footnote{And anything beyond seven digits
      significantly increases the chances that whoever's maintaining your code later will kill you.}

    - s2 Negative integers | sec:building-functions-negative-integers
      Negative integers are treated just like positive ones, except that the entire stack is returned as an array. This can be useful for reordering or combining things, but is most useful
      when used to transform a function (see \Ref{chapter}{sec:transforming-functions}). For example:

      - javascript examples/negative-integer-functions.js << end
        d(-0xa)         // => function (x, y, ...) {return [x + y, ...]}
        d(-0x7188)      // => function (...) {return [1, 1, 1, ...]}
        d(-0x10)        // => function (x, y, ...) {return [y, x, ...]}
        d(-0x77)        // => function (x, ...) {return [x]}
        d(-0x86)        // => function (x, ...) {return [x, ...]}
        d(-0x7721)      // => function (x, y, z, ...) {return [x, z, y]}
      - end

    - s2 Positive floating-point numbers | sec:building-functions-positive-floating-points
      {\em TBD}

    - s2 Negative floating-point numbers | sec:building-functions-negative-floating-points
      {\em TBD}

  - s1 Strings | sec:building-functions-strings
    Strings delegate to domain-specific language parsers, and this delegation is managed entirely by the first non-whitespace character of the string. Divergence includes a few such languages
    built-in, and others can be defined later on. Here are the ones Divergence comes with:

    - s2 Dereferencing | sec:building-functions-strings-dereferencing
      If a string begins with a dot, then it is treated as a monadic dereferencer. It will not fail if it hits a null reference; it simply stops dereferencing at that point. So, for example:

      - javascript examples/dereferencing-functions.js << end
        d('.foo.bar')({foo: {bar: 5}})          // => 5
        d('.foo.bar')({foo: {bif: 5}})          // => undefined
        d('.foo.bar')({bif: {baz: 5}})          // => undefined
      - end

      If passed multiple arguments, the function will return an array of results.

    - s2 String replacement | sec:building-functions-string-replacement
      If a string begins with {\tt /}, it is treated as a replacement command. All regexps are considered to have the modifier {\tt g} implicitly; this can be changed by anchoring the regexp
      to the beginning or end of the string.

      - javascript examples/string-replacement-functions.js << end
        d('/foo/bar')('foobar')                 // => 'barbar'
        d('/f(o)o/b$1r')('foobar')              // => 'borbar'

        // Multiple replacements are also possible:
        d('/foo/bar; /bif/baz')('foobif')       // => 'barbaz'
        
        // And conditionals:
        d('/foo/bar && /bif/baz')('foobif')     // => 'barbaz'
        d('/foo/bar && /bif/baz')('forbif')     // => 'forbif'
        d('/foo/bar || /bif/baz')('foobif')     // => 'barbif'
      - end

      If invoked on an array or a hash, the function will distribute across their values and return a transformed copy. If invoked on multiple arguments, each argument is transformed and the
      results are returned in an array.

    - s2 Named-argument expressions | sec:building-functions-strings-named-expressions
      If a string begins with {\tt |}, then it is parsed as a named-argument function. For example:

      - javascript examples/named-argument-expressions.js << end
        d('|foo| foo + 1')      // => function (foo) {return foo + 1}
        d('|x, y| x + y * 2')   // => function (x, y) {return x + y * 2}
        d('|x| (|y| x + y)')    // => function (x) {return function (y) {return x + y}}
      - end

      A couple of macros are available for brevity. One expands expressions of the form {\tt @foo}, where {\tt foo} is some identifier, into {\tt this.foo}. (Using \verb|@| without a following
      identifier expands into {\tt this}.) The other provides shortcuts for {\tt call} and {\tt apply}: the operator \verb|#c| expands to {\tt .call}, and the operator \verb|#a| expands to
      {\tt .apply}. For example:

      - javascript examples/named-argument-expression-macros.js << end
        d('|foo| foo#c(@, @x)')         // => function (foo) {return foo.call(this, this.x)}
        d('|x, y| @x = x, @y = y')      // => function (x, y) {return this.x = x, this.y = y}
        d('|f, xs| f#a(f, xs)')         // => function (f, xs) {return f.apply (f, xs)}
      - end

      The {\tt @} prefix preserves {\tt this} in the context of a subfunction (that is, binds it to {\tt this} outside of the subfunction body). For example:

      - javascript examples/named-argument-expression-this.js << end
        d('|| @ === (|| @)()').call(true)         // => false
        d('|| @ === (@|| @)()').call(true)        // => true
      - end

      Note that the notation is unambiguous in practice. In JavaScript {\tt this} is always boxed, so expressions of the form {\tt this || x} are trivially {\tt this} and would never evaluate
      {\tt x}. Therefore, there is never a case where {\tt this || x} should be written, and thus the sequence \verb/@|/ always refers to the beginning of an inner function.\footnote{Spaces
      also disambiguate these cases further, since generally there are spaces in expressions but not on decorators.}

    - s2 Destructuring binds | sec:building-functions-strings-destructuring-binds
      Strings beginning with {\tt [} or \verb|{| are interpreted as pattern matches with bind variables. For example:

      - javascript examples/destructuring-binds.js << end
        d('[#x, #y, #z]')([1, 2, 3])
        // => {x: 1, y: 2, z: 3}

        d('{x: {y: {foo: #x}}}')({x: {y: {foo: 'bar'}}})
        // => {x: 'bar'}

        d('[1, 2, {bif: #x}, @#xs]')([1, 2, {bif: 3}, 4, 5])
        // => {x: 3, xs: [4, 5]}
      - end

      Basically, arrays and objects are both allowed as containers, and \verb|#| is used to mark a variable. The prefix \verb|@#| is used to mark a splice variable, which can occur either in
      array or object context; this picks up the remaining (unmatched) entries. The results are returned in a flat hash mapping variable names to matched values. Any variable called \verb|_|
      will match anything and be ignored; you can use it multiple times, in single or splice context. It's useful for things like indicating that an array has a bunch of useless stuff on the
      end.

      You can also put guards onto destructuring binds. For example:

      - javascript examples/destructuring-bind-guards.js << end
        d('[#x, #y] | x < y')([1, 2])   // => {x: 1, y: 2}
        d('[#x, #y] | x < y')([2, 1])   // => false
      - end

      If the match fails either due to structural or constraint problems, {\tt false} is returned. This has some convenient and inconvenient properties. The nice thing is that you won't get
      any errors if you ask for bound variables; they'll all just be {\tt undefined}.\footnote{Unless you've named one of them {\tt constructor} or something, but don't do that.} However, {\tt
      false} will still fail any boolean condition, so you can fall out gracefully. The only bad part is that you can't use the {\tt === undefined} or {\tt === null} check.

      Alternatives can be specified using {\tt ;}. For example:

      - javascript examples/destructuring-bind-alternatives.js << end
        d('[#x, #y] | x < y ; [#x, #y] | x > y')([1, 2])        // => {x: 1, y: 2}
        d('[#x, #y] | x < y ; [#y, #x] | x < y')([2, 1])        // => {x: 1, y: 2}
        d('[#x, #y] | x < y ; [#y, #x] | x < y')([1, 1])        // => false
      - end

      If multiple arguments are provided, the function returns the results from the first match that succeeds:

      - javascript examples/destructuring-bind-multiple.js << end
        d('[#x, 3, #y] | x == y')([1, 3, 5], [2, 3, 2]) // => {x: 2, y: 2}
      - end

    - s2 Terse-form stack functions | sec:building-functions-string-terse-stack
      Large positive and negative integer values (see sections \ref{sec:building-functions-large-positive-integers} and \ref{sec:building-functions-negative-integers}) implement a small
      stack-based command language. Within strings, however, many more characters are available. Strings beginning with {\tt x} are interpreted in this language, which contains as a subset the
      language used for hexadecimal integers. Whitespace within these strings is ignored. For example:

      - javascript examples/terse-form-stack-functions.js << end
        d([0x71a, 'x71a'])(5)           // => [6, 6]
        d([0xee,  'xee'])(1)            // => [1, 1]
      - end

      Using a string allows the entry of additional commands, described in the following sections:

      - s3 Control-flow commands | sec:building-functions-string-terse-control-flow
        - enumerate << end
          - item[] {\tt g}, {\tt G}
            Goto a label. The next character is the label name. Used with {\tt l}. For example, the string {\tt 'xlaga'} produces an infinite-loop function. The alias {\tt G} always refers to
            the \verb|_| label; for example, the string {\tt 'xLG'} is a quicker way to write an infinite-loop function.

          - item[] {\tt l}, {\tt L}
            Creates a named label. The syntax is {\tt lx}, where {\tt x} is some non-whitespace character. Labels can be gone to using {\tt g} or conditional branching. Label definitions are
            mutable (though I do not advise using them this way), so you can redefine them within a function as the function is running. The alias {\tt L} refers to an autogenerated label ID.
            The first one is \verb|_|, and subsequent ones are the digits 0 to 9, the lowercase letters, and then the uppercase letters.\footnote{Seriously, I hope this sentence is never that
            useful. I mean, who's going to use anything like 63 labels in a one-liner anyway?}

          - item[] {\tt t}, {\tt T}
            Jumps to a label if the stack top is truthy. (Doesn't modify the stack.) Its complement, {\tt T}, jumps to a label if the stack top is falsy. For example, the function \verb|Tnrlnn|
            returns its first argument if it's truthy and returns {\tt null} otherwise.\footnote{A shorter and more readable version of this function is {\tt n5b}.}

          - item[] {\tt r}, {\tt R}
            Returns immediately. The return value is whatever is on the top of the stack. The idiom {\tt ur} can be used to return nothing (analogous to \verb|return;|). The {\tt R} variant
            throws the stack top instead of returning it.
        - end

      - s3 Array commands | sec:building-functions-string-terse-array
        - enumerate << end
          - item[] {\tt Pn}
            Here {\tt n} is a single digit. This command pops {\tt n} items off of the stack and into an array, where the array's first element is the previous stack top. The array is then
            pushed onto the stack.

          - item[] {\tt p}
            Pops a number $n$ off of the top of the stack, and then pops $n$ more items off of the stack and pushes them onto an empty array. The array is then pushed. Analogous to {\tt P},
            but the number is determined at runtime.

          - item[] {\tt U}
            Unpacks the array on the top of the stack into stack entries. The first element in the array becomes the top of the stack.

          - item[] {\tt i}
            A zero-based generalized iota, similar to the iota in APL. Replaces the stack top $n$ with an array of consecutive integers from 0 to $n-1$. Distributes across arrays and object
            values. If the top is a string, then it is replaced with an array of right-handed substrings (e.g.~{\tt 'foo'} has right-handed substrings {\tt 'foo'}, {\tt 'oo'}, and {\tt 'o'}).
            Booleans, regular expressions, {\tt null}, and {\tt undefined} are wrapped in single-element arrays.

          - item[] {\tt \#}
            Pushes the size of the stack top onto the stack. The size of arrays and strings is obtained from the {\tt length} property, and the size of an object is the number of keys for
            which {\tt hasOwnProperty} is true. Numbers, booleans, regular expressions, {\tt null}, and {\tt undefined} have size 0.
        - end

      - s3 Typeclass commands | sec:building-functions-string-terse-typeclass
        The commands \verb|*|, \verb|+|, \verb|/|, \verb|%|, and \verb|^| are reserved for typeclasses that provide operator overloading.\footnote{See \Ref{chapter}{sec:typeclasses} for more
        information about typeclasses.} When you define a typeclass, you can define shorthands for various operations; these are alternative names that can be used in an overloaded-operator
        context.\footnote{Previously this was handled by a Divergence module called Rebase. Now operator overloading functionality is built into {\tt d}.}

      - s3 Value commands | sec:building-functions-string-terse-values
        - enumerate << end
          - item[] {\tt @}
            Pushes {\tt this} onto the stack.

          - item[] {\tt n}
            Pushes {\tt null} onto the stack.

          - item[] {\tt u}
            Pushes {\tt undefined} onto the stack.

          - item[] {\tt z}
            Pushes an empty array onto the stack. Equivalent to {\tt 70i}, but faster. For example, \verb|'xz5LV85a5t_'| takes an integer $n$ and returns an array $[n, n-1, n-2, \cdots, 1]$.

          - item[] {\tt Z}
            Pushes an empty object onto the stack.

          - item[] {\tt V}
            Decrement the item on the top of the stack. Works only for numbers.
        - end

      - s3 Quotation | sec:building-functions-string-terse-quotation
        - enumerate << end
          - item[] {\tt [n}, {\tt ]}
            Quotes a closure and pushes it onto the stack. Closures work by being preloaded with the first $n$ things from the enclosing stack. So, for example, the function {\tt '|x| (|y| x +
            y)'} can be written as {\tt 'x[1a]'}.
        - end

      - s3 Combinatory logic | sec:building-functions-string-terse-combinatory
        - enumerate << end
          - item[] {\tt K}
            Replace the stack top with a constant function returning the stack top. That is, $x \Rightarrow (\lambda y.x)$.

          - item[] {\tt I}
            Push the identity function onto the stack.
        - end

      - s3 Invocation | sec:building-functions-string-terse-invocation
        - enumerate << end
          - item[] {\tt v}
            {\tt stack[0].apply(null, stack[1])}. Pops both entries and pushes the result. The {\tt v} stands for ``variadic invocation''.

          - item[] {\tt A}
            {\tt stack[0].apply(stack[1], stack[2])}. Pops all three entries and pushes the result.

          - item[] {\tt B}
            Binds the stack top (as a function; if it is not a function, then it is run through {\tt d} first) to the next entry, pops both, and pushes the result. For example, {\tt
            'x72[0@]Bn5f'} returns 2. The inner function, \verb|[0@]|, is bound by the {\tt B} to the next entry down (the literal 2 pushed by {\tt 72}). Then we push {\tt null}, swap the
            function and the value, and invoke the function. It returns {\tt this}, which is 2.
        - end

      - s3 Unbound | sec:building-functions-string-terse-unbound
        - enumerate << end
          - item[] {\tt k}
          - item[] {\tt j}
          - item[] {\tt h}

          - item[] {\tt m}

          - item[] {\tt o}

          - item[] {\tt q}

          - item[] {\tt s}

          - item[] {\tt w}
          - item[] {\tt x}
          - item[] {\tt y}

          - item[] {\tt C}
          - item[] {\tt D}
        - end

  - s1 Regular Expressions | sec:building-functions-regular-expressions
    These are really simple; they just attempt to match against the input and return an array of matches if successful, {\tt null} otherwise. (This is identical to the behavior of {\tt
    exec()}.) There is a twist, though. The returned function is automatically homomorphic across arrays and object values, and if invoked on multiple arguments it concatenates their results.
    For example:

    - javascript examples/regular-expressions-homomorphic.js << end
      d(/foo/)('foo')                   // => ['foo']
      d(/foo/)(['foo', 'bar'])          // => [['foo'], null]
      d(/foo/)('foo', 'food')           // => ['foo', 'foo']

      d(/f(o)o/)('foo')                 // => ['foo', 'o']
      d(/f(o)o/)(['foo', 'bar'])        // => [['foo', 'o'], null]
      d(/fo(.)/)('foo', 'foad')         // => ['foo', 'o', 'foa', 'a']

      d(/foo/)({bar: 'foo'})            // => {bar: ['foo']}
      d(/foo/)({bar: 'bar'})            // => {bar: null}
    - end

  - s1 Booleans | sec:building-functions-booleans
    These are also very simple. {\tt true} and {\tt false} become functional decisionals. The exception is when one or more arguments are unspecified. In this case, they default to {\tt true}
    and {\tt undefined} respectively:

    - javascript examples/booleans.js << end
      d(true)(4, 5)             // => 4
      d(false)(4, 5)            // => 5
      d(true)()                 // => true
      d(false)()                // => undefined
    - end

  - s1 Arrays | sec:building-functions-arrays
    Arrays, just like in the original Divergence library, are homomorphic across {\tt d}.\footnote{The {\tt d} in question, of course, is the same {\tt d} that you called on the array. The
    same goes for objects (\Ref{section}{sec:building-functions-objects}). See \Ref{chapter}{sec:instances} for an explanation of why this is a relevant question.} For example:

    - javascript examples/arrays.js << end
      d([0x71, '.foo'])({foo: 'bar'})   // => [1, 'bar']
      d([0xee, '.foo'])({foo: 'bar'})   // => [true, 'bar']
      d([0xee, '.foo'])(null)           // => [false, null]
      d([0xa, 0xb, 0xc])(2, 3)          // => [5, -1, 6]
      d([])(1, 2, 3)                    // => []
    - end

  - s1 Objects | sec:building-functions-objects
    Same thing here. These are homomorphic across {\tt d} for values, so:

    - javascript examples/objects.js << end
      d({foo: 0x71a})(5)                  // => {foo: 6}
      d({two: 0x8ab, four: 0x74cb})(6, 7) // => {two: 5, four: 17}
      d({foo: '||@'}).call(5)             // => 5
    - end
__423ef2acb211939a073c075fc1f7e6b5

meta::section('builtin-transforms', <<'__4233f7a745c52b321c26c52de7d7d83f');
- sc Built-in Transforms | sec:builtin-transforms
  Divergence comes with a handful of transforms that are useful for working with JavaScript functions and data types. Some of them are standalone (e.g.~{\tt require}, {\tt ensure}), while
  others (e.g.~{\tt amap}, {\tt xlift}) are generated from a data structure. Divergence provides a framework for defining Haskell-style typeclasses and operations on their instances.

  - s1 Defining a Typeclass | sec:builtin-transforms-defining-a-typeclass
    Here is the definition for the {\tt foldable} typeclass:

    - javascript examples/foldable.js << end
      d.typeclass('foldable', 'fold', 'zero', 'merge', 'ret').define ({
        map:  '|f| @fold((@|x, y| @merge(x, @ret(f(y)))), @zero())',
        lift: '|f| @fold((@|x, y| @merge(x, f(y))), @zero())'});
    - end

    Here's how this works. First, we tell Divergence that we're defining a {\tt foldable} typeclass, and instances are assumed to provide implementations of {\tt fold}, {\tt zero}, {\tt
    merge}, and {\tt ret}. Then we proceed to define methods that we get for free, in this case {\tt map} and {\tt lift}.

    For arrays, {\tt map} can be defined in terms of {\tt fold} like this:

    - verbatim << end
      var map = function (xs, f) {
        return fold ([], xs, function (ys, x) {
          return ys.concat ([f(x)]);
        });
      };
    - end

    However, this definition works only for arrays. To generalize it, we need to remove all array-specific references. Here's what the code looks like in general form, where the extra
    parameter {\tt t} provides collection-specific methods:

    - verbatim << end
      var map = function (t, xs, f) {
        return t.fold (t.zero(), xs, function (ys, x) {
          return t.merge (ys, t.ret (f(x)));
        });
      };
    - end

    Now there is only one step left. We need to take a regular function and return a mapping function, but we don't have a collection yet. That is, instead of having a function {\tt map} that
    does this:

    - verbatim << end
      var ys = map(xs, f);
    - end

    \noindent we want {\tt map} to do this:

    - verbatim << end
      var ys = map(f)(xs);
    - end

    If {\tt fold} is already a function-transform, then we're all set. Here's how that works:

    - verbatim << end
      var map = function (t, f) {
        return t.fold (t.zero(), function (ys, x) {
          return t.merge (ys, t.ret (f(x)));
        });
      };
    - end

    All we've done here is curried out the {\tt xs} parameter at every level. Also notice that it isn't hard to get from the above definition of {\tt map} to what we have implemented in the
    {\tt foldable} typeclass.

    - s2 Making {\tt Array} foldable | sec:builtin-transforms-making-array-foldable
      The definition to make {\tt Array} an instance of {\tt foldable} isn't hard at all:

      - javascript examples/array-foldable.js << end
        d.instance(Array, 'foldable', {
          zero:  '||[]',
          merge: '|x, y| x.concat(y)',
          ret:   -0x77,
          fold:  function (f) {
            var args = arguments;
            return function (xs) {
              var start   = args.length === 2;
              var initial = start ? args[1] : xs[0];
              for (var i = start, l = xs.length; i < l; ++i)
                initial = f(initial, xs[i]);
              return initial;
            };
          }});
      - end

      The following functions are provided for each instance of {\tt foldable} (examples here are for arrays):

    - s2 {\tt amap} | sec:transforming-functions-transforms-amap
      Causes the function to be invoked componentwise across an array. This transform takes no parameters. For example:

      - javascript examples/amap.js << end
        d(0x71a, 'amap')([1, 2, 3, 4])          // => [2, 3, 4, 5]
        d(0x8a, 'amap')([1, 2, 'foo'])          // => [2, 4, 'foofoo']
        d(0xee, 'amap')(['foo', null])          // => [true, false]
        d(0xee, 'amap')([])                     // => []
        d(0x8c, 'amap')([1, 2, 3])              // => [1, 4, 9]
        d(-0x8c, 'amap')([1, 2, 3])             // => [[1], [4], [9]]
      - end

    - s2 {\tt alift} | sec:transforming-functions-transforms-alift
      Lifts a function into the array monad. More specifically, causes the function to be invoked componentwise across the array entries and the results, which should be arrays, are then
      concatenated. {\tt false}, {\tt undefined}, {\tt null}, and other falsy values are considered to be equivalent to empty arrays. For example:

      - javascript examples/alift.js << end
        d('|x| [x + 1]', 'alift')([1, 2, 3])            // => [2, 3, 4]
        d('|x| [x, x + 1]', 'alift')([1, 2, 3])         // => [1, 2, 2, 3, 3, 4]
        d('|x| x&1 && [x]', 'alift')([1, 2, 3, 4])      // => [1, 3]
        d([0], 'alift')([1, 2, 3])                      // => [1, 2, 3]
        d([0x71a, 0x8c], 'alift')([1, 2, 3])            // => [2, 1, 3, 4, 4, 9]
        d(-0x8c, 'alift')([1, 2, 3])                    // => [1, 4, 9]
        d([-0x8c], 'alift')([1, 2, 3])                  // => [[1], [4], [9]]
      - end

    - s2 {\tt afold} | sec:transforming-functions-transforms-afold
      Lifts a function into a left-fold over arrays. That is, calling your function on an array is equivalent to calling a traditional {\tt foldLeft} implementation on both your function and
      the array. For example:

      - javascript examples/afold.js << end
        d(0xa, 'afold')([1, 2, 3])              // => 6
        d(0xc, 'afold')([2, 3, 4])              // => 24
        d(0xa, 'afold')([1])                    // => 1
        d(0x18c0a, 'afold')([[], 1, 2, 3])      // => [1, 4, 9]
      - end

      You can also specify the first fold argument as a transform parameter:

      - javascript >> examples/afold.js << end
        d(0xa, {afold: 4})([1, 2, 3])           // => 10
        d(0x18c0a, {afold: []})([1, 2, 3])      // => [1, 4, 9]
      - end
__4233f7a745c52b321c26c52de7d7d83f

meta::section('instances', <<'__526d70f504043bd799844f03774c68eb');
- sc Instances | sec:instances
  Unlike before, Divergence isn't just one function. You can create a new instance of Divergence with its own configuration, which can be useful for isolated regions of code that require a
  particularly common pattern, unit tests, etc. The most common way to do this is to use {\tt new}:

  - javascript examples/instance-new.js << end
    new divergence (function (d) {
      // Code in here can access d, which is a copy of the global divergence.
      // To create a copy of d:
      new d (function (new_d) {
        // new_d is a copy of d, and will inherit any d-specific customizations
        // specified earlier.
      });

      // Another way to do it:
      d.clone (function (new_d) {
        // This is exactly the same as above, except that its return value is
        // intact.
      });

      // To grab the copy for later:
      var new_d = d.clone();
    });
  - end

  - s1 Return value of {\tt new} | sec:instances-return-value-of-new
    Because {\tt new} always returns a hash, not a function, using the {\tt new divergence(f)} constructor won't return either {\tt f}'s return value, nor will it return the new Divergence.
    Instead, it returns an object containing both. So, for example:

    - javascript examples/instance-new-return.js << end
      var result = new divergence (function (d) {
        d.foo = 'bar';
        return 5;
      });
      result.result             // => 5
      result.divergence.foo     // => 'bar'
    - end

    If you care about the return value of your function, it's probably easier to use {\tt divergence.clone}:

    - javascript examples/instance-clone-return.js << end
      var result = divergence.clone (function (d) {
        d.foo = 'bar';
        return 5;
      });
      result                    // => 5
    - end

    In this case there is no way to access the scoped {\tt d}, though you can return it explicitly if you want to hang on to it.

  - s1 Roles | sec:instances-roles
    Sometimes you want to keep a set of customizations around for reuse. You can do this by creating a {\em role}, which is simply a function that modifies a Divergence instance. For example,
    this role adds an {\tt assert} method to {\tt d}:

    - javascript examples/instance-role-assert.js << end
      divergence.role.create ('assert', function (d) {
        d.assert = function (what, message) {
          if (! what) throw new Error ('Assertion failed: ' + message);
          return what;
        };
      });

      d.assert          // => undefined
    - end

    Roles are attached to whichever Divergence instance they were created on. You can now use that role:

    - javascript examples/instance-role-use.js << end
      new divergence (function (d) {
        d.role.use ('assert');                  // Adds 'assert' to d in-place
        d.assert (3 === 3, 'basic math');       // => true
      });

      new divergence.using ('assert', function (d) {
        // d is a clone of divergence, but also with 'assert'
        d.assert (true, 'should pass');         // => true
      });

      divergence.role.use ('assert');           // Not a great idea; see next paragraph
      divergence.assert (1, 'truthy 1');        // => 1
    - end

    Roles can't be ``un-used'', so generally the best approach is to add a role to a copy of your divergence function.
__526d70f504043bd799844f03774c68eb

meta::section('introduction', <<'__d00ba9397d998926b90168ffe22f310a');
- sc Introduction | sec:introduction
  The original Divergence\footnote{\url{http://github.com/spencertipping/divergence}} has some shortcomings. For one thing, it puts a bunch of methods into the global prototype namespace
  (probably its biggest problem). This used to break jQuery, and now breaks jQuery UI's tab and accordion components.\footnote{Not that is has to in theory; someone made the assumption that
  all array methods would be {\tt dontEnum}, which isn't the case if you add stuff. The workaround is to use {\tt hasOwnProperty}, or more importantly, not to use {\tt for..in} on arrays.}
  Another problem is that macro definitions are permanent, unstructured, and collision-prone.

  This rewrite of Divergence solves both problems. The only object placed into the global namespace is called {\tt divergence}, and all customization is done to it or a copy of it. Macro
  definitions are scoped to a particular instance of Divergence; they are not global by default.

  - s1 Conventions | sec:introduction-conventions
    I'll often make reference to ``the {\tt d} function''. When I say this, I'm referring to either the global {\tt divergence} function or a customized clone of it. (The important thing is
    that it is one of a class of functions that ultimately come from {\tt divergence}; see \Ref{section}{sec:instances} if customization and cloning are unfamiliar.)

  - s1 Disclaimer | sec:introduction-disclaimer
    Divergence is dangerous for developers in a couple of ways. First, it might not work; I'm designing this library as an academic as much as a developer, so there will be times when I make
    impractical choices for the sake of some form of purity. Second, it gives developers many ways to do things, and few of them are at all readable. For example:

    - verbatim << end
      d(0x71a)          // Adds one to the first argument
      d(0x8ee5b)        // Returns first arg if truthy, false otherwise
      d(0x8c8c)         // Returns first arg to the fourth power
      d('xn5b')         // Returns first arg if truthy, null otherwise
      d('x[1]')         // K function
      d('x')            // Identity
      d(0)              // Identity
      d('x#p')          // Returns arguments[] as an array
      d('x68t_R')       // Returns second argument if truthy, throws it otherwise
    - end

    To be fair, each of these functions can be written more readably (in the same order as above):

    - verbatim << end
      d('|x| x + 1')
      d('|x| x || !!x')
      d('|x| x*x*x*x')
      d('|x| x || null')
      d('|x| (|y| x)')
      d('|x| x')
      d('|| arguments[0]')
      d('|| Array.prototype.slice.call (arguments)')
      function (x, y) {
        if (y) return y;
        else   throw y;
      }
    - end

    Divergence isn't there to make code readable in the small, however. Its purpose is to make easy things really easy, and to make some hard things easier. It does this by helping you
    condense your code semantically; things that are unrelated to your core logic can be packed into very few characters and peripherally mentioned, while core logic can occupy most of the
    code space. For example:

    - verbatim << end
      var variable = function (name) {
        this.name  = name;
        this.value = undefined;
      };
      variable.prototype.assign = function (v) {
        this.value = v;
        return this;
      };
    - end

    Using Divergence you could write this instead:

    - verbatim << end
      var variable = d('|name| @name = name, @value = undefined');
      variable.prototype.assign = d('|value| @value = value, @');
    - end

    Notice that the mundane code takes up less space, and the definitions relatively more. That's what Divergence was built to do.
__d00ba9397d998926b90168ffe22f310a

meta::section('main', <<'__73fea24ef317f657479473f9542878ea');
- documentclass report
- include resource::header

- title  Divergence Improved
- author Spencer Tipping

- document << end
  - maketitle
  - tableofcontents

  - sp Using Divergence
  - include section::introduction
  - include section::building-functions
  - include section::transforming-functions
  - include section::builtin-transforms
  - include section::typeclasses
  - include section::instances

  - sp Extending Divergence
- end
__73fea24ef317f657479473f9542878ea

meta::section('transforming-functions', <<'__9f88ee1fe2236dd300295b17f3d02ce1');
- sc Transforming Functions | sec:transforming-functions
  As explained in \Ref{chapter}{sec:building-functions}, you can use Divergence to build functions from values. However, that occupies only one parameter; {\tt d} can accept more. Parameters
  after the first are used to modify the function being generated. So, for example, consider the following invocation:

  - verbatim << end
    d(0x748cc, 'amap', {suchThat: '|f| f([1])[0] === 16',
                          ensure: '|xs| xs.constructor === Array',
                         require: '|xs| xs.constructor === Array'});
  - end

  {\tt 0x748cc} is the initial function (which multiplies its first argument by 16; see \Ref{section}{sec:building-functions-large-positive-integers} for details), {\tt 'amap'} is a nullary
  transformation that lifts the function to distribute componentwise across arrays, and the following object contains a list of transforms to be applied in arbitrary order. In this case, {\tt
  suchThat} is an in-place unit test, {\tt ensure} is a postcondition, and {\tt require} is a precondition. The resulting function would look something like this:

  - verbatim << end
    function (xs) {
      if (! (xs.constructor === Array)) throw new Error (...);
      var result = [];
      for (var i = 0, l = xs.length; i < l; ++i)
        result.push (16 * xs[i]);
      if (! (result.constructor === Array)) throw new Error (...);
      return result;
    }
  - end

  In addition, this code would be run at function-definition time:

  - verbatim << end
    // Here, f is the above function
    if (! (f([1])[0] === 16)) throw new Error (...);
  - end

  Obviously a lot has happened to the original function and the intermediate structures. Divergence keeps functions in intermediate format until all of the transformations have been run, and
  compiles the function into native JavaScript just before returning it. This transformation step isn't primitive; it's a customization that is built into the default copy of Divergence and
  inherited.

  - s1 Arrays | sec:transforming-functions-arrays
    Array transformation arguments are treated as argument list manipulators (\verb|flat_compose| in the original Divergence). They are homomorphic across {\tt d} and let you do things like
    changing argument order, deleting arguments, and transforming them. For example:

    - javascript examples/array-transforms.js << end
      d(0xb)(5, 4)                              // => 1
      d(0xb, [1, 0])(5, 4)                      // => -1
      d(0xb, [0x8a, 1])(5, 4)                   // => 6
      d(0xd, [1, 2])(0, true, 'constructor')    // => function Boolean () {...}
    - end

  - s1 Numbers | sec:transforming-functions-numbers
    Numbers are run through {\tt d} and composed normally. It's often useful to use negative integers for quick argument swapping. For example:

    - javascript examples/number-transforms.js << end
      d(0xa)(1, 3)              // => 4
      d(0xe, 0xa)(1, 3)         // => -4
      d(0, 0xb)(4, 2)           // => 2
      d(0xb, -0x10)(4, 2)       // => -2
    - end

  - s1 Regular expressions | sec:transforming-functions-regular-expressions
    These are composed normally, and are most useful when you expect a string as input. For example:

    - javascript examples/regexp-transforms.js << end
      d(0x6a, /(.)foo(.)/)('afoob')             // => 'ab'
      d(0xd, /foobar(length)/)('foobarlength')  // => 12
      d(0xee, /foobar/)('foo')                  // => null
    - end

    If the regular expression fails to match, the function is never executed and {\tt null} will be returned. Normal regular-expression rules apply for array or multiple arguments.

  - s1 Generalized transforms | sec:transforming-functions-generalized-transforms
    Strings and objects are used to specify generalized transforms. These are arbitrary functions that can transform the function you're building. In the example above, {\tt suchThat}, {\tt
    require}, {\tt ensure}, and {\tt amap} are all such transformations. For example, these are all equivalent (modulo order in the second case):

    - verbatim << end
      d(0x71a, 'amap', 'vlift')
      d(0x71a, {amap: null, vlift: null})
      d(0x71a, 'amap', {vlift: null})
      d(0x71a, {amap: null}, 'vlift')
    - end

    Divergence comes with several generalized transforms, and you can write your own. The built-in transforms are described in \Ref{chapter}{sec:builtin-transforms}.

  - s1 Strings | sec:transforming-functions-strings
    If a string doesn't match one of the defined generalized transforms, then it is interpreted as a string function (see \Ref{section}{sec:building-functions-strings}) and is expected to
    return an array to be used as the function's argument list. For example:

    - javascript examples/string-transforms.js << end
      d(0xa, '|x, y| [x, 2*y]')(3, 4)           // => 11
      d(0, '|x, y| [y]')(3, 4)                  // => 4
      d(0, '|x, y| [x]')(3, 4)                  // => 3
      d(1, '|x, y| [x, y]')(3, 4)               // => 4
    - end

  - s1 Functions | sec:transforming-functions-functions
    A function is used on the argument list and is expected to return an array of new arguments. For example:

    - javascript examples/function-transforms.js << end
      d(0xa, d(-0xc))(4, 5, 6)                  // => 26
      d(0xb, d('|x| [x, x]'))(5)                // => 0
      d(0xc, d('|x| [x, x]'))(5)                // => 25
    - end
__9f88ee1fe2236dd300295b17f3d02ce1

meta::section('typeclasses', <<'__968c7c95a542d4b382c01bc184674a4b');
- sc Typeclasses | sec:typeclasses
  Adding functionality to default constructs such as arrays and objects is difficult, especially in a dynamically-typed language with poor global containment. Divergence doesn't have a great
  solution to this, but it avoids global namespace pollution. The idea is that you define typeclasses in Haskell style, and then promote types into those typeclasses later on. When you want to
  use functionality provided by a typeclass, you do so by lifting a function into an operator over instances of that typeclass. In other words, rather than focusing on the values you instead
  focus on the functions that manipulate those values.

  Here's a simple example of the difference:

  - javascript examples/array-map-traditional.js << end
    var mapped = my_array.map (d('|x| x + 1'));
  - end

  The reason this example works is that JavaScript does dynamic dispatch on the {\tt map} method based on the prototype of \verb|my_array|. However, since {\tt Array} is global, we can't
  modify it.

  - javascript examples/array-map-typeclass.js << end
    var mappable = d.typeclass(...);
    var mapped   = d('|x| x + 1', mappable.map)(my_array);
  - end

  Here, Divergence has to decide how to lift the function. It's a runtime-dispatch decision just as it was before, but this time the type-selection logic happens in library-space. This lets
  Divergence compile a custom version of the function for that data structure (if the \verb|specialize_typeclass_functions| and \verb|inline_typeclass_members| compiler options are set). Note
  that the type selection logic isn't blazingly fast; constructor functions are first hashed by their {\tt toString()} output, and then a referential comparison is done on the identity. So,
  for example, if we want to lift a function using {\tt map}, and the {\tt mappable} typeclass contains {\tt Array} and {\tt Object}, then this is the process when that function is invoked:

  - enumerate << end
    - item Find the constructor of the first argument.
    - item Invoke {\tt toString()} on the constructor to obtain its source code.
    - item Look up that string in the {\tt mappable.instances} hashtable. This returns an array of pairs.
    - item Find the constructor in that array and retrieve the second element of the pair (the instance method table).
    - item Invoke the element's {\tt map} method on the original function, and invoke that result on the first argument.
    - item Repeat this process for each additional argument.
  - end

  If there are few instances or each instance has a short and unique constructor, then this won't be a slow operation. The problem arises when there are a bunch of instances with identical
  constructor code, or code that is very long. In that case, using typeclasses will be computationally expensive.\footnote{And unfortunately there is no way to memoize the process, since
  JavaScript references are opaque.}

  - s1 Defining a typeclass
    Divergence doesn't keep a registry of typeclasses. A typeclass is just another value, and you can modify it using standard method calls. For example, here is a typeclass definition:

    - javascript examples/defining-the-mappable-typeclass.js << end
      var mappable = d.typeclass({
    - end
__968c7c95a542d4b382c01bc184674a4b

meta::template('comment', '\'\';     # A mechanism for line or block comments.');
meta::template('eval', <<'__7be1d470a07a06c58e971bc7fc24c048');
my $result = eval $_[0];
terminal::message('warning', "Error during template evaluation: $@") if $@;
$result;
__7be1d470a07a06c58e971bc7fc24c048

meta::template('failing_conditional', <<'__b49f2ffe1cfefb36b1eabd7abd7b3bb6');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::message('warning', "eval of template condition failed: $@") if $@;
$should_return;
__b49f2ffe1cfefb36b1eabd7abd7b3bb6

meta::template('include', <<'__e0624844a65ae41e0217dd871fc0dbfb');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__e0624844a65ae41e0217dd871fc0dbfb

meta::template('item[]', '"\\\\item[$_[0]]";');
meta::vim_highlighter('cltex', <<'__5bfc80e1a2ad3bb7cb4f57ff906d71b0');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX with support for a bunch of embedded languages)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match   cltEofMarker   /<<\s*\w\+/ contained
syn region  cltLineComment matchgroup=cltCode start=/^\s*- comment / end=/$/ contained
syn match   cltLine        /^\s*- .*$/ contains=cltEofMarker,cltLineComment

syn include @cpp           syntax/cpp.vim        | unlet b:current_syntax
syn include @java          syntax/java.vim       | unlet b:current_syntax
syn include @asm           syntax/asm.vim        | unlet b:current_syntax
syn include @javascript    syntax/javascript.vim | unlet b:current_syntax
syn include @html          syntax/html.vim       | unlet b:current_syntax

syn region  cltCpp         matchgroup=cltCode start=/^\z(\s*\)- cpp .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@cpp
syn region  cltJava        matchgroup=cltCode start=/^\z(\s*\)- java .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@java
syn region  cltAsm         matchgroup=cltCode start=/^\z(\s*\)- asm .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@asm
syn region  cltJavascript  matchgroup=cltCode start=/^\z(\s*\)- javascript .*<<\s*\z(\w\+\)$/ end=/^\z1- \z2$/ contains=@javascript
syn region  cltHtml        matchgroup=cltCode start=/^\z(\s*\)- html .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@html
syn region  cltResource    matchgroup=cltCode start=/^\z(\s*\)- resource .*<<\s*\z(\w\+\)$/   end=/^\z1- \z2$/
syn region  cltComment     matchgroup=cltCode start=/^\z(\s*\)- comment .*<<\s*\z(\w\+\)$/    end=/^\z1- \z2$/

syn cluster cltStuff       add=cltCpp,cltJava,cltAsm,cltJavascript,cltHtml,cltResource,cltComment,cltLine

syn region  cltDocument    start=/\%^/ end=/\%$/ contains=@cltStuff

hi link cltLine            Special
hi link cltKeyword         String
hi link cltResource        String
hi link cltEofMarker       String

hi link cltCode            Special
hi link cltDocument        Comment
hi link cltComment         Type
hi link cltLineComment     Type

let b:current_syntax = "cltex"
__5bfc80e1a2ad3bb7cb4f57ff906d71b0

internal::main();

__END__