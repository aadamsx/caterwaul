sdocp('sdoc::js::shell', 'Caterwaul interactive shell | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis page provides the user with an interactive way to execute Caterwaul code. It compiles code, shows macroexpansions, and allows the user to inspect return values in some detail. If I\'ve\ndone my job correctly, it should be useful to (1) learn Caterwaul, and (2) drop onto a webserver to have a quick and powerful way to access APIs for troubleshooting.\n\nUI structure.\nLike most REPLs, this interface provides a prompt and a history area. Unlike most REPLs, though, the interface macroexpands the user\'s code in realtime. It also maintains a list of variables\ndefined by the user and lets the user interactively inspect objects, arrays, and other values.\n\nshell = caterwaul.clone(\'std format seq continuation montenegro\')(function (options) {\n  options = options || {};\n\n  return html[div.shell(div.log(prompt))],\n\n  where*[caterwaul_global = caterwaul.clone(\'std seq continuation opt montenegro parser\'),\n\n         input_syntax_check_delay = options.syntax_check_delay   || 30,\n         up_arrow_keycode         = options.history_up_keycode   || 38,\n         down_arrow_keycode       = options.history_down_keycode || 40,\n\n         prompt = html[div.prompt(input.input.fixed.large, pre.macroexpansion.fixed.large *readonly(\'true\'))]\n                  /se.p[p.find(\'.input\').keyup(restart_timer).\n                                         keyup(fn[e][navigate_through_history(e), when[e.which === up_arrow_keycode || e.which === down_arrow_keycode]]).\n                                         enter_key(fn[e][result($(this).val())]),\n\n                        where*[edit_history                = seq[~[]],\n                               edit_index                  = 0,\n\n                               event(name)                 = l[f = options[name]][f && f.apply(this, seq[~arguments].slice(1))],\n\n                               navigate_through_history(e) = e.which === up_arrow_keycode ? history_up() : history_down(),\n                               history_up()                = edit_index > 0                   && stash_current_entry() && load_new_entry(edit_index - 1),\n                               history_down()              = edit_index < edit_history.size() && stash_current_entry() && load_new_entry(edit_index + 1),\n                               history_append(text)        = edit_index = edit_history.push(text).size(),\n                               stash_current_entry()       = edit_history /se[_[edit_index] = p.find(\'.input\').val(), when[edit_index < _.size()]],\n                               load_new_entry(index)       = p.find(\'.input\') /se[_.val(edit_history[edit_index = index] || \'\')],\n\n                               timer                       = null,\n                               do_timer_action()           = l[expanded = macroexpand(p.find(\'.input\').val())][event(\'macroexpansion\', expanded), p.find(\'.macroexpansion\').text(expanded)],\n                               restart_timer()             = timer /se[_ && clearTimeout(_), timer = setTimeout(do_timer_action, input_syntax_check_delay)],\n\n                               syntax_errors(s)            = s ? unwind_protect[e.toString()][new Function(\'return (#{s})\') && \'\'] : \' \',\n                               macroexpand(code)           = syntax_errors(code) || caterwaul.format(caterwaul_global(caterwaul.parse(code))),\n\n                               result(text)                = compile_into_function(text) /se[_ ? accept_input(text, _) : reject_input()],\n                               compile_into_function(text) = unwind_protect[false][caterwaul_global(\'function () {return (#{text})}\')],\n\n                               accept_input(text, f)       = run_user_input(text, f) /se[history_append(text), clear_fields(), event(\'input_accepted\', text, f)],\n                               bombproof_execute(f)        = unwind_protect[{error: e}][{result: f()}],\n                               clear_fields()              = p.find(\'.input, .macroexpansion\').val(\'\').text(\'\'),\n                               run_user_input(text, f)     = l[result = bombproof_execute(f)][log_user_input(text), result.error ? log_error(result.error) : log_value(result.result)],\n\n                               reject_input(f)             = event(\'input_rejected\', f),\n\n                               adjust_scrolling()          = p.up(\'.shell\').scrollTop(l[h = p.up(\'.shell\').height()] in p.parent().height() - h * 5/3),\n                               after_log()                 = event(\'appended_to_log\') /se[setTimeout(adjust_scrolling, 0)],\n\n                               log_error(e)                = p.before(html[div.error(pre.fixed /text(e.toString()))])                      /se[after_log()],\n                               log_user_input(s)           = p.before(html[div.input(pre.fixed /text(s))])                                 /se[after_log()],\n                               log_value(v)                = p.before(html[div.value(pre.fixed /text(v == null ? \'\' + v : v.toString()))]) /se[after_log()]]]]});');