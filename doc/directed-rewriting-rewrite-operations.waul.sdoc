Rewriting operations.
The idea here is to focus on specific rewriting operations and various ways they could be efficiently implemented. match() and replace() are a great start, though the intermediate object can
(and should!) be bypassed by fusing the two. Further, each pattern can match with an ad-hoc algorithm; this allows the matching code to be expanded in-place.

| 'replacement'.qs /~replace/ 'pattern'.qs.match(tree) /!@

There are two main things that slow down rewrites. One is the fact that most rewrites end up being applied recursively; it helps to be able to reject things quickly, or at least to be able to
determine that a subtree does not contain the symbol that you're looking for. Bloom filters are a great way to do this, especially when the match target contains a symbol that is unusual.

The other large performance aspect is diving into a non-matching tree. This happens quite frequently and will not be prevented by Bloom filter checks. For example:

| '_x + y'.qs.match('q + t'.qs)

Here, three length checks, two string compares, and ten pointer dereferences must be performed before it is determined that no match is possible. With hashing, this could be reduced to one
'and', one compare, and three pointer dereferences (two for the hashes, one for the hash mask of the pattern).
