\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}

\lstnewenvironment{resourcecode}{}{}

\title{Caterwaul By Example}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}

\chapter{Introduction}\label{sec:introduction}
  Caterwaul streamlines Javascript. It was designed both to minimize the ergonomic overhead associated with common edits, and to make it possible to express complex algorithms in a reasonable
  amount of space. It uses several ideas foreign to Javascript, some of which I've never seen used elsewhere:

\begin{enumerate}
\item{High reliance on operator precedence and associativity as a form of general-purpose grouping.}
\begin{verbatim}
jquery [div.foo]
-se- it.addClass('bar') /when.bif

//   ^----------------^ <- scope of /when.bif due to operator precedence
\end{verbatim}

\item{Edit-conscious design that minimizes the number of jumps for common editing patterns.}
\begin{verbatim}
return Math.abs(x - y -se- console.log(it));

//                    ^------------------^
// one continuous editing motion to introduce a side-effect on this
// subexpression
\end{verbatim}

\item{Compact function definition syntax that encourages granular abstraction.}
\begin{verbatim}
log(level, message) = console.log('#{new Date} #{level}: #{message}'),
info(message)       = log('INFO', message),
debug(message)      = log('DEBUG', message),
error(message)      = log('ERROR', message)
\end{verbatim}

\item{Front-focusing constructs such as {\tt where[]} that allow the implementation to follow the definition.}
\begin{verbatim}
choose(n, k) = fact(n) / (fact(k) * fact(n - k))
               -where [fact(x) = x ? x * fact(x - 1) : 1]
\end{verbatim}
\end{enumerate}

  Because Caterwaul is written as a pure Javascript library, it maintains complete compatibility with Javascript as a language. Most of the reason for this is that Caterwaul is a syntactic
  transform only; specifically, it is a function over Javascript functions:

\begin{verbatim}
var my_compiler = caterwaul();
var f = function () {...};
var g = caterwaul(f);
g();
\end{verbatim}

  While being compatible in a technical sense, however, Caterwaul also changes the difficulty of various tasks with respect to one another; the result, in my experience, is that Javascript is
  written very differently.

\section{How's the learning curve?}
    Caterwaul is relatively straightforward, certainly much simpler than complex functional languages such as Scala, OCaml, Haskell, Clojure, or others. However, it is also subtle and requires
    a fairly solid knowledge of Javascript's expression grammar. It's for this reason that I characterize the learning curve as being similar to Lisp or first-class
    continuations:\footnote{This is a reference to something a professor said in college. When asked about Lisp, he said ``the learning curve is an overhang.''}

\begin{verbatim}
                  _______________
                  \
                   \_  Caterwaul
                     \  learning
                      \    curve
                      |
                  ?   \
                _O_    \
Programmer ->    |      \
                / \ _____|
\end{verbatim}

    It's not actually quite this bad. It took me about two weeks to understand how to use Caterwaul after I wrote it. The benefit of using it on a regular basis is that I now have a much
    greater understanding and appreciation for Javascript, and it's significantly changed the way I see programming languages. I imagine the same would be true of anyone who learns Caterwaul.

\chapter{List of Primes}\label{sec:list-of-primes}
  It's rare that you actually need to generate a list of primes in production code, but this problem makes a good programming language example. The goal here is to write a web page that ends
  up showing the user a list of primes below 10,000.

\section{Preparing the HTML}
    The first step, assuming that we want to iterate rapidly, is to create a basic HTML document that loads Caterwaul and our application source code:

\lstset{caption={examples/primes/index.html},name={examples/primes/index.html}}\begin{resourcecode}
<!doctype html>
<html>
  <head>
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.std.js'></script>
  <script src='primes.js'></script>
  </head>
  <body></body>
</html> \end{resourcecode}

    Caterwaul's core and the {\tt std} module don't depend on jQuery. I'm just including it here so that we can easily do things when the page is loaded.

\section{Invoking Caterwaul}
    Caterwaul is a Javascript compiler written in Javascript. So to use it, you just hand your function to Caterwaul and run the function it gives you back. Here's an example of this behavior:

\begin{verbatim}
// Use an unconfigured caterwaul compiler; this has no effect:
var f = function (x) {return x + 1};
var g = caterwaul(f);

// Use all known Javascript extensions:
var f2 = function (x) {return y, where[y = x + 1]};
var c  = caterwaul.js_all();      // Returns a configured compiler
var g2 = c(f2);
\end{verbatim}

    Most Javascript apps have a surrounding lexical closure to create a local scope, so you can save some space by transforming the function inline:

\begin{verbatim}
caterwaul.js_all()(function () {
  // app code
})();

// If using jQuery:
$(caterwaul.js_all()(function () {
  // app code
}));
\end{verbatim}

    We're using jQuery, so our app will look like the second function here.

\section{Application code}
    Here's a Caterwaul app that computes our list of primes and shows it to the user:

\lstset{caption={examples/primes/primes-first.js},name={examples/primes/primes-first.js}}\begin{resourcecode}
$(caterwaul.js_all()(function () {
  var is_prime = function (x) {
    for (var i = 2; i * i <= x; ++i)
      if (x % i === 0)
        return false;
    return true;
  };

  var list = [];
  for (var i = 2; i < 10000; ++i)
    if (is_prime(i))
      list.push(i);

  $('body').text(list.join(', '));
})); \end{resourcecode}

    Caterwaul is a superset of Javascript,\footnote{Not technically true, but this is generally the case in practice. Caterwaul's syntax makes use of the uncommon edge cases of Javascript
    syntax, so it is unlikely to collide with regular code.} so this example behaves exactly as we'd expect. However, it doesn't look particularly special. Using Caterwaul idioms and
    refactoring a bit, we get this:\footnote{Thanks to Jeff Simpson for pointing out a bug here! I had previously written {\tt composite(n) = n[2, Math.sqrt(n)]}, which has an off-by-one error
    since it stops before reaching $\sqrt n$. It's necessary to use an inclusive upper bound to make sure that we get squares as well as other factors.}

\lstset{caption={examples/primes/primes.js},name={examples/primes/primes.js}}\begin{resourcecode}
$(caterwaul.js_all()(function () {
  $('body').text(primes.join(', '))
  -where [
    composite(n) = ni[2, Math.sqrt(n)] |[n % x === 0] |seq,
    primes       = n[2, 10000] %!composite -seq];
})); \end{resourcecode}

    This code probably looks like voodoo, but it's actually not that complicated. There are two things happening here that aren't in regular Javascript. First, the {\tt where[]} construct
    binds variables within an expression. Second, the {\tt seq} modifier is deeply mysterious and somehow condenses five or six lines of code into two.

    {\tt where[]} is used when you want to locally bind something. For example:

\begin{verbatim}
alert(x)     -where [x = 10];
alert(f(10)) -where [f(x) = x + 1];
\end{verbatim}

    This is translated into a local function scope that gets called immediately:

\begin{verbatim}
(function () {
  var x = 10;
  return alert(x);
})();

(function () {
  var f = function (x) {return x + 1};
  return alert(f(10));
})();
\end{verbatim}

    You'll notice that there's a little bit of magic going on to let you say {\tt f(x) = x + 1}. This is not explicitly handled by {\tt where[]}; instead, Caterwaul has a macro that rewrites
    things that look like {\tt x(y) = z} into \verb|x = function (y) {return z}|. Because this rule is applied globally, you can also use it to create methods or reassign existing functions:

\begin{verbatim}
jQuery.fn.size() = this.length;
\end{verbatim}

    Because it's recursive, you can create curried functions by providing multiple argument lists:

\begin{verbatim}
alert(f(1)(2)) -where [f(x)(y) = x + y];

// Is compiled to:
(function () {
  var f = function (x) {
    return function (y) {
      return x + y;
    };
  };
  return alert(f(1)(2));
})();
\end{verbatim}

    A reasonable question is how {\tt where[]} knows how much code should be able to see the variables you're binding. The answer has to do with its prefix: {\tt where} is what's known as a
    modifier, and all modifiers have an accompanying operator that has a precedence. For example, in the expression {\tt x * y -where[...]} the {\tt where} clause binds over the
    multiplication, since the minus has lower precedence. Writing it as {\tt x + y /where[...]} causes only {\tt y} to have access to the {\tt where} variables.

    {\tt seq} is the macro that is more interesting in this prime-generator example. It's a mechanism that writes all different kinds of {\tt for} loops. In this case we're using it in two
    places. The first time is in the {\tt composite()} function, where we use it to detect factors:

\begin{verbatim}
composite(n) = ni[2, Math.sqrt(n)] |[n % x === 0] |seq
\end{verbatim}

    First, we use {\tt ni[]} to generate an array of numbers between 2 and {\tt Math.sqrt(n)}, inclusive. {\tt ni[]} (with square brackets) is a syntax form, not a function; so it won't collide
    with the variable {\tt n} that we take as a parameter. The next piece, \verb+|[n % x === 0]+, has two parts. The pipe operator, which normally performs a bitwise-or, means ``there exists''
    in sequence context. Its body, \verb|n % x === 0|, is then evaluated for each element ({\tt seq} calls the element {\tt x}). So at this point we're asking, ``does there exist an integer
    {\tt x} for which {\tt n \% x} is zero?'' We tack the \verb+|seq+ onto the end to cause the preceding expression (in this case, everything back to the {\tt =}) to be interpreted by the
    {\tt seq} macro. {\tt seq} is a modifier just like {\tt where[]}, though {\tt seq} doesn't take parameters.

    The other use of {\tt seq} is to retrieve all numbers that are not composite:

\begin{verbatim}
primes = n[2, 10000] %!composite -seq
\end{verbatim}

    {\tt n[]} is doing the same thing as {\tt ni[]}, but doesn't include its upper bound. After it is {\tt \%}, which is the filter operator. So we're filtering down to only the elements which
    are not composite. The filter prefix is \verb|%|, and the \verb|!| modifier negates the condition. Because there's already a function defined, I use that instead of writing out a block.
    I'm using a higher-precedence prefix for {\tt seq} as a matter of convention; I default to using a minus unless there's a reason to use something else.

\chapter{This is Hideous!}\label{sec:this-is-hideous}
\begin{quote}
\verb|o %k%~!f %v*!~[x /!g] -seq|
\hfill \textit{-- valid Caterwaul code}
\end{quote}

  A fair point. I certainly didn't design Caterwaul to look nice.\footnote{Otherwise it would be called something besides Caterwaul.}

\section{Linear edits}
    Seek time is a large burden for programmers, just as it is for mechanical hard drives. Programmers are extremely productive when they are able to type a continuous stream of text without
    jumping around. For instance, consider the amount of programmer-effort required to implement this edit:

\begin{verbatim}
// Update this function to log the square of the distance:
var distance = function (x1, x2, y1, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx*dx + dy*dy);
};
\end{verbatim}

    This is a moderate-effort change. The expression {\tt dx*dx + dy*dy} must be factored into a variable, then the variable must be typed twice, and logging code must be added. The steps
    probably look about like this:

\begin{verbatim}
return Math.sqrt(dx*dx + dy*dy);
                 ^-----------^    <- select this region and cut

var d = <paste>;                  <- type this, with a paste

console.log(d);                   <- type this on a new line

return Math.sqrt(d);              <- navigate to sqrt() and type 'd'
\end{verbatim}

    If you time yourself making this edit, I'm guessing it will take on the order of five or ten seconds. I doubt that it would ever become a one or two second edit even with practice. Now
    consider what this edit looks like using Caterwaul:

\begin{verbatim}
return Math.sqrt(dx*dx + dy*dy);
                              ^   <- move insertion point here

-se- console.log(it)              <- type this
\end{verbatim}

    This edit can easily be made in about two seconds because it is mostly linear. This is really important! It isn't just about saving a few seconds here and there; every jump and every
    keystroke is a potential point of failure within the edit process. If, for example, you had ended up making this edit the first time (I've done things like this on many occasions without
    thinking):

\begin{verbatim}
var distance = function (x1, x2, y1, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  var d = dx*dx + dy*dy;
  console.log(d);
  return Math.sqrt(dx);
};
\end{verbatim}

    You might then be wondering why the function was returning bad results despite logging the right thing. It could easily turn into a 60 or 120-second bug-hunt. This is the kind of thing
    that saps productivity and demoralizes programmers, and this is exactly what Caterwaul was designed to overcome.

\subsection{How Caterwaul does this}
      I thought a lot about this problem before deciding on the current notation. Infix operators are obviously a step in the right direction (the worst offender is Lisp, which requires at
      least one jump for every significant edit). These operators are organized by common-use precedence, since it was far more common to add products than to multiply sums, for instance. In a
      sense, this is a very ergonomic Huffman-style coding of common practice.

      Perhaps a less commonly recognized feature of infix operators is that you can easily determine how much code to grab with one continuous edit. For example, suppose I'm editing the code
      below and want to conditionalize the side effect on truthiness:

\begin{verbatim}
foo() -se- console.log(it)
      -re- it.bar()
\end{verbatim}

      I don't want to use short-circuit logic, since this has far lower precedence than minus. I also don't want to use a minus, since it left-associates (meaning that any modifier I used
      would grab everything back to the {\tt foo()} invocation). Rather, I need a {\tt /} prefix, which will modify only the log expression:

\begin{verbatim}
foo() -se- console.log(it) /when.it
      -re- it.bar()
\end{verbatim}

      The alternative to choosing an operator is to add explicit grouping. This, however, requires a jump and decreases readability, which I complain about in more detail in the next section:

\begin{verbatim}
foo() -se- (it && console.log(it))
           ^-----^               ^      <- two edit points
\end{verbatim}

\section{Silly parentheses}
\begin{quote}
{\tt ... get)) add) button)))))))))))}
\hfill \textit{-- Lisp}
\end{quote}

    Relying on operator precedence for grouping has another beneficial side effect: It reduces the infamous Lisp problem of trailing parentheses.

    Parentheses and other grouping constructs are hard for humans to parse unless they have some other kind of reinforcement such as indentation or differentiated brackets. For example, this
    code requires a lot of effort to understand:

\begin{verbatim}
sum(product(join(x, y)), fix(z(t), z()), a(b(c), d, e))
\end{verbatim}

    I think this has something to do with our natural language being primarily infix:~subject-verb-object. Infix is simple because there is an implicit limit to how much stuff you can group
    together. If you're adding stuff, all you have to worry about is multiplication and more addition. You don't have to count parentheses to keep track of when an expression ends.

    So while parentheses and other explicit grouping constructs are more versatile and computationally pure, they can impose a lot of conceptual overhead. This, along with the ergonomic
    advantage of infix operators, was a large influence on Caterwaul's macro design.

\section{Keystrokes}
    Some things are easier to type than others. For example, it's far easier to type a dot than it is to type a caret. Part of it is frequency of use, but another part of it is layout.
    Caterwaul is optimized to avoid using the shift key for common cases, since this is a large cause of typos (for me, anyway). This is why it uses \verb|/| and \verb|-| instead of \verb|*|
    and \verb|+|.

    This is also why all of its identifiers use lowercase and generally avoid underscores. The shift key produces its own set of typos, including:

\begin{verbatim}
aNameWithcaps             <- missed shift
aNAmeWithCaps             <- doubled shift
\end{verbatim}

    There's another issue though. The shift key generally occupies the hand opposite of the one typing the character. So, for instance, typing a {\tt +} or a {\tt *} would use the right
    index/middle or ring/pinky along with the left pinky on the shift. However, most Caterwaul modifiers begin with a letter typed by the left hand:

\begin{verbatim}
where
se
re
seq
when
raise
rescue
given
delay
\end{verbatim}

    So it's useful to have the left hand available for the character immediately following the modifier operator. In this case, that means using unshifted variants of {\tt +} and {\tt *},
    which, naturally enough, are {\tt -} and {\tt /}.

\section{Aesthetics}
\begin{quote}
\begin{verbatim}
log(factorial(5)),
where [factorial(x) = x ? x * factorial(x - 1) : 1]
\end{verbatim}
\hfill \textit{-- not the ugliest code out there}
\end{quote}

    Caterwaul won't win any beauty contests, but I've tried to make design choices that keep it visually out of the way. This is another reason I chose {\tt -}, {\tt /}, and {\tt |} as
    modifier prefixes: they are all straight lines and don't introduce intersections into a stream of text.\footnote{I have no idea whether this actually matters, but I noticed that I
    preferred operators with simple linear forms to operators with more complex forms.}

    Also, Caterwaul gives you the flexibility to write code that looks very nice. Consider this numerical integration function, for instance:

\begin{verbatim}
integrate(f, a, b, h) = sum(moments)
                        -where [sum(xs) = xs /[x + x0] -seq,
                                moments = n[a, b, h] *[f(x) * h] -seq]
\end{verbatim}

    The definition of integration is clearly visible, and the implementation details follow as an afterthought. Most Javascript code requires that the implementation details come first,
    followed by the high-level description at the end:

\begin{verbatim}
function integrate(f, a, b, h) {
  var sum = 0;
  for (var x = a; x < b; x += h)
    sum += f(x) * h;
  return sum;
}
\end{verbatim}

    This imperative definition is simpler, but at the cost of eliding the {\tt moments} variable. We can do the same with the Caterwaul definition, though it loses some readability:

\begin{verbatim}
integrate(f, a, b, h) = n[a, b, h] /[0][x0 + f(x) * h] -seq
\end{verbatim}

    Or, moving the multiplication out of the loop by the distributive property:

\begin{verbatim}
integrate(f, a, b, h) = n[a, b, h] /[0][x0 + f(x)] -seq -re- it * h
\end{verbatim}

\chapter{Game of Life}\label{sec:game-of-life}
  This example is more interesting than the prime list because it makes use of Caterwaul's jQuery macros. These macros, along with the sequence library, can significantly change the way
  Javascript programs are structured. As a twist, this game of life is implemented on a toroidal map; that is, both the horizontal and vertical edges wrap around to the opposite side.

\section{HTML structure}
    Like other Caterwaul applications, this one is built on a minimal HTML file that pulls in various scripts.

\lstset{caption={examples/game-of-life/index.html},name={examples/game-of-life/index.html}}\begin{resourcecode}
<!doctype html>
<html>
  <head>
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.std.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.ui.js'></script>
  <script src='life.js'></script>
  <link rel='stylesheet' href='style.css'/>
  </head>
  <body></body>
</html> \end{resourcecode}

\lstset{caption={examples/game-of-life/style.css},name={examples/game-of-life/style.css}}\begin{resourcecode}
.cell          {background: #eee}
.cell:hover    {background: #ccc}
.cell.on       {background: #444}
.cell.on:hover {background: #555}

.board {position: relative} \end{resourcecode}

\section{UI structure}
    One of the tricky things about the game of life is linking the cells together. This is especially true when, as is the case here, we use the DOM as a data model (thus removing the usual
    layer of indirection that causes all sorts of synchronization bugs).

    The key in this case is to build up arrays of elements first, establishing their visual position as a separate step. This avoids tricky reliance on DOM-level navigation and sibling
    checking. There are a couple of ways to represent the elements. One is to use a single long array and use modular access, but I'm going to use multiple nested arrays to illustrate some
    less commonly used features of the sequence library.

    Above the board, which is contained within a single \verb|<div>|, is a button to step the simulation.

\section{Javascript code}
    Normally I write Caterwaul with 192-column wrapping. This makes it easier to write multiple layers of {\tt where[]} modifiers without running out of horizontal space. (This, in turn, keeps
    the left margin relatively clean by moving lower-level details off to the right.) However, this code is wrapped at under 100 columns to be readable in the PDF.

\lstset{caption={examples/game-of-life/life.js},name={examples/game-of-life/life.js}}\begin{resourcecode}
$(caterwaul.jquery(caterwaul.js_all())(function () {
  $('body').append(top_button_row, board.div)
  -where [
    board           = life_board(30, 30),
    interval        = null,
    run_or_stop()   = interval ? stop_running()  -se- $(this).text('Run') :
                                 start_running() -se- $(this).text('Stop'),
    start_running() = interval = setInterval(board.step, 100),
    stop_running()  = clearInterval(interval) -se [interval = null],
    top_button_row  = jquery in div(
                        button.step('Step') /click(board.step),
                        button.run('Run')   /click(run_or_stop))]
  -where [
    life_board(x, y)    = {cells: cells,
                           div:   div_for(cells),
                           step:  step_function(cells)}
                          -where [cells = cells_for(x, y)],

    cells_for(x, y)     = n[x] *~[n[y] *y[cell_for(x, y)]] -seq,
    cell_for(x, y)      = jquery in div.cell *!x(x) *!y(y) %position(x, y)
                                                           %invert_on_click,
    position(x, y)(e)   = e.css({position: 'absolute',
                                 left: x * 12, width:  10,
                                 top:  y * 12, height: 10}),

    invert_on_click(e)  = e.mousedown($(this).toggleClass('on') -given.e),
    div_for(cs)         = jquery [div.board]
                          -se- cs *!~[x *![it.append(x)]] /seq,
    step_function(cs)() =
      cs *!~[x *!update] -seq
      -where [
        new_state(x, y) = on(x, y) ? count(x, y) -re [it >= 2 && it <= 3] :
                                     count(x, y) === 3,
        count(x, y)     = adjacent(x, y) /[x + x0] -seq,
        adjacent(x, y)  = (ni[x - 1, x + 1] - ni[y - 1, y + 1])
                            %p[p[0] !== x || p[1] !== y]
                            *[+on(x[0], x[1])] -seq,
        cell(x, y)      = cs[wrap(x, cs)] -re- it[wrap(y, it)],
        wrap(x, xs)     = (x + xs.length) % xs.length,
        on(x, y)        = cell(x, y).hasClass('on'),

        new_states      = cs *~[x *y[new_state(xi, yi)]] -seq,
        update(cell)    = cell.toggleClass('on',
                            new_states[cell.data('x')][cell.data('y')])]]})); \end{resourcecode}

\section{What's going on here?}
    This code is reasonably well front-loaded,\footnote{Meaning that higher-level things precede lower-level ones.} so I'll explain the code from the top down.

    First off, there are two separate {\tt where[]} blocks operating at the top level. This is totally ok because all of the operators used to modify things are left-associative. This means
    that the syntax tree will end up parsing like this:

\begin{verbatim}
($('body').append(...) -where [...]) -where [...]
\end{verbatim}

    This wouldn't be possible if {\tt -} were right-associative; in that case, you'd have:

\begin{verbatim}
$('body').append(...) -(where [...] -where [...])
\end{verbatim}

\subsection{UI code}
      The first part sets up the UI and appends it to the body:

\begin{verbatim}
$('body').append(top_button_row, board.div)
-where [
  board           = life_board(30, 30),
  interval        = null,
  run_or_stop()   = interval ? stop_running()  -se- $(this).text('Run') :
                               start_running() -se- $(this).text('Stop'),
  start_running() = interval = setInterval(board.step, 100),
  stop_running()  = clearInterval(interval) -se [interval = null],
  top_button_row  = jquery in div(
                      button.step('Step') /click(board.step),
                      button.run('Run')   /click(run_or_stop))]
\end{verbatim}

      This is all grouped into a single {\tt where[]} block because it's all UI-related. Grouping things like this limits the amount of interaction that can happen between any two components.

      An English-like description of each function and variable would be something like this:

\begin{enumerate}
\item[{\tt board}]
  The model for the simulation. This provides a UI, step function, and nested cell arrays.

\item[{\tt interval}]
  The interval timer used to run the simulation. When the simulation is running, this will hold the result of {\tt setInterval()}; otherwise it will be {\tt null}.

\item[{\tt run\_or\_stop()}]
  If the simulation is running, then stop it and set the button text to {\tt Run}. Otherwise, start the simulation and set the button text to {\tt Stop}.

\item[{\tt start\_running()}]
  Creates and stores an interval timer that steps the simulation every 100ms.

\item[{\tt stop\_running()}]
  Stops the (presumably running) interval timer and clears the {\tt interval} variable to indicate that nothing is running.

\item[{\tt top\_button\_row}]
  This is just a \verb|<div>| that contains the two buttons. Each one has a click handler; the step button delegates directly to {\tt board.step()} (which is safe because {\tt
  board.step} doesn't rely on any parameters or the value of {\tt this}), and the run button references {\tt run\_or\_stop} directly.
\end{enumerate}

\subsection{Model code}
      The model is a little unusual in that it stores its data directly on DOM elements. I did it this way to keep the example simple; it's more difficult (though often more scalable and
      performant) to maintain a purely logical data structure and keep it synchronized with a view layer of DOM nodes. The exact structure used is this:

\begin{verbatim}
cells = [[cell_11, cell_12, cell_13, ..., cell_1n],
         [cell_21, cell_22, cell_23, ..., cell_2n],
         ...
         [cell_m1, cell_m2, cell_m3, ..., cell_mn]]
\end{verbatim}

      \noindent where {\tt m} is the number of columns (!) and {\tt n} is the number of rows. So the cells are stored in column-major order if you're looking at it from the user's point of
      view. I didn't have a particularly compelling reason to do it this way, other than the fact that it seems more intuitive to first iterate over {\tt x} and then {\tt y}. (The outer loop
      is over {\tt y} when using row-major order.)

      There are two major pieces of code for the model. The first is the board setup code:

\begin{verbatim}
life_board(x, y)    = {cells: cells,
                       div:   div_for(cells),
                       step:  step_function(cells)}
                      -where [cells = cells_for(x, y)],

cells_for(x, y)     = n[x] *~[n[y] *y[cell_for(x, y)]] -seq,
cell_for(x, y)      = jquery in div.cell *!x(x) *!y(y) %position(x, y)
                                                       %invert_on_click,
position(x, y)(e)   = e.css({position: 'absolute',
                             left: x * 12, width:  10,
                             top:  y * 12, height: 10}),

invert_on_click(e)  = e.mousedown($(this).toggleClass('on') -given.e),
div_for(cs)         = jquery [div.board]
                      -se- cs *!~[x *![it.append(x)]] /seq
\end{verbatim}

      Here's what each variable/function does:

\begin{enumerate}
\item[{\tt life\_board(x, y)}]
  Creates a board, which is the top-level model element. A board consists of cells, a display \verb|<div>|, and a public {\tt step()} method that advances its state by one generation.
  Normally a model wouldn't expose DOM elements, but this one does because of the DOM-data coupling.

  The {\tt div} and {\tt step} attributes aren't linked to the board object itself, but they are linked to the cell array. This is useful from an API design perspective:~it lets users
  call the {\tt step} method without setting the context. (Which is what we did by using the {\tt step()} method as the click handler in the previous section.) The simplest way to
  create unbound functions such as \verb|step_function| is to use currying, and this is how \verb|step_function| is defined.

\item[{\tt cells\_for(x, y)}]
  This constructs a column-major nested array of cell \verb|<div>| elements. Each of these \verb|<div>|s keeps track of its state by either having or not having the {\tt on} class.
  Elements with the {\tt on} class set are drawn with a dark background; this behavior is governed by the stylesheet. (This prevents the Javascript from knowing too much about the UI
  presentation.)

\begin{verbatim}
n[x] *~[n[y] *y[cell_for(x, y)]] -seq
\end{verbatim}

  The sequence comprehension is a bit gnarly, but here's what each piece of it means:

\begin{enumerate}
\item[{\tt n[x]}]
  Construct an array of numbers {\tt [0, 1, 2, ..., x - 1]}.

\item[{\tt *\textasciitilde[...]}]
  Map over a block, and interpret the contents of the block in sequence context (that is, as if the {\tt -seq} modifier had been applied to the body of the block). The {\tt *}
  operator signifies mapping, and the {\tt \textasciitilde} indicates sequence context.

  Because no variable was named, the block will receive {\tt x}, {\tt xi}, and {\tt xl} as lexically-scoped variables. This inner {\tt x} shadows the {\tt x} passed into
  \verb|cells_for()| within the context of the block.

  The result of this inner block, which is an array of cells, will become a single entry in the final array returned by \verb|cells_for()|. This outer map operation constructs the
  array of all columns (each column is constructed by the logic below).

\item[{\tt n[y]}]
  Construct an array of numbers {\tt [0, 1, 2, ..., y - 1]}.

\item[{\tt *y[...]}]
  Map over another block, this time interpreted as a regular Javascript expression. The {\tt y} immediately preceding the block causes the loop variables to be renamed to {\tt y},
  {\tt yi}, and {\tt yl} instead of the default {\tt x}, {\tt xi}, and {\tt xl}. The inner {\tt y} created for this block will shadow the one passed into \verb|cells_for()|.

  This map operation constructs a column of cells.

\item[{\tt cell\_for(x, y)}]
  Construct a single cell at the coordinates $(x, y)$. Because this is the result of mapping, the cell will be added to the column array.

\item[{\tt -seq}]
  This causes the entire preceding expression (in this case, everything back to the {\tt =}, which has lower precedence than the {\tt -} on the front of {\tt seq}) to be treated as
  a sequence comprehension. This is what causes {\tt *} to be interpreted as a map operation, {\tt n[]} to be interpreted as an array constructor, etc.

  {\tt seq} is a modifier just like {\tt jquery} and {\tt where[]}, so it could be written several different ways. I generally like to use {\tt -} because it's a medium-precedence
  operator that easily combines with things like {\tt -se-} and {\tt -re-}.
\end{enumerate}

\item[{\tt cell\_for(x, y)}]
  Constructs and returns a single cell, which is a jQuery-wrapped \verb|<div>|. Each cell has some data associated with it. It has two jQuery {\tt data()} properties to store its {\tt
  x} and {\tt y} coordinates, and it tracks its on/off state using the {\tt on} CSS class.

\begin{verbatim}
jquery in div.cell *!x(x) *!y(y) %position(x, y) %invert_on_click
\end{verbatim}

  Here's what the {\tt jquery} modifier is doing:

\begin{enumerate}
\item[{\tt jquery in}]
  Causes the following expression to be interpreted in jQuery context. This enables the transformations described below. {\tt in} has the same precedence as {\tt <}, {\tt >}, {\tt
  <=}, and {\tt >=} and is left-associative. This means that all of the usual arithmetic operators will still be in jQuery context, but any relational or lower-precedence operators
  will escape.

\item[{\tt div.cell}]
  In jQuery context this constructs a \verb|<div>| element with CSS class {\tt cell}. Specifically, it expands to \verb|jQuery("<div>").addClass("cell")|.

\item[{\tt *!x(x) *!y(y)}]
  This looks a bit tricky, but there isn't anything particularly magical happening. The {\tt *!}~prefix, when interpreted by the {\tt jquery} modifier, refers to a jQuery {\tt
  data} property. So in general, things of the form \verb|a *!b(c)| will expand to \verb|a.data("b", c)|, and that's exactly what's happening here. In this case, the resulting code
  is \verb|.data("x", x).data("y", y)|, which sets two data properties and returns the original jQuery selector.

\item[{\tt \%position(x, y)}]
  This is interesting. First, it calls {\tt position()} on the current {\tt x} and {\tt y} coordinates, then it calls that result on the current element. In general, \verb|a %b|
  is expanded into \verb|b(a)|. Because applying {\tt position} to {\tt (x, y)} has higher precedence than the \verb|%| operator, the resulting expansion is
  \verb|position(x, y)(...)|, where {\tt ...}~is the aforementioned element constructed by {\tt div.cell}.

\item[{\tt \%invert\_on\_click}]
  The same thing as \verb|%position(x, y)|, but this function isn't curried. \verb|%| left associates, so the overall parse order is \verb|(... %position(x, y)) %invert_on_click|.
  By the rule described above, then, the whole expansion would be \verb|invert_on_click(position(x, y)(...))|. You can see this happening using the interactive shell on
  \url{http://caterwauljs.org}.
\end{enumerate}

\item[{\tt position(x, y)(e)}]
  This is one of the functions used in the jQuery comprehension in the previous step. It's responsible for visually positioning each cell on the board. I've hard-coded some numbers
  here; basically, each cell is $10\times 10$ pixels and has a 2-pixel margin.

  Importantly, this function returns {\tt e} (indirectly, since jQuery's {\tt css()} method returns the original element when used as a setter). This matters because the {\tt jquery}
  modifier lets you change the return value from a \verb|%| function. For example, suppose we had written this:

\begin{verbatim}
position(x, y)(e) = e.css({...}) -re- false
\end{verbatim}

  Then the {\tt jquery} comprehension would end up passing {\tt false} to \verb|invert_on_click|, with unfortunate consequences. Generally, functions used with \verb|%| should return
  the element they're given to avoid confusion.

\item[{\tt invert\_on\_click(e)}]
  This function is generally unremarkable. The only interesting thing about it is that it uses an inline {\tt -given} modifier, which converts its expression into a function. The {\tt
  .e} on the end of {\tt given} is a shorthand to indicate that {\tt e} is the function's only parameter. (If we wanted a function that took multiple parameters, we'd write something
  like {\tt -given[e, x, y]}.)

  Like {\tt position(x, y)}, \verb|invert_on_click| returns the element it modifies. That is, besides the fact that it is side-effecting, it behaves like the identity function.
\end{enumerate}

\subsection{Simulation code}
      This is the most complex bit of the program. It contains logic to count the neighbors of each cell, compute an array of new states, and update each cell to reflect its new state.

\begin{verbatim}
step_function(cs)() =
  cs *!~[x *!update] -seq
  -where [
    new_state(x, y) = on(x, y) ? count(x, y) -re [it >= 2 && it <= 3] :
                                 count(x, y) === 3,
    count(x, y)     = adjacent(x, y) /[x + x0] -seq,
    adjacent(x, y)  = (ni[x - 1, x + 1] - ni[y - 1, y + 1])
                        %p[p[0] !== x || p[1] !== y]
                        *[+on(x[0], x[1])] -seq,
    cell(x, y)      = cs[wrap(x, cs)] -re- it[wrap(y, it)],
    wrap(x, xs)     = (x + xs.length) % xs.length,
    on(x, y)        = cell(x, y).hasClass('on'),

    new_states      = cs *~[x *y[new_state(xi, yi)]] -seq,
    update(cell)    = cell.toggleClass('on',
                        new_states[cell.data('x')][cell.data('y')])]
\end{verbatim}

      The first thing to notice is that this function is curried; it takes a cell array called {\tt cs}, and expects to be invoked again before doing anything. This is an easy way to store
      temporary data using Caterwaul. I've curried this function because it ends up being invoked as the click handler of the step button. The click handler won't receive a reference to the
      board, so the function will need to have one already available. In this sense the function is behaving more like a callable object, and in fact currying can be a good substitute for
      immutable object-oriented data structures.

      The other unusual thing about \verb|step_function| is that it has a bunch of variables defined in a sub-{\tt where[]}. These variables are re-created on each invocation of
      \verb|step_function()()|.

      Like other functions, this one is front-loaded; here's a breakdown of what's happening.

\begin{enumerate}
\item[{\tt cs *!\textasciitilde[x *!update] -seq}]
  This just runs through the two-dimensional array, calling {\tt update()} on each cell \verb|<div>|. Cells know their own coordinates, so we don't need to pass the array indexes into
  the {\tt update()} function; it will obtain the coordinates directly from the cell object's {\tt data} properties.

  The sequence comprehension here consists of:

\begin{enumerate}
\item[{\tt cs *!\textasciitilde[...]}]
  A foreach operation on {\tt cs}. This invokes the block, in sequence context due to the tilde, on each element of {\tt cs}. Each element of {\tt cs} is itself an array. The
  block's result isn't stored because it is used in a foreach rather than a map operation. (For this reason, foreach has less overhead than map.)

\item[{\tt x *!update}]
  This block takes {\tt x}, which is one of the arrays in {\tt cs}, and invokes {\tt update} on each element. In this case, {\tt update} appears where a block would normally go.
  {\tt seq} handles this by turning it into this block: {\tt [update(x, x0, xi, xl)]}. It's safe to use {\tt update()} this way because it uses only its first parameter. It isn't
  safe to use a function such as {\tt Array.prototype.push} in this context, however, as it will push each item you pass it (which probably isn't what you would want to do).

\item[{\tt -seq}]
  Modifies the preceding expression by interpreting it in sequence context. It's ok to use {\tt -} here because of left-associativity.
\end{enumerate}

\item[{\tt new\_state(x, y)}]
\begin{verbatim}
= on(x, y) ? count(x, y) -re [it >= 2 && it <= 3] :
             count(x, y) === 3
\end{verbatim}

  Returns a boolean specifying whether the cell at position $(x, y)$ will be activated in the next generation. The rules for this depend on the current state of the cell. If the cell
  is currently on and has 2 or 3 active neighbors, then it will remain activated. A cell that is currently off and has 3 active neighbors will become activated.

  As might be expected, {\tt on(x, y)} returns a boolean indicating whether the cell at $(x, y)$ is presently activated.

  The {\tt -re[]} expression is being used to bind a temporary variable. This is useful when you don't want to go to the trouble of setting up a {\tt -where[]} block or when you need
  to box up low-precedence operators such as {\tt \&\&}. It's similar to the linguistic construct people would use when saying something like ``if the neighbor count of $(x, y)$ is at
  least 2 and it's at most 3, then ...'', though Caterwaul's construct is a bit clunkier, requiring both uses to be referred to as {\tt it}.

\item[{\tt count(x, y)}]
\begin{verbatim}
= adjacent(x, y) /[x + x0] -seq
\end{verbatim}

  Returns the number of active neighbors of the cell at $(x, y)$. This is done by retrieving the active-status of each adjacent cell (returned by {\tt adjacent(x, y)}), and folding
  over addition. A less efficient but equivalent way to do it would be to use filtering: \verb|adjacent(x, y) %[x] -seq -re- it.length|. Conceptually, I think folding communicates the
  intention more clearly.

\item[{\tt adjacent(x, y)}]
\begin{verbatim}
= (ni[x - 1, x + 1] - ni[y - 1, y + 1])
    %p[p[0] !== x || p[1] !== y]
    *[+on(x[0], x[1])] -seq
\end{verbatim}

  This is a fun one, and it's where most of the heavy lifting happens. The idea is to come up with an array of numerical active-statuses, each one either a 1 (active) or a 0
  (inactive). The {\tt count()} function can then sum that array with minimal effort.

\begin{enumerate}
\item[{\tt (ni[...]~- ni[...])}]
  This constructs a single array of {\tt [x, y]} pairings within the $3\times 3$ rectangle around $(x, y)$. If {\tt x} is 4 and {\tt y} is 10, for example, then this expression
  returns {\tt [[3, 9], [3, 10], [3, 11], [4, 9], [4, 10], [4, 11], [5, 9], [5, 10], [5, 11]]}. This behavior is primarily governed by {\tt -}, which in sequence context computes
  the cartesian product of its operands. (Because {\tt -} has lower precedence than most sequence operators, it must be parenthesized as shown here.)

\item[{\tt \%p[p[0] !== x \char `\| \char `\|~p[1] !== y]}]
  Here we're removing the {\tt [x, y]} pair representing the original cell. Each pair is called {\tt p} to avoid shadowing {\tt x} or {\tt y} (both of which are required inside the
  block). The resulting array contains eight pairs, each one of which represents a cell that's adjacent but not the original.

\item[{\tt *[+on(x[0], x[1])]}]
  Now we transform coordinate pairs into numbers. The map, hopefully, is not mysterious at all by now; but the block is a bit unusual. {\tt on()} returns a boolean, which I'm
  coercing into a number using Javascript's unary {\tt +} operator. The block is being interpreted in regular context, so this isn't transformed by {\tt seq} in any way.

\item[{\tt -seq}]
  Wrapping up the sequence comprehension by transforming everything back to {\tt =}. The return value of this sequence comprehension is an array of eight numbers, each a 1 or a 0,
  describing the activation states of the cells surrounding $(x, y)$.
\end{enumerate}

\item[{\tt cell(x, y)}]
\begin{verbatim}
= cs[wrap(x, cs)] -re- it[wrap(y, it)]
\end{verbatim}

  Normally I wouldn't factor this into its own function, since indexing twice into {\tt cs[]} isn't a big deal. But this life game is in toroidal space, which requires wraparound
  logic. So the {\tt cell()} function has to transform the array indexes as well as dereference stuff.

  I'm using {\tt -re-} here because we need two references to {\tt cs[wrap(x)]}. The first one, obviously, provides the cell within the column. The second one is passed into {\tt
  wrap()} to provide the wrapping length. I could bind a local variable or duplicate a subexpression, but {\tt -re-} is very short to type so I've used that instead.

\item[{\tt wrap(x, xs)}]
\begin{verbatim}
= (x + xs.length) % xs.length
\end{verbatim}

  This wraps the index around the beginning or end of the array and returns the new transformed index. It takes the array so that it can retrieve its length.

\item[{\tt on(x, y)}]
\begin{verbatim}
= cell(x, y).hasClass('on')
\end{verbatim}

  A trivial function to concisely represent the activation state of the given cell.

\item[{\tt new\_states}]
\begin{verbatim}
= cs *~[x *y[new_state(xi, yi)]] -seq
\end{verbatim}

  This is an array like {\tt cs} that contains the new state of each cell. We have to store these before updating the individual cell elements because otherwise we would lose
  information; future computations depend on the old state of each cell.

  My API is a bit suboptimal for this case.\footnote{Actually, a lot of the factoring here is suboptimal. But I'm resisting my OCD and leaving it this way for now.} I end up throwing
  away the actual elements of {\tt cs} and just using their indexes as positional coordinates. The first map preserves sequence context for its block to make the inner map more
  convenient. I rename the inner variable to have access to both {\tt xi} and {\tt yi} at the same time.

  {\tt new\_states} is a variable, so its value is computed eagerly after the functions above it have been created. However, it has no access to {\tt update}, which is defined below.

\item[{\tt update(cell)}]
\begin{verbatim}
= cell.toggleClass('on',
    new_states[cell.data('x')][cell.data('y')])
\end{verbatim}

  By the time {\tt update()} is called, {\tt new\_states} is fully populated. All we have to do is store the new state back onto the DOM element, which happens using {\tt
  toggleClass()}. As usual, jQuery makes this trivially easy.
\end{enumerate}

      And there you have it! That's the entirety of this 41-SLOC implementation of the game of life.

\chapter{Run Length Encoding}
  It's unlikely that you'll actually need to write a run-length encoder in Javascript anytime soon, but the problem is a good example of how to do basic sequence-manipulation tasks. I'll start
  with the decoder because it's simpler. The format looks like this:

\begin{verbatim}
[[count, item], [count, item], ...]
\end{verbatim}

  \noindent So, for example, \verb+[[1, 3], [2, 4]]+ encodes the array \verb+[3, 4, 4]+. A regular Javascript decoder looks like this:

\begin{verbatim}
var rle_decode = function (xs) {
  var result = [];
  for (var i = 0, l = xs.length; i < l; ++i)
    for (var j = 0, lj = xs[i][0]; j < lj; ++j)
      result.push(xs[i][1]);
  return result;
};
\end{verbatim}

  Fortunately this is exactly the kind of thing that the \verb+seq+ macro can help with. Here's the same function in Caterwaul:

\begin{verbatim}
rle_decode(xs) = xs *~!~[n[x[0]] *y[x[1]]] -seq
\end{verbatim}

  This makes use of some of the more obscure bits of the sequence library. Here's the breakdown:

\begin{enumerate}
\item[{\tt xs *\textasciitilde !}]
  Flat-map over {\tt xs}. The block should return an array from each {\tt x} in {\tt xs}; all of these arrays are concatenated to form the result.

\item[{\tt \textasciitilde[n[x[0]] ...]}]
  Interpret the flat-map block in sequence context. This gives us access to {\tt n[]}, which generates a sequence of numbers. In this case we're generating a list {\tt x[0]} elements long.
  The numbers themselves don't matter, just the length of the array.

\item[{\tt *y[x[1]]}]
  Take that list of numbers, calling each one {\tt y}, and return {\tt x[1]}. We're throwing away {\tt y} because we just want the same item repeated a bunch of times.
\end{enumerate}

\end{document}
