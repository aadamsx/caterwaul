\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{rubycode}      {\lstset{language=ruby}}{}

\lstnewenvironment{resourcecode}{}{}

\title{Caterwaul By Example}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}

\chapter{List of Primes}\label{sec:list-of-primes}
  It's rare that you actually need to generate a list of primes in production code, but this problem makes a good programming language example. The goal here is to write a web page that ends
  up showing the user a list of primes below 10,000.

\section{Preparing the HTML}
    The first step, assuming that we want to iterate rapidly, is to create a basic HTML document that loads Caterwaul and our application source code:

\lstset{caption={examples/primes/index.html},name={examples/primes/index.html}}\begin{resourcecode}
<!doctype html>
<html>
  <head>
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.std.js'></script>
  <script src='primes.js'></script>
  </head>
  <body></body>
</html> \end{resourcecode}

    Caterwaul's core and the {\tt std} module don't depend on jQuery. I'm just including it here so that we can easily do things when the page is loaded.

\section{Invoking Caterwaul}
    Caterwaul is a Javascript compiler written in Javascript. So to use it, you just hand your function to Caterwaul and run the function it gives you back. Here's an example of this behavior:

\begin{verbatim}
// Use an unconfigured caterwaul compiler; this has no effect:
var f = function (x) {return x + 1};
var g = caterwaul(f);

// Use all known Javascript extensions:
var f2 = function (x) {return y, where[y = x + 1]};
var c  = caterwaul.js_all();      // Returns a configured compiler
var g2 = c(f2);
\end{verbatim}

    Most Javascript apps have a surrounding lexical closure to create a local scope, so you can save some space by transforming the function inline:

\begin{verbatim}
caterwaul.js_all()(function () {
  // app code
})();

// If using jQuery:
$(caterwaul.js_all()(function () {
  // app code
}));
\end{verbatim}

    We're using jQuery, so our app will look like the second function here.

\section{Application code}
    Here's a Caterwaul app that computes our list of primes and shows it to the user:

\lstset{caption={examples/primes/primes-first.js},name={examples/primes/primes-first.js}}\begin{resourcecode}
$(caterwaul.js_all()(function () {
  var is_prime = function (x) {
    for (var i = 2; i * i <= x; ++i)
      if (x % i === 0)
        return false;
    return true;
  };

  var list = [];
  for (var i = 2; i < 10000; ++i)
    if (is_prime(i))
      list.push(i);

  $('body').text(list.join(', '));
})); \end{resourcecode}

    Caterwaul is a superset of Javascript, so this example behaves exactly as we'd expect. However, it doesn't look particularly special. Using Caterwaul idioms and refactoring a bit, we get
    this:\footnote{Thanks to Jeff Simpson for pointing out a bug here! I had previously written {\tt composite(n) = n[2, Math.sqrt(n)]}, which has an off-by-one error since it stops before
    reaching $\sqrt n$. It's necessary to add one to make sure that we include the square root as well as the other factors.}

\lstset{caption={examples/primes/primes.js},name={examples/primes/primes.js}}\begin{resourcecode}
$(caterwaul.js_all()(function () {
  $('body').append(primes.join(', '))
  -where [
    composite(n) = n[2, Math.sqrt(n) + 1] |[n % x === 0] |seq,
    primes       = n[2, 10000] %!composite -seq];
})); \end{resourcecode}

    This code probably looks like voodoo, but it's actually not that complicated. There are two things happening here that aren't in regular Javascript. First, the {\tt where[]} construct
    binds variables within an expression. Second, the {\tt seq} modifier is deeply mysterious and somehow condenses five or six lines of code into two.

    {\tt where[]} is used when you want to locally bind something. For example:

\begin{verbatim}
alert(x)     -where [x = 10];
alert(f(10)) -where [f(x) = x + 1];
\end{verbatim}

    This is translated into a local function scope that gets called immediately:

\begin{verbatim}
(function () {
  var x = 10;
  return alert(x);
})();

(function () {
  var f = function (x) {return x + 1};
  return alert(f(10));
})();
\end{verbatim}

    You'll notice that there's a little bit of magic going on to let you say {\tt f(x) = x + 1}. This is not explicitly handled by {\tt where[]}; instead, Caterwaul has a macro that rewrites
    things that look like {\tt x(y) = z} into \verb|x = function (y) {return z}|. Because this rule is applied globally, you can also use it to create methods or reassign existing functions:

\begin{verbatim}
jQuery.fn.size() = this.length;
\end{verbatim}

    Because it's recursive, you can create curried functions by providing multiple argument lists:

\begin{verbatim}
alert(f(1)(2)) -where [f(x)(y) = x + y];

// Is compiled to:
(function () {
  var f = function (x) {
    return function (y) {
      return x + y;
    };
  };
  return alert(f(1)(2));
})();
\end{verbatim}

    A reasonable question is how {\tt where[]} knows how much code should be able to see the variables you're binding. The answer has to do with its prefix: {\tt where} is what's known as a
    modifier, and all modifiers have an accompanying operator that has a precedence. For example, in the expression {\tt x * y -where[...]} the {\tt where} clause binds over the
    multiplication, since the minus has lower precedence. Writing it as {\tt x + y /where[...]} causes only {\tt y} to have access to the {\tt where} variables.

    {\tt seq} is the macro that is more interesting in this prime-generator example. It's a mechanism that writes all different kinds of {\tt for} loops. In this case we're using it in two
    places. The first time is in the {\tt composite()} function, where we use it to detect factors:

\begin{verbatim}
composite(n) = n[2, Math.sqrt(n) + 1] |[n % x === 0] |seq
\end{verbatim}

    First, we use {\tt n[]} to generate an array of numbers between 2 and {\tt Math.sqrt(n)}, inclusive. {\tt n[]} (with square brackets) is a syntax form, not a function; so it won't collide
    with the variable {\tt n} that we take as a parameter. The next piece, \verb+|[n % x === 0]+, has two parts. The pipe operator, which normally performs a bitwise-or, means ``there exists''
    in sequence context. Its body, \verb|n % x === 0|, is then evaluated for each element ({\tt seq} calls the element {\tt x}). So at this point we're asking, ``does there exist an integer
    {\tt x} for which {\tt n \% x} is zero?'' We tack the \verb+|seq+ onto the end to cause the preceding expression (in this case, everything back to the {\tt =}) to be interpreted by the
    {\tt seq} macro. {\tt seq} is a modifier just like {\tt where[]}, though {\tt seq} doesn't take parameters.

    The other use of {\tt seq} is to retrieve all numbers that are not composite:

\begin{verbatim}
primes = n[2, 10000] %!composite -seq
\end{verbatim}

    {\tt n[]} is doing the same thing as before. After it is {\tt \%}, which is the filter operator. So we're filtering down to only the elements which are not composite. The filter prefix is
    \verb|%|, and the \verb|!| modifier negates the condition. Because there's already a function defined, I use that instead of writing out a block. I'm using a higher-precedence prefix for
    {\tt seq} as a matter of convention; I default to using a minus unless there's a reason to use something else.

\chapter{Quicksort}\label{sec:quicksort}
  Every self-respecting functional language author must illustrate how to write an inefficient quicksort that conses up tons of memory. A trivial quicksort in Caterwaul looks like this:

\begin{verbatim}
quicksort(xs) = xs.length === 0 ? xs :
                less + [pivot] + greater -seq
                -where [pivot   = xs[0],
                        rest    = xs.slice(1),
                        less    = quicksort(rest %[x <  pivot] -seq),
                        greater = quicksort(rest %[x >= pivot] -seq)];
\end{verbatim}

  That could be the end of the chapter, but if I stopped here then you wouldn't see the awesomeness that is Caterwaul's jQuery library. This app, rather than just sorting data, makes the
  process interactive by having the user resolve pieces of the sort.

\section{HTML and CSS}
    This is fairly routine. We need a page that includes jQuery, Caterwaul, the standard modules, and the Caterwaul future library.\footnote{The Caterwaul future library is on Github at
    \url{http://github.com/spencertipping/caterwaul-futures}.}

    There's an extra \verb|<script>| element here, just below \verb|<script src='quicksort.js'>|. I'm using this pattern because it makes it simpler to precompile things. If your main script
    has this form:

\begin{verbatim}
$(caterwaul.js_all()(function () {...}));
\end{verbatim}

    \noindent then it's impossible to precompile because \verb|$| won't be defined (precompilation executes your code so that it can perform value tracing). However, we can defer the jQuery
    initializer call by pushing it into a non-Caterwaul script and just defining an {\tt initialize} function:

\begin{verbatim}
initialize = caterwaul.js_all()(function () {...});
\end{verbatim}

\lstset{caption={examples/quicksort/index.html},name={examples/quicksort/index.html}}\begin{resourcecode}
<!doctype html>
<html>
  <head>
  <script src='http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.std.js'></script>
  <script src='http://caterwauljs.org/build/caterwaul.ui.js'></script>
  <script src='http://spencertipping.com/caterwaul-futures/future.js'></script>
  <script src='quicksort.js'></script>
  <script>$(initialize)</script>

  <style>
  body {font-family: sans-serif; font-size: 9pt}
  </style>
  </head>
  <body></body>
</html> \end{resourcecode}

\section{Javascript}
    When the user first loads the page, they're presented with a randomly generated list of numbers and a button. When they click the button, the sort begins and they see the stages as they
    happen. Internally this is achieved by using futures that later are resolved to the intermediate results. When the futures become decided, new UI elements are created to show the process.

\lstset{caption={examples/quicksort/quicksort.js},name={examples/quicksort/quicksort.js}}\begin{resourcecode}
 \end{resourcecode}

\end{document}
