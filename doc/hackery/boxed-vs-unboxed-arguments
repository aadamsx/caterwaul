#!/usr/bin/env waul
# boxed-vs-unboxed-arguments: is native variadic packing more efficient than manual boxing?

caterwaul('js_all')(function () {
  'starting benchmark' /!console.log,

  bench('unboxed 1', 30000000, "unboxed_1(_)".qf),
  bench('unboxed 2', 30000000, "unboxed_2(_, _ + 1)".qf),
  bench('unboxed 8', 30000000, "unboxed_8(_, _, _, _, _, _, _, _)".qf),

  bench('consing boxed 1', 30000000, "boxed_1({x: _})".qf),
  bench('consing boxed 2', 30000000, "boxed_2({x: _, y: _})".qf),
  bench('consing boxed 8', 30000000, "boxed_8({a: _, b: _, c: _, d: _, e: _, f: _, g: _, h: _})".qf),

  bench('non-consing boxed 1', 30000000, "nbox_1.x = _, boxed_1(nbox_1)".qf),
  bench('non-consing boxed 2', 30000000, "nbox_2.x = _, nbox_2.y = _, boxed_2(nbox_2)".qf),
  bench('non-consing boxed 8', 30000000, "nbox_8.a = _, nbox_8.b = _, nbox_8.c = _, nbox_8.d = _, nbox_8.e = _, nbox_8.f = _, nbox_8.g = _, nbox_8.h = _, boxed_8(nbox_8)".qf),

  # Same number of accesses regardless of which alternative is chosen. We're interested only in figuring out the overhead imposed by the calling convention.
  where [unboxed_1(x) = x + x + x + x + x + x + x + x,                  unboxed_2(x, y) = x + y + x + y + x + y + x + y,
         boxed_1(o)   = o.x + o.x + o.x + o.x + o.x + o.x + o.x + o.x,  boxed_2(o)      = o.x + o.y + o.x + o.y + o.x + o.y + o.x + o.y,

         unboxed_8(a, b, c, d, e, f, g, h) = a + b + c + d + e + f + g + h,
         boxed_8(o)                        = o.a + o.b + o.c + o.d + o.e + o.f + o.g + o.h,

         nbox_1 = {x: 0},
         nbox_2 = {x: 0, y: 0},
         nbox_8 = {a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0},

         bench(name, n, f) = '#{name}\033[40G\033[1;32m#{average /!Math.round}ms avg, #{max}ms max, #{min}ms min, #{Math.sqrt(variance) /!Math.round}ms stddev\033[0;0m' /!console.log
                     -where [samples  = n[8] *[run(name, n >>> 3, f)] -seq,
                             average  = samples /[x + x0] -seq -re- it / 8,
                             max      = samples /[x /-Math.max/ x0] -seq,
                             min      = samples /[x /-Math.min/ x0] -seq,
                             variance = samples /[0][x0 + (x - average) * (x - average)] -seq],
         run = function (name, n, f) {var start = +new Date(); for (var i = n; i >= 0; --i) f(i); return +new Date() - start}]})();
