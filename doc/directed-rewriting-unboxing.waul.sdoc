Unboxing complex syntax trees.
Caterwaul's syntax tree representation is fairly inefficient. Every 'if', parenthesis, brace, and other element is stored as a token, not as an encoded quantity. Put differently, Caterwaul's
representation is unstructured enough that it allows you to encode possibilities that are syntactically invalid. I personally like the flexibility; it makes it easy to do things like
annotating trees in statement mode.

Each rule can be represented as a unique number containing children directly. This will accelerate pattern matching. For example:

| @seq(_xs *[_body])    ->   {data: 1, '0': {'_xs'}, '1': {'_body'}}

This also creates some interesting challenges for the matcher. Cross-level matching won't be possible until you manually unbox the trees and repack them according to a different scheme.
(Actually, this might be a feature instead of a bug.)

Detecting unboxing candidates.
This is where entropy hashes come into play. Only commonly-occurring nodes need to be unboxed; the overhead isn't worth it for nodes that occur just once or twice. So, given a program,
pattern, and replacement space, we compute per-node entropy hashes. These hashes are then sorted into a max-heap by frequency. (Note that entropy hashes include information about immediate
children.) [Incomplete thought ... finish this later]
