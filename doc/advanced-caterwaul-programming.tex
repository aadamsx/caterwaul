\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}

\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}

\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
\lstnewenvironment{perlcode}      {\lstset{language=perl}}{}
\lstnewenvironment{resourcecode}{}{}

\title{Advanced Caterwaul Programming}
\author{Spencer Tipping}

\begin{document}
\maketitle{}
\tableofcontents{}

\chapter{Introduction}
  {\it Client-Side Caterwaul} introduces Caterwaul in an applied context. This guide talks about leveraging the more advanced features of Caterwaul to write rich client and server
  applications. I also introduce some design patterns that help keep code readable despite being very terse.

\section{Useful libraries}
    Caterwaul alone, even with a growing standard library, is only so useful. As I find repeated use cases I write extension modules or libraries. At this point Caterwaul supports:

\begin{itemize}
\item{Finite and infinite sequences and concise comprehensions ({\tt seq})}
\item{Tail-call optimization and delimited continuations ({\tt continuation})}
\item{Packrat parser combinators ({\tt parser})}
\item{HAML-style HTML element generation ({\tt montenegro}, an external library)}
\end{itemize}

    The Montenegro project\footnote{\url{http://github.com/spencertipping/montenegro}} is briefly documented in its readme, but I'll cover its usage here by example. Now the HTML scaffolding
    should look like this:

\begin{verbatim}
<!doctype html>
<html>
  <head>
    <title>...</title>
    <script src='jquery.js'></script>
    <script src='caterwaul.all.js'></script>
    <script src='montenegro.client.js'></script>
    <script src='page.js'></script>
    <link rel='stylesheet' href='...' />
  </head>
  <body></body>
</html>
\end{verbatim}

    {\tt page.js} is the page driver, and that's where all of the logic will end up.
\chapter{Creating Markup}
  Montenegro was written to integrate markup creation into the page logic. Before you vote to have me excommunicated for suggesting that this is a good thing, let's consider the simplicity it
  offers.

\section{Functional UI modeling}
    Caterwaul includes macros to make function definitions very lightweight in order to encourage abstraction where appropriate. One of the places it's most helpful is factoring out the
    implementation of a particular UI element. So, for example, if we want a box asking for someone's name and e-mail address, we could do it this way:

\begin{verbatim}
$('body').append(html[table(
  tr(td('Name: '), td(input.name)),
  tr(td('Email: '), td(input.email)))]);
\end{verbatim}

    \noindent But if we're going to be creating many of them, it's better to factor it out:

\begin{verbatim}
$('body').append(name_and_email()),
where*[
  name_and_email() = html[table[row_for('name'), row_for('email')]],
  row_for(field)   = html[tr(td['#{field}: '], td(input /addClass(field)))]];
\end{verbatim}

\begin{quote}
\textbf{N.B.}
This code illustrates a design pattern I've found to be very useful: {\it one concern per line}. As I'll discuss later on, Caterwaul code can be very terse, and it's often useful to
leverage that terseness without creating spaghetti code.
\end{quote}
    
\section{Side-effects}
    Normally in functional style you want to use as few side-effects as possible and have each function be pure. However, this breaks down when you have to work with continuations. The classic
    example is loading some content via AJAX:

\begin{quote}
\begin{verbatim}
// side-effect at toplevel
name_and_email(fn[element][$('body').append(element)]),
where*[
  name_and_email(cc) = l/cps[data <- $.getJSON('...', _)] in
                       cc(name_and_email_helper(data)),
  name_and_email_helper(data) = html[table[row_for('name'), row_for('email')]],
  row_for(field) = /* same as before */];
\end{verbatim}
\end{quote}

    \noindent The problem here is obvious; we haven't really gotten rid of the side-effect, we've just pushed it up to the toplevel. More useful is to push the side-effect into the abstraction
    so that we have the usual behavior from \verb|name_and_email|. Here's how to do it:

\begin{quote}
\begin{verbatim}
// side-effect encapsulated inside name_and_email()
$('body').append(name_and_email()),
where*[
  name_and_email() = html[div] /se[populate(_)],
  populate(div)    = l/cps[data <- $.getJSON('...', _)] in
                     div.append(html[table[row_for('name'), row_for('email')]]),
  row_for(field)   = /* same as before */];
\end{verbatim}
\end{quote}
\chapter{Sequences}
  {\tt seq} is probably my favorite Caterwaul library. It can reduce complex map/fold/filter expressions down to a single line and can represent most if not all of the cases where bulkier
  constructs such as {\tt while} and {\tt for} would normally be used.

\section{The {\tt seq[]} macro}
    As with most macros in Caterwaul, {\tt seq[]} creates a context in which operators are reinterpreted. However, none of the functionality exposed by {\tt seq[]} is created by the macro; all
    generated code refers to public methods of the sequence classes. For example:

\begin{verbatim}
seq[xs *[_ + 1]]   ->   xs.map(fn[_, _i][_ + 1])
seq[xs %[_]]       ->   xs.filter(fn[_, _i][_])
seq[xs *~[_ *[_]]] ->   xs.map(fn[_, _i][_.map(fn[_, _i][_])])
\end{verbatim}

    All of the transformations are documented in the source code.\footnote{\url{http://github.com/spencertipping/caterwaul/blob/master/modules/caterwaul.seq.js}} Operators apply with their
    usual precedence, which generally is intuitive except in the case of flat-map, represented by {\tt -}.\footnote{Sadly, I ran out of multiplication-precedence operators and had to go down
    one level. It's unfortunate, but still usable.}

    I'll explain the semantics of the operations encoded by various operators as I go. It will probably be handy to have the source code available, and perhaps also the Caterwaul live
    compiler.\footnote{\url{http://spencertipping.com/caterwaul/compiler}}

\section{Use case: A list of resources}
    Often in AJAX applications there's some list of stuff that needs to be displayed to the user. For simplicity, let's assume that we have an index of things, each of which can be clicked on
    to view the whole object. In straight jQuery/HTML a common way to code this would be (preserving the functional-DOM pattern):

\begin{quote}
\begin{verbatim}
var a_thing = function (name) {
  return $('<a>').text(name).attr('href', 'javascript:void(0)').
                            click(open_page_for(name));
};
var list_of_things = function () {
  var result = $('<div>');
  $.getJSON('/index', function (items) {
    for (var i = 0, l = items.length; i < l; ++i)
      result.append(a_thing(items[i]));
  });
  return result;
};
$('body').append(list_of_things());
\end{verbatim}
\end{quote}

    \noindent This Caterwaul code does the same thing:

\begin{quote}
\begin{verbatim}
$('body').append(list_of_things()),
where*[
  list_of_things() = html[div] /se[add_things_to(_)],
  add_things_to(x) = l/cps[things <- $.getJSON('/index', _)] in
                     seq[~things *+a_thing *![x.append(_)]],
  a_thing(name)    = html[a[name] *href('javascript:void(0)')
                                  /click(open_page_for(name))]];
\end{verbatim}
\end{quote}

    \noindent We saved the most space with {\tt l/cps} and {\tt seq[]}. Here's how to read the \verb|add_things_to| function:

\begin{quote}
Pull {\it things} from a {\tt getJSON} call using a callback. {\tt l/cps} stands for 'let-in-continuation-passing-style', so it binds a variable when the continuation gets invoked.
\begin{verbatim}
l/cps[things <- $.getJSON('/index', _)] in
\end{verbatim}
\end{quote}

\begin{quote}
Promote the array {\it things} into a Caterwaul finite sequence. Then map each one through the function \verb|a_thing|. For each element in this new sequence, append it to {\tt x}.
\begin{verbatim}
seq[~things *+a_thing *![x.append(_)]]
\end{verbatim}
\end{quote}
\end{document}