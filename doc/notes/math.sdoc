Mathematical constructs in caterwaul 1.0.
Caterwaul is no longer just about transforming syntax in convenient ways. It's also about doing totally off the hook stuff with macros and adding structure to its extensions.

| 1. Macros should have standard forms. One common one is the "adverb", which includes things like when[], unless[], where[], se[], re[], etc.
  2. Expressions should have well-defined destructuring semantics (see below).

Destructuring.
The lvalue() macro needs to become significantly more capable. Here's an example:

| Foo = fc[x, y][this.x = x, this.y = y];
  Bar = fc[x, y][this.x = x, this.y = y];
  f(new Foo(x, y)) = x + y;
  f(new Bar(x, y)) = x * y;
  f(new Foo(3, 4))      // returns 7
  f(new Bar(3, 4))      // returns 12

| f(x + 1) = Number(x) * 2
  f(4)                  // returns 6
  f('41')               // returns 8

I'm not 100% sure how to do the failover for pattern matching because it requires knowledge of previous cases. The generated code would have to end up looking like this:

| Foo = ...
  Bar = ...
  f = function (gs_value) {
    var gs_bindings = null;
    if (gs_value.constructor === Foo && Foo.gs_caterwaul_invert && (gs_bindings = Foo.gs_caterwaul_invert(gs_value)))
      return (function (x, y) {return x + y}).call(this, gs_bindings.x, gs_bindings.y);
    else if (gs_value.constructor === Bar && Bar.gs_caterwaul_invert && (gs_bindings = Bar.gs_caterwaul_invert(gs_value)))
      return (function (x, y) {return x * y}).call(this, gs_bindings.x, gs_bindings.y);
    else
      return undefined;
  };

  Implementing function inversion.
  It's possible to invert a function. All we have to do is assign it combinatory semantics and then invert each combinator in turn. For instance:

  | f(x, y) = {foo: x, bar: y}                                  // If this definition is made...
    f.gs_caterwaul_invert(o) = o && {x: o.foo, y: o.bar}        // this one will be too.

  Inversion can happen even over closures:

  | f(g)(x, y) = {foo: x, bar: y, bif: g};
    f(g).gs_caterwaul_invert(o) = o && o.bif === g && {x: o.foo, y: o.bar};
    f.gs_caterwaul_invert(g)(o) = o && o.bif === g && {x: o.foo, y: o.bar};

  Failover.
  This is really tricky. We have to know in advance whether f has been defined. For example:

  | f(x, y) = x + y;
    f(new Foo(bar)) = bar.x + bar.y;

  What does the generated code look like? (Especially considering that each of these is an imperative statement.)

  Interesting case:

  | f(x, y) = x + y;
    f(3, 4);            // should return 7
    f(x + 1, y) = x * y;
    f(3, 4);            // should return 8

  Actually, we don't care whether f is already defined; we can assume it:

  | f(x, y) = x + y
    f(new Foo(bar)) = bar.x * bar.y;

  Here's the code:

  | f = function (x, y) {return x + y};         // No modifiers; gets inlined into an erasing assignment
    f = (function (old_f) {
      var this_case = function (x, y) {return x * y};
      return function (gensym) {
        var gensym_result = Foo && Foo.gensym_caterwaul_invert && Foo.gensym_caterwaul_invert(gensym);
        if (gensym_result) return this_case.call(this, gensym_result.x, gensym_result.y);
        else return old_f.apply(this, arguments);
      };
    }).call(this, typeof f === 'undefined' ? function () {throw new Error('no matching case for f')} : f);

  It's true that this imposes a linear-time overhead in the number of cases, but it's the best we can do for dynamic assignment.

  Consequences of ubiquitous inversion.
  One nice side-effect of assigning an inverse to every function is that you can have pattern-matching functions invert each other:

  | f(x, y) = x + y
    g(f(x, 1)) = x * 2
    g(10)               // -> 18

  Perhaps more interestingly:

  | modifier(m, x) = m + ' ' + x;
    variable(n, v) = n + ' = ' + v;
    g(modifier('var', variable('x', value))) = alert('x is assigned ' + value);

  We'd have to detect the presence of a constant in the destructuring pattern and propagate it through the combinatory logic somehow. (This is computationally expensive!) However, it's also
  really important to be able to do.

  Anonymous destructuring functions.
  There isn't a good reason fn[] couldn't take on destructuring semantics. The only difficulty is having multiple alternatives.

  | fn[new Foo(x, y)][x + y]
    fn[x + 1][x * (x + 1)]

  Ultimately the problem is that Javascript doesn't have a way to represent parameter-based multiple dispatch. So pattern matching is something that gets superimposed at the last minute.