Usability for common problems.
I'm not 100% sure that a declarative rewriting approach will be powerful enough to cover all of the possibilities. For example, is it possible to encode all of the seq library rules?
(Actually, I know the answer to this. It isn't possible at present because there is no way to declare the arity of a syntax variable.) So arity-specific matching is a must. I could commandeer
@ as an identifier character to make this work.

So, given arity-specific matching, here's a rough attempt at modeling part of the sequence library:

| @seq(_xs *  [_body]) = @ssa(for (var _xs1 = (_xs), _i = 0, _l = _xs1.length, _ys = new _xs1.constructor(), _x; _i < _l; ++_i) _x = _xs1[_i], _ys.push((_body)); _ys)
  @seq(_xs *! [_body]) = @ssa(..., _xs1)
  @seq(_xs *~ [_body]) = @ssa(... push((@seq(_body))); _ys)
  @seq(_xs *~![_body]) = @ssa(...)
  @seq(_xs *!~[_body]) = @ssa(... @seq(_body); _xs1)
  @seq(_xs *_f@0)      = @ssa(... _f(_x); _ys)
  @seq(_xs *_x[_body]) = @ssa(... _ys.push((_body)); _ys)

I think this will work. Now how about stitching together SSA segments into a regular program?

Assembling functional expressions.
Suppose you've got a complex sequence expression that uses more than one operator. For example, xs *[x + 1] *[x + 2]. Then you'll get nested SSA expressions that look like this:

| @ssa(for (var _xs1 = (@ssa(...; _ys1)), ...) ...; _ys2)

The second @ssa is obviously a dependency of the first since it appears as a descendant. However, it is unclear how to write a rule that would unfold these into canonical imperative form and
then link the variables together. This may need to be done with a non-declarative link step. This link step will probably make use of some of the same optimizations that are used to optimize
declarative rewrites.
