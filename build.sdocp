sdocp('build.sdoc', '#!/bin/bash\n\nCaterwaul build script | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nUnit testing functions.\nThese helper functions are used for unit tests. Because node.js doesn\'t accept multiple JS files as arguments, we first concatenate the files together and then hand that to node.js. Each test\nis run separately to get an idea of what percentage of the codebase works, although it would also be semantically valid to run all of the tests together in the same environment.\n\n  start() {\n    echo starting $*\n  }\n\n  fail() {\n    echo fail $* >> .test-log\n    echo -e "\\033[1;31mfail $*\\033[0;0m:"\n    return 1\n  }\n\n  pass() {\n    echo pass $* >> .test-log\n  }\n\n  run-node() {\n    start node $*\n    cat "$@" > tmp.js\n    node tmp.js || fail node $* || return 1\n    rm -f tmp.js\n    pass node $*\n  }\n\nBuild phases.\nThere are a few different things that happen here. First, SDoc needs to be run to update the main source, tests, and modules. This happens regardless of what we\'re doing. Next the minified JS\nfiles need to be generated. Each of these things requires little enough time that I\'m willing to have them run automatically on every build (anything to avoid using a makefile!).\n\n  minify() {\n    node lib/minify.js < $1.js > $1.min.js\n  }\n\n  generate() {\n    sdoc -p . lib test modules modules/*.test\n\n    # Production-worthy files get minified:\n    minify caterwaul\n    minify modules/caterwaul.opt\n    minify modules/caterwaul.format\n  }\n\nTest driver.\nUnit tests are run after the code is generated. You can run the build script without running unit tests, but only for trivial things such as getting LOC counts. Unit tests are a part of the\npackaging process.\n\n  unit() {\n    generate\n    rm -f .test-log\n    for file in test/$1*.js modules/*.test/$1*.js; do\n      run-node caterwaul.js     modules/*.min.js lib/unit.js $file &&\n      run-node caterwaul.min.js modules/*.min.js lib/unit.js $file\n    done\n    grep \'^fail\' .test-log && return 1\n    return 0\n  }\n\nVersion packaging.\nCaterwaul is versioned in the stable/ directory. All production-worthy (i.e. minified) files are included in a versioned release, and a commit ID is also included.\n\n  package() {\n    if [[ -d stable/$1 ]]; then\n      echo package: version $1 already exists\n      return 1\n    fi\n    unit || return 1\n    mkdir stable/$1\n    cp *.min.js modules/*.min.js stable/$1/\n    git add stable/$1\n    git commit -am "Automatic commit for version $1"\n    git tag version-$1\n    cp .git/refs/heads/master stable/$1/commit-id\n    tar -cj stable/$1 > stable/$1.tar.bz2\n    git add stable/$1*\n    git commit -am "Automatic commit for version $1 deployment"\n  }\n\nInformational stuff.\nTrivial build rules that don\'t actually do anything, but exist to provide information about the code.\n\n  loc() {\n    generate\n    echo "core gzip bytes:    $(gzip -c9 caterwaul.min.js | wc -c)"\n    echo "core compact bytes: $(cat caterwaul.min.js | wc -c)"\n\n    rm -f *.min.js modules/*.min.js\n    echo "total LOC/chars:          $(cat test/*.js modules/*.js modules/*.test/*.js caterwaul.js | wc -lm)"\n    echo "core SLOC/chars:          $(grep -v \'//\' < caterwaul.js | grep -v \'^$\' | wc -lm)"\n    echo "core comment LOC/chars:   $(grep \'//\' < caterwaul.js | wc -lm)"\n    echo "core test SLOC/chars:     $(cat test/*.js | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n    echo "module SLOC/chars:        $(cat modules/*.js | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n    echo "module comment LOC/chars: $(cat modules/*.js | grep \'//\' | wc -lm)"\n    echo "module test SLOC/chars:   $(cat modules/*.test/*.js | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n\n    generate\n  }\n\nMain loop.\nThere are only a few things that the main loop provides, mainly to keep the interface simple.\n\n  if [[ build.sdoc -nt build ]]; then\n    sdoc -p build.sdoc\n    $0 "$@"\n  else\n    command=$1\n    shift\n    case $command in\n      unit)     unit "$@" ;;\n      generate) generate "$@" ;;\n      package)  package "$@" ;;\n      loc)      loc "$@" ;;\n      *)        echo "usage: $0 {unit|package|loc}" ;;\n    esac\n  fi\n');