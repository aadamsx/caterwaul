sdocp('build.sdoc', '#!/bin/bash\n\nCaterwaul build script | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nUnit testing functions.\nThese helper functions are used for unit tests. Because node.js doesn\'t accept multiple JS files as arguments, we first concatenate the files together and then hand that to node.js. Each test\nis run separately to get an idea of what percentage of the codebase works, although it would also be semantically valid to run all of the tests together in the same environment.\n\n  start() {\n    echo starting $*\n  }\n\n  fail() {\n    echo fail $* >> .test-log\n    echo -e "\\033[1;31mfail $*\\033[0;0m:"\n    return 1\n  }\n\n  pass() {\n    echo pass $* >> .test-log\n  }\n\n  run-node() {\n    start node $*\n    sleep 0.1\n    cat "$@" > tmp.js\n    node tmp.js || fail node $* || return 1\n    rm -f tmp.js\n    pass node $*\n  }\n\nBuild phases.\nThere are a few different things that happen here. First, SDoc needs to be run to update the main source, tests, and modules. This happens regardless of what we\'re doing. Next the minified JS\nfiles need to be generated. Each of these things requires little enough time that I\'m willing to have them run automatically on every build (anything to avoid using a makefile!).\n\nCaterwaul is particular about the order in which scripts are loaded. Because that\'s a pain to deal with, I\'m generating a precompiled file called \'caterwaul.all.js\' (and a corresponding\nmin.js) that loads all of the usual stuff in the right order.\n\n  minify() {\n    node lib/minify.js < $1.js > $1.min.js\n  }\n\n  generate() {\n    sdoc -p . lib test modules modules/*.test\n\n    # Production-worthy files get minified:\n    minify caterwaul\n    minify modules/caterwaul.std\n    minify modules/caterwaul.opt\n    minify modules/caterwaul.seq\n    minify modules/caterwaul.format\n    minify modules/caterwaul.continuation\n\n    cat caterwaul.js modules/caterwaul.{std,opt,continuation,seq}.js > caterwaul.all.js\n    minify caterwaul.all\n\n    # Keep the test page up-to-date:\n    testpage\n  }\n\nREPL.\nNode provides a nice REPL shell. All we have to do is put in some JavaScript to enable it:\n\n  repl() {\n    generate\n    echo \'require("repl").start("caterwaul> ")\' > /tmp/caterwaul-repl.js\n    run-node caterwaul.js modules/*.min.js /tmp/caterwaul-repl.js\n  }\n\nTest driver.\nUnit tests are run after the code is generated. You can run the build script without running unit tests, but only for trivial things such as getting LOC counts. Unit tests are a part of the\npackaging process.\n\n  unit() {\n    generate\n    rm -f .test-log\n    for file in test/$1*.js modules/*.test/$1*.js; do\n      [[ -f $file ]] && run-node caterwaul.js     modules/{std,opt,continuation,seq}.js     lib/unit.js $file &&\n                        run-node caterwaul.min.js modules/{std,opt,continuation,seq}.min.js lib/unit.js $file\n    done\n    grep \'^fail\' .test-log && return 1\n    return 0\n  }\n\nBrowser testing.\nI\'m too lazy to manually update the test page every time I add a new unit test, so this script generates it from the list of tests that get run when you run build unit. The client-side test\ncode is now factored into lib/unit.client.js.\n\n  testpage() {\n    rm -f test/index.html\n    echo \'<html><head><title>Caterwaul tests</title><script src="../lib/unit.js"></script><script src="../lib/unit.client.js"></script>\' >> test/index.html\n    echo \'<script src="../caterwaul.all.min.js"></script></head>\'                                                                        >> test/index.html\n    echo \'<body><p>Any failing tests will produce log messages below.</p><div id="log"></div>\'                                           >> test/index.html\n\n    find -wholename \'./test/*.js\'           | sed \'s/^/<script src="..\\//;s/$/"><\\/script>/\' >> test/index.html\n    find -wholename \'./modules/*.test/*.js\' | sed \'s/^/<script src="..\\//;s/$/"><\\/script>/\' >> test/index.html\n\n    echo \'</body></html>\' >> test/index.html\n  }\n\nVersion packaging.\nCaterwaul is versioned in the stable/ directory. All production-worthy (i.e. minified) files are included in a versioned release, and a commit ID is also included.\n\n  package() {\n    if [[ -d stable/$1 ]]; then\n      echo package: version $1 already exists\n      return 1\n    fi\n    unit || return 1\n    mkdir stable/$1\n    cp *.min.js modules/*.min.js stable/$1/\n    git add stable/$1\n    git commit -am "Automatic commit for version $1"\n    git tag version-$1\n    cp .git/refs/heads/master stable/$1/commit-id\n    tar -cj stable/$1 > stable/$1.tar.bz2\n    git add stable/$1*\n    git commit -am "Automatic commit for version $1 deployment"\n  }\n\nInformational stuff.\nTrivial build rules that don\'t actually do anything, but exist to provide information about the code.\n\n  loc() {\n    generate\n    echo "core gzip bytes:    $(gzip -c9 caterwaul.min.js | wc -c)"\n    echo "core compact bytes: $(cat caterwaul.min.js | wc -c)"\n\n    rm -f *.min.js modules/*.min.js caterwaul.all.js\n    echo "total LOC/chars:          $(cat test/*.js modules/*.js modules/*.test/*.js caterwaul.js | wc -lm)"\n    echo "core SLOC/chars:          $(grep -v \'//\' < caterwaul.js | grep -v \'^$\' | wc -lm)"\n    echo "core comment LOC/chars:   $(grep \'//\' < caterwaul.js | wc -lm)"\n    echo "core test SLOC/chars:     $(cat test/*.js | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n    echo\n\n    for m in modules/*.js; do\n      echo "Module ${m#modules/}:"\n      echo "  SLOC/chars:        $(cat $m | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n      echo "  comment LOC/chars: $(cat $m | grep \'//\' | wc -lm)"\n      [[ -d ${m/js/test} ]] && echo "  test SLOC/chars:   $(cat ${m/js/test}/*.js | grep -v \'//\' | grep -v \'^$\' | wc -lm)"\n      echo\n    done\n\n    generate\n\n    echo "caterwaul.all.min chars/gzip bytes: $(cat caterwaul.all.min.js | wc -m) / $(gzip -c caterwaul.all.min.js | wc -c)"\n  }\n\nMain loop.\nThere are only a few things that the main loop provides, mainly to keep the interface simple.\n\n  if [[ build.sdoc -nt build ]]; then\n    sdoc -p build.sdoc\n    $0 "$@"\n  else\n    command=$1\n    shift\n    case $command in\n      repl)     repl "$@" ;;\n      unit)     unit "$@" ;;\n      generate) generate "$@" ;;\n      package)  package "$@" ;;\n      loc)      loc "$@" ;;\n      *)        echo "usage: $0 {unit|package|loc}" ;;\n    esac\n  fi\n');