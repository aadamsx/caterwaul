#!/bin/bash

Caterwaul build script | Spencer Tipping
Licensed under the terms of the MIT source code license

Unit testing functions.
These helper functions are used for unit tests. Because node.js doesn't accept multiple JS files as arguments, we first concatenate the files together and then hand that to node.js. Each test
is run separately to get an idea of what percentage of the codebase works, although it would also be semantically valid to run all of the tests together in the same environment.

  start() {
    echo starting $*
  }

  fail() {
    echo fail $* >> .test-log
    echo -e "\033[1;31mfail $*\033[0;0m:"
    return 1
  }

  pass() {
    echo pass $* >> .test-log
  }

  run-node() {
    start node $*
    sleep 0.1
    cat "$@" > tmp.js
    node tmp.js || fail node $* || return 1
    rm -f tmp.js
    pass node $*
  }

Build phases.
There are a few different things that happen here. First, SDoc needs to be run to update the main source, tests, and modules. This happens regardless of what we're doing. Next the minified JS
files need to be generated. Each of these things requires little enough time that I'm willing to have them run automatically on every build (anything to avoid using a makefile!).

  minify() {
    node lib/minify.js < $1.js > $1.min.js
  }

  generate() {
    sdoc -p . lib test modules modules/*.test

    # Production-worthy files get minified:
    minify caterwaul
    minify modules/caterwaul.iter
    minify modules/caterwaul.seq
    minify modules/caterwaul.op
    minify modules/caterwaul.opt
    minify modules/caterwaul.format
    minify modules/caterwaul.error
    minify modules/caterwaul.continuation
  }

REPL.
Node provides a nice REPL shell. All we have to do is put in some JavaScript to enable it:

  repl() {
    generate
    echo 'require("repl").start("caterwaul> ")' > /tmp/caterwaul-repl.js
    run-node caterwaul.js modules/*.min.js /tmp/caterwaul-repl.js
  }

Test driver.
Unit tests are run after the code is generated. You can run the build script without running unit tests, but only for trivial things such as getting LOC counts. Unit tests are a part of the
packaging process.

  unit() {
    generate
    rm -f .test-log
    for file in test/$1*.js modules/*.test/$1*.js; do
      [[ -f $file ]] && run-node caterwaul.js     modules/*.min.js lib/unit.js $file &&
                        run-node caterwaul.min.js modules/*.min.js lib/unit.js $file
    done
    grep '^fail' .test-log && return 1
    return 0
  }

Version packaging.
Caterwaul is versioned in the stable/ directory. All production-worthy (i.e. minified) files are included in a versioned release, and a commit ID is also included.

  package() {
    if [[ -d stable/$1 ]]; then
      echo package: version $1 already exists
      return 1
    fi
    unit || return 1
    mkdir stable/$1
    cp *.min.js modules/*.min.js stable/$1/
    git add stable/$1
    git commit -am "Automatic commit for version $1"
    git tag version-$1
    cp .git/refs/heads/master stable/$1/commit-id
    tar -cj stable/$1 > stable/$1.tar.bz2
    git add stable/$1*
    git commit -am "Automatic commit for version $1 deployment"
  }

Informational stuff.
Trivial build rules that don't actually do anything, but exist to provide information about the code.

  loc() {
    generate
    echo "core gzip bytes:    $(gzip -c9 caterwaul.min.js | wc -c)"
    echo "core compact bytes: $(cat caterwaul.min.js | wc -c)"

    rm -f *.min.js modules/*.min.js
    echo "total LOC/chars:          $(cat test/*.js modules/*.js modules/*.test/*.js caterwaul.js | wc -lm)"
    echo "core SLOC/chars:          $(grep -v '//' < caterwaul.js | grep -v '^$' | wc -lm)"
    echo "core comment LOC/chars:   $(grep '//' < caterwaul.js | wc -lm)"
    echo "core test SLOC/chars:     $(cat test/*.js | grep -v '//' | grep -v '^$' | wc -lm)"
    echo "module SLOC/chars:        $(cat modules/*.js | grep -v '//' | grep -v '^$' | wc -lm)"
    echo "module comment LOC/chars: $(cat modules/*.js | grep '//' | wc -lm)"
    echo "module test SLOC/chars:   $(cat modules/*.test/*.js | grep -v '//' | grep -v '^$' | wc -lm)"

    generate
  }

Main loop.
There are only a few things that the main loop provides, mainly to keep the interface simple.

  if [[ build.sdoc -nt build ]]; then
    sdoc -p build.sdoc
    $0 "$@"
  else
    command=$1
    shift
    case $command in
      repl)     repl "$@" ;;
      unit)     unit "$@" ;;
      generate) generate "$@" ;;
      package)  package "$@" ;;
      loc)      loc "$@" ;;
      *)        echo "usage: $0 {unit|package|loc}" ;;
    esac
  fi
